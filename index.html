
<!DOCTYPE html>

<html lang="ko">
<head>
<!-- Injected: PART_WEIGHTS (user-defined) -->
<script>
const PART_WEIGHTS = {
  "헤어": 0.5,
  "원피스": 2.0,
  "아우터": 0.2,
  "상의": 1.0,
  "하의": 1.0,
  "양말": 0.3,
  "양말장식": 0.3,
  "신발": 0.4,
  "장식": 0.2,
  "허리": 0.2,
  "특수": 0.2,
  "뷰티": 0.1,
  "반딧불의 영혼": 0.2
};
</script>
<script>
// Force tags to come ONLY from explicit item.tags, never auto-generated.
(function(){
  function ensureArray(x){ if(!x) return []; if(Array.isArray(x)) return x; return String(x).split(/[,\s#]+/).filter(Boolean); }
  window.parseTags = window.parseTags || function(str){ return ensureArray(str); };
  window.getItemTags = function(it){
    try { return ensureArray((it && it.tags) ? it.tags : ''); }
    catch(e){ return []; }
  };
  // Back-compat: provide tgs helper if templates expect it
  window.__tagsFromItem = function(it){ return window.getItemTags(it); };
})();
</script>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>니키 점수계산</title>
<style>
*{box-sizing:border-box}body{font-family:system-ui,AppleSDGothicNeo,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,sans-serif;margin:0;background:#f7f7fb;color:#222}
header{padding:14px 20px;background:#fff;border-bottom:1px solid #eee;top:0;z-index:3}
h1{margin:0 0 6px 0;font-size:20px}
nav.tabs{display:flex;gap:8px;padding:10px 20px;border-bottom:1px solid #eee;background:#fff;top:56px;z-index:2justify-content:center;}
.tab{padding:8px 12px;border:1px solid #ddd;background:#fff;border-radius:10px;cursor:pointer} .tab.active{background:#f0f7ff;border-color:#cfe4ff}
#controls{display:flex;gap:12px;align-items:end;flex-wrap:wrap;padding:12px 20px;background:#fff;top:100px;z-index:1;border-bottom:1px solid #eee}
#controls>div{display:flex;flex-direction:column;gap:6px}
select,textarea,input[type=text],button{padding:8px;border:1px solid #ddd;border-radius:8px;background:#fff}
button{cursor:pointer} button:hover{background:#fafafa}
#tips{padding:6px 20px}
.pill{display:inline-block;margin:4px 6px 0 0;padding:6px 10px;background:#eef6ff;border:1px solid #cfe4ff;border-radius:999px;font-size:12px}
#skills{padding:0 20px 6px 20px}
.skill{display:inline-block;margin:4px 6px 0 0;padding:6px 10px;background:#f4f1ff;border:1px solid #e0daff;border-radius:999px;font-size:12px}
#ownedBox{padding:0 20px 8px 20px}
#list{padding:8px 20px;display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:12px}
.card{background:#fff;border:1px solid #eee;border-radius:14px;padding:12px;box-shadow:0 1px 0 rgba(0,0,0,0.02);display:flex;flex-direction:column;gap:8px}
.card h3{margin:0 0 4px 0;font-size:16px;display:flex;justify-content:space-between;align-items:center}
.badges{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:6px}
.badge{font-size:11px;border:1px solid #eee;padding:4px 8px;border-radius:999px;background:#fafafa}

.badge.tag{background:#fff0fb;border-color:#ffd1f3}
.badges.tags{margin-top:2px}
.badge.owned{background:#eaffea;border-color:#cdeccc}
.score{font-weight:700}
.small{color:#666;font-size:12px}
.empty{padding:24px 20px;color:#666}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.muted{color:#777;font-size:12px}
.copy-btn{font-size:12px;padding:6px 8px;border-radius:8px}
.toast{left:50%;bottom:20px;transform:translateX(-50%);background:#222;color:#fff;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .2s,transform .2s;pointer-events:none}
.toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}
details.tagbox{padding:0 20px} details.tagbox summary{cursor:pointer;user-select:none;padding:6px 0;color:#333}
.tags-panel{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:6px;padding:8px;border:1px solid #eee;border-radius:10px;background:#fff}
.tag-chip{display:flex;gap:6px;align-items:center;font-size:12px;padding:6px 8px;border:1px solid #eee;border-radius:999px;background:#fafafa}
.tag-chip input{margin:0}
.tag-bar{padding:0 20px 8px 20px} .tag-pill{display:inline-block;margin:4px 6px 0 0;padding:4px 10px;background:#f4fbf4;border:1px solid #d9f0d9;border-radius:999px;font-size:12px}
.panel{display:none} .panel.active{display:block}
.table-wrap{padding:10px 20px}
table{width:100%;border-collapse:collapse;background:#fff;border:1px solid #eee;border-radius:12px;overflow:hidden}
th,td{padding:8px 10px;border-bottom:1px solid #f0f0f0;font-size:13px;vertical-align:middle}
thead th{top:0;background:#fafafa;z-index:1} /* sticky fix */
tbody tr:hover{background:#fafcff}
.nowrap{white-space:nowrap} .num{text-align:right}
.group table thead th{ top:auto !important}
.group{margin:14px 20px;border:1px solid #eee;border-radius:12px;background:#fff}
.group summary{padding:10px 12px;cursor:pointer;font-weight:600;border-bottom:1px solid #f5f5f5}
.group .inner{padding:10px 12px}
.countpill{display:inline-block;margin-left:8px;font-size:11px;background:#f0f7ff;border:1px solid #cfe4ff;border-radius:999px;padding:2px 8px}
/* thumbnails */
.thumb{width:65px;height: 65px;border-radius:8px;object-fit:cover;border:1px solid #eee;background:#fafafa}
.thumb.sm{width:32px;height:32px;border-radius:6px}
.card .row.thumbrow{gap:10px;align-items:center}
.imgcol{width:80px;text-align:center}
/* Hide top totals (의상/스테이지/스킬) only */
.countbox{display:none !important}
#controls .muted{display:none !important}
#partCounts{display:flex;flex-wrap:wrap;gap:6px;padding:6px 20px}
#stageFilterBlock label{margin-right:6px}
/* align filters in one row */
#controls .filter-row{display:flex;align-items:center;gap:16px;flex-wrap:wrap}
#controls .filter-row label{margin-right:4px}
/* ensure labels and selects inline */
#controls .filter-row label{margin-right:6px;white-space:nowrap}
#controls .filter-row select{margin-right:16px}
/* Filter styling adjustments */
#controls .filter-row label,
#controls .filter-row select,
#controls .filter-row input[type=checkbox] {
  font-size: 13px;
}
#controls .filter-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: 8px;
  white-space: nowrap;
}
/* Adjust filter alignment */
#controls .filter-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
#controls .filter-row select,
#controls .filter-row label,
#controls .filter-row input[type=checkbox] {
  font-size: 13px;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: 0;
  white-space: nowrap;
}
/* Tighter filter alignment */
#controls .filter-row {
  display: flex;
  align-items: center;
  gap: 2px; /* 최소 간격 */
  flex-wrap: wrap;
}
#controls .filter-row select,
#controls .filter-row label,
#controls .filter-row input[type=checkbox] {
  font-size: 12px;
  margin: 0;
  padding: 2px 4px;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 2px;
  margin: 0;
  white-space: nowrap;
}
/* Ultra tight filter alignment */
#controls .filter-row {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 0px; /* 완전히 붙이기 */
  flex-wrap: nowrap; /* 줄바꿈 방지 */
}
#controls .filter-row select,
#controls .filter-row label,
#controls .filter-row input[type=checkbox] {
  font-size: 12px;
  margin: 0;
  padding: 2px 4px;
}
#controls .filter-row .checkbox-inline {
  display: flex;
  align-items: center;
  gap: 2px;
  margin: 0;
  white-space: nowrap;
}
/* Match filter font size to tab font size */
#controls .filter-row label,
#controls .filter-row select,
#controls .filter-row input[type=checkbox] {
  font-size: 14px; /* 탭과 동일 크기 */
}
#controls .filter-row .checkbox-inline {
  font-size: 14px;
}
/* Match '보유 의상 이름' label and inputs to tab font size */
#ownedBox label,
#ownedBox textarea,
#ownedBox button {
  font-size: 14px;
}
/* Match action buttons to tab font size */
#ownedBox button {
  font-size: 14px !important;
}
#partCounts{ display:none !important; }
#partSummary{ display:none !important; }
.pill-small{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid #e6e6e6;border-radius:999px;font-size:12px;background:#fff;cursor:pointer}
.pill-small .k{opacity:.75}
.pill-small .v{font-weight:600}
.partbar .pill-small:hover{background:#f2f2ff;border-color:#dcd8ff}
.small{font-size:12px}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef1ff;border:1px solid #dfe5ff}
.partbar-wrap .muted.small{font-size:12px;color:#666}
.gtab{border:1px solid #e6e6e6;background:#fff;border-radius:999px;padding:2px 10px;font-size:12px;cursor:pointer}
.gtab.is-on{background:#f2f2ff;border-color:#dcd8ff}
.chip{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border:1px solid #e6e6e6;border-radius:999px;font-size:12px;background:#fff;cursor:pointer}
.chip .k{opacity:.75}
.chip .v{font-weight:600}
.chip:hover{background:#f7f7ff;border-color:#dcd8ff}
#partFilter option.groupHdr{font-weight:700}

#itemsTable th, 
#itemsTable td,
#byPartWrap th,
#byPartWrap td {
  text-align: center;
}

</style>
<style>
/* Required item badge & checklist */
.badge.req{background:#fff3cd;border-color:#ffe8a1}
.reqlist{padding:6px 20px}
.reqlist .pill{display:inline-block;margin:4px 6px 0 0;padding:6px 10px;background:#fff7e0;border:1px solid #ffe8a1;border-radius:999px;font-size:12px}
.reqlist .own{background:#eaffea;border-color:#cdeccc}
.reqlist .miss{background:#ffecec;border-color:#ffd1d1}
.reqlist .part{font-weight:600;margin-right:8px}
</style>
<script>
/* === Harden getFilteredList + required name set helpers (replaced clean) === */
(function(){
  // Safe helper: build ownedNameSet from textarea or data attr if present
  function buildOwnedNameSet(){
    try{
      var el = document.getElementById('ownedNamesInput');
      var raw = el ? el.value : '';
      var names = String(raw||'').split(/\s*[\n\r;,]+\s*/).filter(Boolean);
      var set = new Set();
      var norm = (window.normOwnedName || function(s){ return String(s||'').trim().toLowerCase(); });
      names.forEach(n => set.add(norm(n)));
      return set;
    }catch(e){ return new Set(); }
  }
  // expose as lazy getter
  Object.defineProperty(window, 'ownedNameSet', {
    get: function(){ return window._ownedNameSet || (window._ownedNameSet = buildOwnedNameSet()); },
    set: function(v){ window._ownedNameSet = v; }
  });

  var _origGet = window.getFilteredList;
  if (typeof _origGet === 'function'){
    window.getFilteredList = function(){
      try{
        var list = _origGet.apply(this, arguments) || [];
        // ownedOnly filter
        var ownedOnlyEl = document.getElementById('ownedOnly');
        var ownedOnly = ownedOnlyEl ? !!ownedOnlyEl.checked : false;
        if (ownedOnly){
          var hasSet = (window.ownedNameSet instanceof Set) && (typeof window.normOwnedName === 'function');
          if (hasSet){
            list = list.filter(function(it){
              var key = window.normOwnedName(it && it.name);
              return window.ownedNameSet.has(key);
            });
          } else {
            list = list.filter(function(it){ return it && it._owned === true; });
          }
        }
        return Array.isArray(list) ? list : [];
      }catch(e){ return []; }
    };
  }
})();
/* === End: Harden getFilteredList === */
</script>
<style>
.req-badge{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:6px;border:1px solid #ff9b9b;background:#ffecec;color:#d40000;font-weight:600;font-size:12px}
.req-panel{margin:10px 20px;padding:10px;border:1px solid #f3d2d2;background:#fff6f6;border-radius:10px}
.req-panel h3{margin:0 0 8px 0;font-size:14px;color:#b10000}
.req-table{width:100%;border-collapse:collapse;font-size:13px}
.req-table th,.req-table td{border:1px solid #f1c9c9;padding:6px 8px;text-align:left}
.req-table th{background:#ffe3e3}
</style>
<script>
// Display helper: shorten hierarchical labels like "장식 - 머리 - 베일" -> "베일"
function displayShort(txt){
  try{
    var s = String(txt==null ? '' : txt).replace(/\u00A0/g,' ').trim();
    // Normalize separators: treat consecutive hyphen groups uniformly
    s = s.replace(/\s*-\s*/g, ' - ');
    if (s.indexOf(' - ') !== -1){
      var segs = s.split(' - ').map(function(t){ return t.trim(); }).filter(Boolean);
      s = segs[segs.length - 1];
    }
    return s;
  }catch(e){ return txt; }
}
</script>
</head>
<body>
<!-- === DATA FRAMES (hidden) === -->
<iframe id="itemsFrame" src="items_frame_v2.html" style="display:none;width:0;height:0;border:0;"></iframe>
<iframe id="stagesFrame" src="stages_frame_v2.html" style="display:none;width:0;height:0;border:0;"></iframe>
<script>
// Kill MutationObserver globally (surgical, to stop any render loops)
try {
  window.MutationObserver = function(){ return { observe(){}, disconnect(){}, takeRecords(){ return [] } }; };
} catch(e){}
</script>
<!-- INLINE_DATA_REMOVED -->
<script>
// Global aliases and safety
window.items = window.items || [];
window.stages = window.stages || [];
window.ITEMS = window.items;
var items = window.items;
var stages = window.stages;
</script>
<nav class="tabs">
<button class="tab active" data-tab="calc">추천/점수</button>
<button class="tab" data-tab="table">의상 데이터(전체)</button>
<button class="tab" data-tab="by-part">의상 데이터(부위별)</button>
</nav>
<section id="controls">
<div><label>
<div class="filter-row">
<label for="stageSelect">스테이지 선택</label>
<select id="stageSelect"></select>
<label>부위 필터 (그룹)</label><select id="partFilter"><option value="">전체</option>
<optgroup label="의상">
<option value="헤어">헤어</option>
<option value="원피스">원피스</option>
<option value="아우터">아우터</option>
<option value="상의">상의</option>
<option value="하의">하의</option>
<option value="양말">양말</option>
<option value="양말장식">양말장식</option>
<option value="신발">신발</option>
<option value="뷰티">뷰티</option>
<option value="반딧불의 영혼">반딧불의 영혼</option>
</optgroup>
<optgroup label="머리">
<option value="머리">머리</option>
<option value="머리">베일</option>
<option value="머리">헤어핀</option>
<option value="머리">귀장식</option>
</optgroup>
<optgroup label="귀">
<option value="귀">귀</option>
</optgroup>
<optgroup label="목">
<option value="목">목도리</option>
<option value="목">목걸이</option>
</optgroup>
<optgroup label="손">
<option value="손">팔찌(우)</option>
<option value="손">팔찌(좌)</option>
<option value="손">장갑</option>
</optgroup>
<optgroup label="소품">
<option value="소품">소품(우)</option>
<option value="소품">소품(좌)</option>
<option value="소품">양손</option>
</optgroup>
<optgroup label="허리">
<option value="허리">허리</option>
</optgroup>
<optgroup label="특수">
<option value="특수">얼굴</option>
<option value="특수">가슴</option>
<option value="특수">문신</option>
<option value="특수">날개</option>
<option value="특수">꼬리</option>
<option value="특수">전경</option>
<option value="특수">배경</option>
<option value="특수">상단</option>
<option value="특수">하단</option>
<option value="특수">스킨</option>
</optgroup>
</select>
<label>정렬</label><select id="sortBy"><option value="score">점수순</option><option value="name">이름순</option></select>
<label><span class="checkbox-inline"><input id="ownedOnly" type="checkbox"/> 보유만 보기</span></label>
</div>
</label><div>
</div></div>
<div>
<div></div></div>
<div></div>
<div class="muted" style="align-self:center">의상 <span id="itemCount">0</span> · 스테이지 <span id="stageCount">0</span> · 스킬 <span id="skillCount">0</span></div>
</section>
<details class="tagbox">
<summary>태그 필터 (펼치기)</summary>
<div class="row" style="padding:6px 0">
<label><input checked="" name="tagMode" type="radio" value="AND"/> 모두 포함(AND)</label>
<label><input name="tagMode" type="radio" value="OR"/> 하나 이상(OR)</label>
<button id="clearTags">선택 해제</button>
</div>
<div class="tags-panel" id="tagsPanel"></div>
</details>
<div class="tag-bar" id="activeTags"></div>
<section class="panel active" id="panel-calc">
<section id="ownedBox">
<span class="badge" id="ownedSummary" style="margin-left:8px">보유 0 / 전체 0</span>
<div class="row">
<div class="chiprow" id="partChips" style="display:flex;gap:6px;overflow:auto;white-space:nowrap;margin-top:6px"></div>
</div>
<div id="partTabsWrap" style="margin:4px 0">
<div id="partTabs" style="display:flex;gap:6px;align-items:center">
<button class="gtab is-on" data-g="wear">의상</button>
<button class="gtab" data-g="acc">장식</button>
<button class="gtab" data-g="special">특수</button><button class="gtab" data-g="beauty">뷰티</button><button class="gtab" data-g="soul">반딧불의 영혼</button></div>
</div>
<div><label for="ownedInput" style="display:block;margin:4px 0;font-weight:500">보유 의상 이름 (줄바꿈/쉼표/공백 구분)</label></div>
<div class="row" id="ownedModeRow" style="gap:10px; align-items:center; margin:6px 0;">
<label style="font-size:13px;">입력 모드</label>
<label style="font-size:13px;"><input checked="" name="ownedMode" type="radio" value="owned"/> 보유</label>
<label style="font-size:13px;"><input name="ownedMode" type="radio" value="code"/> 코드</label>
<div class="row" id="codeInlineControls" style="display:none; gap:6px; align-items:center;">
<label style="font-size:13px;">부위 선택</label>
<select id="codePartSelectInline" style="min-width:160px;"></select>
<button class="gtab" id="applyCodesBtnInline" type="button">코드 적용</button>
</div>
</div>
<textarea id="ownedInput" placeholder="" style="min-width:420px;min-height:84px"></textarea>
<div class="owned-buttons" style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap">
<button id="exportOwned" type="button">내보내기(.txt)</button>
<button id="importOwned" type="button">불러오기(.txt)</button>
<input accept=".txt" id="importOwnedFile" style="display:none" type="file"/>
</div>
<div class="row" style="align-items:flex-start"></div>
<section id="partSummary" style="margin:10px 0 4px 0">
<div class="row" style="align-items:center;gap:8px">
<h3 style="margin:0;font-size:14px">부위별 개수</h3>
<span class="muted" style="font-size:12px">보유 / 전체(등록)</span>
</div>
<div class="table-wrap" style="margin-top:6px">
<table class="table small" id="partSummaryTable" style="min-width:520px">
<thead>
<tr>
<th style="width:40%">부위</th>
<th style="width:20%">보유</th>
<th style="width:20%">전체</th>
<th style="width:20%">보유율</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div class="muted" style="font-size:12px">행을 클릭하면 해당 부위로 필터가 적용됩니다.</div>
</section>
</section>
<section id="tips"></section><section id="skills"></section>
<div class="empty" id="emptyState">아직 내장된 데이터가 없습니다. 의상/스테이지/스킬을 보내주시면 이 파일에 반영해 드릴게요.</div>
<section id="list" style="display:none"></section>
<div class="toast" id="toast">복사됨</div>
</section>
<section class="panel" id="panel-table">
<div class="table-wrap">
<div class="row" style="justify-content:space-between;padding:6px 0">
<div class="muted">현재 선택된 스테이지 가중치로 <b>계산 점수</b>가 표시됩니다.</div>
<div class="row"><input id="tableSearch" placeholder="이름/부위/태그 검색" style="min-width:220px" type="text"/><button id="tableClear">지우기</button></div>
</div>
<div style="overflow:auto;max-height:70vh">
<table id="itemsTable">
<thead><tr>
<th class="nowrap imgcol">이미지</th><th class="nowrap">부위</th><th>코드</th><th class="nowrap">이름</th><th class="num nowrap">별</th>
<th>화려</th><th>심플</th><th>우아</th><th>활발</th><th>성숙</th>
<th>큐티</th><th>섹시</th><th>청순</th><th>청량</th><th>따뜻</th>
<th>태그</th><th class="num nowrap">계산 점수</th>
</tr></thead>
<tbody></tbody>
</table>
</div>
</div>
</section>
<section class="panel" id="panel-by-part">
<div class="table-wrap" id="byPartWrap"></div>
</section>
<script>
// --- Deduplicate and update "마음의 주말" ---
(function(){
  const arr = (window.items || window.ITEMS || []);
  const keyOf = (it)=> (String(it?.part||'').trim() + "@@" + String(it?.name||'').trim());
  const seen = new Map();
  const dedup = [];
  const copyIfBetter = (tgt, src, p) => {
    const sv = src[p];
    if(sv === undefined || sv === null) return;
    const s = String(sv).trim();
    const tv = tgt[p];
    const t = (tv === undefined || tv === null) ? "" : String(tv).trim();
    if(t === "" || t === "-" ) tgt[p] = sv; // fill empty/placeholder
  };
  const mergeBonus = (tgt, src, p) => {
    const sv = Number(src[p]);
    if(!Number.isFinite(sv)) return;
    const tv = Number(tgt[p]);
    if(!Number.isFinite(tv) || sv !== tv) tgt[p] = sv;
  };
  for(const it of arr){
    const k = keyOf(it);
    if(!seen.has(k)){
      seen.set(k, it);
      dedup.push(it);
    }else{
      const tgt = seen.get(k);
      ["stars","img","tags","flair","simple","elegant","lively","mature","cute","sexy","pure","cool","warm"]
        .forEach(p=> copyIfBetter(tgt, it, p));
      ["flair_bonus","simple_bonus","elegant_bonus","lively_bonus","mature_bonus","cute_bonus","sexy_bonus","pure_bonus","cool_bonus","warm_bonus"]
        .forEach(p=> mergeBonus(tgt, it, p));
    }
  }
  window.items = dedup;

  // Ensure target item exists and is updated with latest data

  let target = window.items.find(it=> String(it.part).trim()==="원피스" && String(it.name).trim()==="마음의 주말");
  if(target){ Object.assign(target, updated); }
  else { window.items.push(updated); }

  // --- Patch score function to include *_bonus if present ---
  try{
    const attrs=['flair','simple','elegant','lively','mature','cute','sexy','pure','cool','warm'];
    const orig = window.scoreItemForStage;
    if(typeof orig !== "function"){
      window.scoreItemForStage = function(item, stage){
        if(!stage) return 0;
  // === Stage-based mine handling (NAME ONLY) ===
  try {
    const nameStr = (item && item.name) ? String(item.name).trim() : "";
    const mineNames = (stage && Array.isArray(stage.mine_items)) ? stage.mine_items : [];
    if (mineNames.length && mineNames.includes(nameStr)) return 0;
  } catch(e) { /* ignore and continue */ }
  // =============================================

  

        const factor = (toNum(stage.weight||9))/9;
        const stageW = {...stage};
        attrs.forEach(a => stageW[a] = toNum(stageW[a]||0) * factor);
        let base = 0;
        for(const a of attrs){
          const grade = (item[a]);
          const bonus = toNum(item[`${a}_bonus`]||0);
          base += toNum(stageW[a]) * (grade + bonus);
        }
        return base * starMultiplier(item.stars) * (PART_WEIGHTS[item.part]||1);
      };
    }else{
      window.scoreItemForStage = function(item, stage){
        if(!stage) return 0;
        const factor = (toNum(stage.weight||9))/9;
        const stageW = {...stage};
        attrs.forEach(a => stageW[a] = toNum(stageW[a]||0) * factor);
        let base = 0;
        for(const a of attrs){
          const grade = (item[a]);
          const bonus = toNum(item[`${a}_bonus`]||0);
          base += toNum(stageW[a]) * (grade + bonus);
        }
        return base * starMultiplier(item.stars) * (PART_WEIGHTS[item.part]||1);
      };
    }
  }catch(e){ console.warn("score patch failed:", e); }
})();
</script>
<script>
/* Global de-duplication by (part + normalized name).
   Name normalization removes spaces/punct and common particles (의/와/과) to catch variants like '소녀의고양이' vs '소녀와 고양이'. */
(function(){
  const arr = (window.items || window.ITEMS || []);
  const normName = (s)=> String(s||"")
    .replace(/[ \t\r\n._-]+/g,"")
    .replace(/[의와과]/g,"") // drop common particles
    .toLowerCase();
  const key = (it)=> String(it.part||"").trim()+"@@"+normName(it.name);
  const best = new Map();
  const merge = (a,b)=>{
    const out = {...a};
    const fields = ["stars","img","tags","flair","simple","elegant","lively","mature","cute","sexy","pure","cool","warm","name","part"];
    const bonuses = ["flair_bonus","simple_bonus","elegant_bonus","lively_bonus","mature_bonus","cute_bonus","sexy_bonus","pure_bonus","cool_bonus","warm_bonus"];
    const isEmpty = (v)=> v==null || String(v).trim()==="" || String(v).trim()==="-";
    // prefer non-empty image
    if(isEmpty(out.img) && !isEmpty(b.img)) out.img = b.img;
    // fill empties
    for(const f of fields){
      if(isEmpty(out[f]) && !isEmpty(b[f])) out[f]=b[f];
    }
    // bonuses: prefer numeric; if both numeric, take larger absolute value
    for(const f of bonuses){
      const av = Number(out[f]);
      const bv = Number(b[f]);
      if(Number.isFinite(bv)){
        if(!Number.isFinite(av) || Math.abs(bv)>Math.abs(av)) out[f]=bv;
      }
    }
    return out;
  };
  for(const it of arr){
    const k = key(it);
    if(!best.has(k)) best.set(k, it);
    else best.set(k, merge(best.get(k), it));
  }
  // Replace items with merged unique list
  const unique = Array.from(best.values());
  window.items = unique;
})();
</script>
<!-- Owned items fix: parse/apply/save/load -->
<script>
(function(){
  const OWNED_KEY = window.OWNED_KEY || 'nikki_owned_names';
  const $ = (id)=> document.getElementById(id);

  // pagination state
  const state = { page: 1, key: '' };

  // Robust split: commas/semicolons/newlines or 2+ spaces separate names.
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=>s.trim())
      .filter(Boolean);
  }
const normName = (s)=> String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'');
      });
    }
    if(saveBtn){
      saveBtn.addEventListener('click', ()=>{
        saveOwned();
        const t = document.getElementById('toast'); if(t){ t.textContent = '로컬 저장 완료'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1000); }
      });
    }
    if(clearBtn){
      clearBtn.addEventListener('click', ()=>{
        setOwned([]);
        if(ta) ta.value = '';
        try{ localStorage.removeItem(OWNED_KEY); }catch(e){}
        if(typeof window.renderAll === 'function') window.renderAll();
        const t = document.getElementById('toast'); if(t){ t.textContent = '보유 초기화'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1000); }
      });
    }
  }

  // Load after the original init, then re-render so badges reflect owned state.
  document.addEventListener('DOMContentLoaded', ()=>{
    loadOwned();
    bindOwnedUI();
    if(typeof window.renderAll === 'function') window.renderAll();
  });
})();
</script>
<!-- De-dup & image fallback patch -->
<script>
(function(){
  const norm = (s)=> String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim();

  function dedupItems(){
    if(!Array.isArray(window.ITEMS)) return {removed:0};
    const seen = new Set();
    const out = [];
    let removed = 0;
    for(const it of window.ITEMS){
      const key = norm(it && it.name);
      if(!key){ out.push(it); continue; }
      if(seen.has(key)){ removed++; continue; }
      seen.add(key);
      out.push(it);
    }
    if(removed > 0){
      window.ITEMS = out;
    }
    return {removed};
  }

  // Global image onerror fallback for Google Drive thumbs
  function attachImgFallback(){
    document.addEventListener('error', function(e){
      const el = e.target;
      if(!(el && el.tagName === 'IMG')) return;
      try{
        const u = new URL(el.src);
        if(u.hostname === 'drive.google.com' && u.pathname === '/thumbnail'){
          const id = u.searchParams.get('id');
          if(id && !el.dataset.fallbackTried){
            el.dataset.fallbackTried = '1';
            el.src = 'https://drive.google.com/uc?export=view&id=' + id;
          }
        }
      }catch(err){ /* ignore */ }
    }, true);
  }

  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    const {removed} = dedupItems();
    attachImgFallback();
    if(typeof window.renderAll === 'function'){
      window.renderAll();
    }
    if(removed){
      const t = document.getElementById('toast'); 
      if(t){ t.textContent = `중복 제거: ${removed}개`; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1200); }
      console.log('[dedup] removed', removed);
    }
  });
})();
</script>
<!-- Strong DOM dedup + image overrides + renderAll wrapper -->
<script>
(function(){
  const TOAST = ()=> document.getElementById('toast');
  const showToast = (msg)=>{ const t=TOAST(); if(!t) return; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200); };

  const NORM = (s)=> String(s||'')
    .toLowerCase()
    .replace(/[\u3000\u00A0\s]+/g,'')   // all spaces
    .replace(/[~!@#$%^&*()\-_=+\[\]{};:'"\\|,<.>/?·・｡、，．]/g,''); // punctuation

  // Known image overrides by visible name => Drive file id
  const IMG_OVERRIDES = {
    "시어썸머":"16h2tV0wFSxU7F4uNePec9l7R2pE2xN-t",
    "씨솔트크림":"1uVgAy0iUKQA5GqVeZa1EdokPnxfqeIPp"
  };

  function findName(el){
    if(!el) return "";
    if(el.dataset && el.dataset.name) return el.dataset.name;
    // common title/name nodes
    let t = el.querySelector('[data-field="name"], .item-name, .card-title, .title, .name, .label');
    if(t && t.textContent) return t.textContent.trim();
    // aria/alt fallbacks
    if(el.getAttribute){
      const a = el.getAttribute('aria-label') || el.getAttribute('title') || "";
      if(a) return a.trim();
    }
    return "";
  }

  function dedupDOM(){
    const cards = Array.from(document.querySelectorAll('[data-item], [data-name], .item-card, .card, li'));
    const seen = new Set();
    let removed = 0;
    for(const el of cards){
      const nm = findName(el);
      if(!nm) continue;
      const key = NORM(nm);
      if(!key) continue;
      if(seen.has(key)){
        el.remove();
        removed++;
      }else{
        seen.add(key);
      }
    }
    if(removed) showToast(`중복 제거: ${removed}개`);
    return removed;
  }

  function fixImages(){
    // Attach global onerror fallback once
    if(!window.__imgFallbackAttached){
      document.addEventListener('error', function(e){
        const el = e.target;
        if(!(el && el.tagName === 'IMG')) return;
        try{
          const u = new URL(el.src);
          if(u.hostname === 'drive.google.com' && u.pathname === '/thumbnail'){
            const id = u.searchParams.get('id');
            if(id && !el.dataset.fallbackTried){
              el.dataset.fallbackTried = '1';
              el.src = 'https://drive.google.com/uc?export=view&id='+id;
            }
          }
        }catch(err){}
      }, true);
      window.__imgFallbackAttached = true;
    }

    // Apply explicit overrides by name
    const all = Array.from(document.querySelectorAll('img'));
    for(const img of all){
      const card = img.closest('[data-item], .item-card, .card, li') || img.parentElement;
      const nm = NORM(findName(card));
      if(IMG_OVERRIDES[nm] && !img.dataset.overrideApplied){
        img.dataset.overrideApplied = '1';
        img.src = 'https://drive.google.com/uc?export=view&id='+IMG_OVERRIDES[nm];
      }
    }
  }

  // Wrap renderAll so dedup & image fixes run after every render
  (function wrapRender(){
    if(typeof window.renderAll === 'function'){
      const orig = window.renderAll;
      window.renderAll = function(){
        const r = orig.apply(this, arguments);
        // run after DOM updates
        queueMicrotask(()=>{ fixImages(); dedupDOM(); });
        return r;
      };
    }
  })();

  // Also run once on initial load and whenever DOM changes (defensive)
  document.addEventListener('DOMContentLoaded', ()=>{
    fixImages();
    dedupDOM();
  });
  const mo = /* MO-off */ (null && new MutationObserver)(()=>{ fixImages(); dedupDOM(); });
  mo.observe(document.documentElement, {childList:true, subtree:true});
})();
</script>
<script>

<script>

<script>

<script>
function toThumb(u){
    try{
      if(!u) return u;
      if(/drive\.google\.com\/thumbnail\?id=/.test(u)) return u;
      var m = String(u).match(/\/d\/([a-zA-Z0-9_-]{10,})\/view/);
      if(m) return "https://drive.google.com/thumbnail?id="+m[1];
      if(/^[a-zA-Z0-9_-]{10,}$/.test(u)) return "https://drive.google.com/thumbnail?id="+u;
    }catch(e){}
    return u;
  }
// 
//   var sane = NEW_ITEMS.map(function(it){
    var out = Object.assign({}, it);
    out.img = toThumb(out.img);
    return out;
  });
  if(Array.isArray(window.items)) window.items.push.apply(window.items, sane);
  if(typeof window.renderAll === "function") window.renderAll();
})();

</script>
<script>
(function(){
  var got = {items:false, stages:false};
  function maybeInit(){
    if (got.items && got.stages) {
      if (!window.items) window.items = [];
      if (!window.stages) window.stages = [];
      if (typeof init === 'function') init();
      try{ if(window._loading) window._loading.show(false); }catch(e){}
      try{ if(typeof renderAll==='function') renderAll(); }catch(e){}
    }
  }
  window.addEventListener('message', function(ev){
    var msg = ev.data;
    if (!msg || !msg.__splitData) return;
    if (msg.key==='items'){ window.items = msg.data; got.items = true; try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){} }
    if (msg.key==='stages'){ window.stages = msg.data; got.stages = true; try{ if(typeof __populateStages==='function') __populateStages(); }catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){} }
    maybeInit();
  });
})();
</script>
<script>
(function(){
  var inited = false;
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    if (typeof renderPartCounts === 'function') renderPartCounts();
  };
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  function computePerPart(){
    var items = (window.items || window.ITEMS || []);
    var itemByName = Object.create(null);
    for (var it of items){
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in itemByName)) itemByName[key] = it;
    }
    // totals
    var totals = Object.create(null);
    for (var it of items){
      var p = (it && it.part) || '(기타)';
      if (!totals[p]) totals[p] = 0;
      totals[p]++;
    }
    // owned
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    var owned = Object.create(null);
    for (var n of names){
      var it = itemByName[norm(n)];
      if (!it) continue;
      var p = it.part || '(기타)';
      if (!owned[p]) owned[p] = 0;
      owned[p]++;
    }
    // build rows
    var parts = Object.keys(totals).sort();
    parts = ensureBeautyParts(parts, totals);
    var rows = parts.map(function(p){
      var t = totals[p]||0;
      var o = owned[p]||0;
      var rate = t ? ((o*100)/t).toFixed(1) + '%' : '-';
      return { part:p, owned:o, total:t, rate:rate };
    });
    return rows;
  }
  function renderPerPartTable(){
    var tbody = document.querySelector('#partSummaryTable tbody');
    if (!tbody) return;
    var rows = computePerPart();
    tbody.innerHTML = rows.map(function(r){
      return '<tr data-part=\"'+ r.part.replace(/"/g,'&quot;') +'\">'
        + '<td>'+ r.part +'</td>'
        + '<td>'+ r.owned +'</td>'
        + '<td>'+ r.total +'</td>'
        + '<td>'+ r.rate +'</td>'
        + '</tr>';
    }).join('');
  }
  // click -> sync to existing partFilter
  document.addEventListener('click', function(ev){
    var tr = ev.target && ev.target.closest && ev.target.closest('#partSummaryTable tbody tr');
    if (!tr) return;
    var part = tr.getAttribute('data-part') || '';
    var sel = document.getElementById('partFilter');
    if (sel){
      // Try to match exact option; fallback to empty if not found
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);
  // keep table in sync
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){ renderPerPartTable(); }
  });
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    renderPerPartTable();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(renderPerPartTable, 50); });
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  
  function ensureBeautyParts(parts, totals){
    try{
      if (totals && typeof totals==='object' && !('뷰티' in totals)) totals['뷰티'] = 0;
      if (Array.isArray(parts)){
        if (parts.indexOf('뷰티') === -1){
          // place after '신발' if present, else at end
          var idx = parts.indexOf('신발');
          if (idx !== -1) parts.splice(idx+1, 0, '뷰티');
          else parts.push('뷰티');
        }
      }
    }catch(e){}
    return parts;
  }

  function computePartStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var it of items){
      var p = it && it.part || '(기타)';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    var ownedPer = Object.create(null);
    var ownedTotal = 0;
    for (var n of names){
      var it = byName[norm(n)];
      if (it){
        var p = it.part || '(기타)';
        ownedPer[p] = (ownedPer[p]||0)+1;
        ownedTotal++;
      }
    }
    var totalCount = (window.items||window.ITEMS||[]).length;
    // Build sorted parts
    var parts = Object.keys(totals).sort();
    parts = ensureBeautyParts(parts, totals);
    return {parts:parts, totals:totals, ownedPer:ownedPer, ownedTotal:ownedTotal, totalCount: totalCount};
  }
  
  function ensureBeauty(parts){
    if (!Array.isArray(parts)) return parts;
    if (parts.indexOf('뷰티') === -1){
      // Insert after '신발' if present, else push at end
      var idx = parts.indexOf('신발');
      if (idx !== -1) parts.splice(idx+1, 0, '뷰티');
      else parts.push('뷰티');
    }
    return parts;
  }

  function renderPartBar(){
    var bar = document.getElementById('partBar');
    if (!bar) return;
    var stats = computePartStats();
    // Summary mini
    var mini = document.getElementById('ownedSummaryMini');
    if (mini){ mini.textContent = '보유 ' + stats.ownedTotal + ' / 전체 ' + stats.totalCount; }

    bar.innerHTML = stats.parts.map(function(p){
      var o = stats.ownedPer[p] || 0;
      
    var t = stats.totals[p] || 0;
      return '<span class="pill-small" data-part="'+ p.replace(/"/g,'&quot;') +'" title="'+ p +'">'
        + '<span class="k">'+ (typeof displayShort==='function'?displayShort(p):p) +'</span>'
        + '<span class="v">'+ o +'/'+ t +'</span>'
        + '</span>';
    }).join('');
    try{ window.shortenChipLabels(); }catch(e){}
  }
  // Click a pill -> sync to existing part filter
  document.addEventListener('click', function(ev){
    var el = ev.target.closest && ev.target.closest('.pill-small');
    if (!el) return;
    var part = el.getAttribute('data-part') || '';
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);
  // Toggle collapse (single line vs hidden)
  document.addEventListener('click', function(ev){
    if (ev.target && ev.target.id === 'togglePartBar'){
      var bar = document.getElementById('partBar');
      if (!bar) return;
      var isHidden = bar.style.display === 'none';
      bar.style.display = isHidden ? 'flex' : 'none';
      ev.target.textContent = isHidden ? '접기' : '펼치기';
    }
  });
  // Update on input & after init
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){ renderPartBar(); }
  });
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    renderPartBar();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(renderPartBar, 50); });
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  function computeStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = {}, byName={};
    totals['뷰티'] = totals['뷰티'] || 0;
    for (var it of items){
      var p = it && it.part || '(기타)';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    var ownedPer = {}, ownedTotal = 0;
    for (var n of names){
      var it = byName[norm(n)];
      if (it){
        var p = it.part || '(기타)';
        ownedPer[p] = (ownedPer[p]||0)+1;
        ownedTotal++;
      }
    }
    return {totals:totals, ownedPer:ownedPer, ownedTotal:ownedTotal, totalCount:items.length};
  }
  function renderPartBar(){
    var stats = computeStats();
    var mini = document.getElementById('ownedSummaryMini');
    if (mini){ mini.textContent = '보유 ' + stats.ownedTotal + ' / 전체 ' + stats.totalCount; }
    var bar = document.getElementById('partBar');
    if (!bar) return;
    var parts = [];
    var sel = document.getElementById('partFilter');
    if (sel){
      for (var i=0;i<sel.options.length;i++){
        var v = sel.options[i].value;
        if (!v) continue; // skip 전체
        parts.push(v);
      }
    } else {
      parts = Object.keys(stats.totals).sort();
    }
    parts = ensureBeauty(parts);
    bar.innerHTML = parts.map(function(p){
      var o = stats.ownedPer[p]||0;
      
    try{ window.shortenChipLabels(); }catch(e){}
var t = stats.totals[p]||0;
      return '<span class="pill-small" data-part="'+ p.replace(/"/g,'&quot;') +'">'
        + '<span class="k">'+ (typeof displayShort==='function'?displayShort(p):p) +'</span>'
        + '<span class="v">'+ o +'/'+ t +'</span>'
        + '</span>';
    }).join('');
  }
  window.renderPartBar = renderPartBar;
  // Hook to init
  var origInit = window.init;
  window.init = function(){
    if (typeof origInit === 'function') origInit();
    renderPartBar();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(renderPartBar,50); });
  document.addEventListener('input', function(ev){ if(ev.target && ev.target.id==='ownedInput') renderPartBar(); });
})();
</script>
<script>
(function(){
  
  var ORDER_WEAR = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];
var ORDER_BEAUTY = ["뷰티"];
var ORDER_SOUL = ["반딧불의 영혼"];
  var ORDER_ACC = [
    "장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식","장식 - 귀",
    "장식 - 목 - 목도리","장식 - 목 - 목걸이",
    "장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑",
    "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손","장식 - 허리",
    "장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리",
    "장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨",
    "반딧불의 영혼"
  ];
  var GROUPS = { wear: ORDER_WEAR, acc: ORDER_ACC, beauty: ORDER_BEAUTY, soul: ORDER_SOUL };

  function norm(s){ return String(s||'').toLowerCase().replace(/[\\s\\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\\n\\r;,]+|\\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function pill(part, o, t){
    return '<span class="chip" data-part="'+ part.replace(/"/g,'&quot;') +'" title="'+ part +'"><span class="k">'+ part +'</span><span class="v">'+ (o||0) +'/'+ (t||0) +'</span></span>';
  }
  function renderChips(groupKey){
    var row = document.getElementById('partChips');
    if (!row) return;
    var stats = getStats();
    var order = GROUPS[groupKey] || [];
    if (!order || order.length === 0){ order = ["뷰티"]; }
    row.innerHTML = order.map(function(p){
      var o = stats.ownedPer[p] || 0;
      
    var t = stats.totals[p] || 0;
      return pill(p, o, t);
    }).join('');
    try{ window.shortenChipLabels(); }catch(e){}

  }
  function setGroup(g){
  var tabs = document.querySelectorAll('#partTabs .gtab');
  tabs.forEach(function(b){
    b.classList.toggle('is-on', b.getAttribute('data-g') === g);
  });
  if (g === 'special'){
    try { renderSpecialChips(); } catch(e){ console.error('특수 렌더링 오류', e); }
  } else {
    try { renderChips(g); } catch(e){ console.error('일반 렌더링 오류', e); }
  }
})();
</script>
<script>
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function computeOwnedTotal(){
    var items = (window.items || window.ITEMS || []);
    var total = items.length || 0 + GRADE_OFFSET[item.grade];
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = true;
    }
    var ta = document.getElementById('ownedInput');
    var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    var owned = 0;
    for (var j=0;j<names.length;j++){
      if (byName[window.normOwnedName(names[j])]) owned++;
    }
    return {owned: owned, total: total};
  }
  function updateOwnedBadges(){
    var c = computeOwnedTotal();
    var el1 = document.getElementById('ownedSummary');
    var el2 = document.getElementById('ownedSummaryMini');
    if (el1) el1.textContent = '보유 ' + c.owned + ' / 전체 ' + c.total;
    if (el2) el2.textContent = '보유 ' + c.owned + ' / 전체 ' + c.total;
  }
  // hook: after init (data loaded)
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    updateOwnedBadges();
  };
  // live update on input changes
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput') updateOwnedBadges();
  });
  // fallback on DOM ready
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(updateOwnedBadges, 100); });
  window.updateOwnedBadges = updateOwnedBadges;
})();
</script>
<script>
(function(){
  function markPartHeaders(){
    var sel = document.getElementById('partFilter');
    if (!sel) return;
    var headers = new Set(['팔찌','등 장식','특수 아이템']);
    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      if (headers.has(opt.text.trim())){
        opt.disabled = true;            // 선택 불가
        opt.classList.add('groupHdr');  // 진하게(볼드)
      }
    }
    // 만약 현재 선택이 헤더라면 전체로 초기화
    if (sel.selectedIndex >= 0 && sel.options[sel.selectedIndex].disabled){
      sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }
  // run after init and on DOM ready
  var __origInit_headers = window.init;
  window.init = function(){
    if (typeof __origInit_headers === 'function') __origInit_headers();
    markPartHeaders();
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(markPartHeaders, 50); });
  window.markPartHeaders = markPartHeaders;
})();
</script>
<script>
(function(){
  var ORDER_WEAR = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];

  function norm(s){ return String(s||'').toLowerCase().replace(/[\\s\\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\\n\\r;,]+|\\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function sumCounts(keys, map){
    var s = 0;
    for (var i=0;i<keys.length;i++){
      s += map[keys[i]] || 0;
    }
    return s;
  }
  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    var lbl = String(label||'');
    try{
      if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
        var segs = lbl.split(' - ');
        lbl = segs[segs.length-1];
      }
    }catch(e){}
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ owned +'/'+ total +'</span>'
         + '</span>';
  }
  function renderChips_acc(S){
    var html = [];
    // singles
    var singles = ACC_SINGLES;
    for (var i=0;i<singles.length;i++){
      var p = singles[i];
      html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
    }
    // subgroups aggregate badges (no click filter for now)
    html.push(chipHtml("팔찌",        sumCounts(ACC_PALJJI, S.ownedPer), sumCounts(ACC_PALJJI, S.totals), ""));
    html.push(chipHtml("등 장식",     sumCounts(ACC_BACK,   S.ownedPer), sumCounts(ACC_BACK,   S.totals), ""));
    html.push(chipHtml("특수 아이템", sumCounts(ACC_SPEC,   S.ownedPer), sumCounts(ACC_SPEC,   S.totals), ""));
    return html.join('');
  }
  function renderChips(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    if (groupKey === 'wear'){
      row.innerHTML = ORDER_WEAR.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      
    
    try{ window.shortenChipLabels(); }catch(e){}
try{ relabelDecorations(); }catch(e){};
}).join('');
    } else if (groupKey === 'acc'){
      row.innerHTML = renderChips_acc(S);
    } else if (groupKey === 'beauty'){
      row.innerHTML = ORDER_BEAUTY.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }
    else if (groupKey === 'soul'){
      row.innerHTML = (ORDER_SOUL || ['반딧불의 영혼']).map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    }).join('');
    }).join('');
    }
  }
  function setGroup(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips(g);
  }
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return; // aggregated badges do nothing on click
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup(on ? on.getAttribute('data-g') : 'wear');
    }
  });
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    setGroup('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup('wear'); }, 50); });
})();
</script>
<script>
// --- override for accessory aggregated chips ---
(function(){
  var ORDER_WEAR = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];

  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function sumCounts(keys, map){
    var s = 0;
    for (var i=0;i<keys.length;i++) s += map[keys[i]] || 0;
    return s;
  }
  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ owned +'/'+ total +'</span>'
         + '</span>';
  }
  function renderChips2(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    var html = [];
    if (groupKey === 'wear'){
      ORDER_WEAR.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    } else if (groupKey === 'acc'){
      ACC_SINGLES.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      }
    else if (groupKey === 'soul'){
      row.innerHTML = (ORDER_SOUL || ['반딧불의 영혼']).map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      
    try{ window.shortenChipLabels(); }catch(e){}
}).join('');
    }
    else if (groupKey === 'beauty'){
      row.innerHTML = (ORDER_BEAUTY || ['뷰티']).map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    });
      html.push(chipHtml("팔찌",        sumCounts(ACC_PALJJI, S.ownedPer), sumCounts(ACC_PALJJI, S.totals), ""));
      html.push(chipHtml("등 장식",     sumCounts(ACC_BACK,   S.ownedPer), sumCounts(ACC_BACK,   S.totals), ""));
      html.push(chipHtml("특수 아이템", sumCounts(ACC_SPEC,   S.ownedPer), sumCounts(ACC_SPEC,   S.totals), ""));
    } else if (groupKey === 'beauty'){
      ORDER_BEAUTY.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    }
    row.innerHTML = html.join('');
  }
  function setGroup2(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips2(g);
  }
  // Override globals if any
  window.renderChips = renderChips2;
  window.setGroup = setGroup2;

  // Rebind tab clicks to our setGroup
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (t){
      setGroup2(t.getAttribute('data-g'));
    }
  });

  // Re-render on owned input
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup2(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // Run once after init
  var __origInit2 = window.init;
  window.init = function(){
    if (typeof __origInit2 === 'function') __origInit2();
    setGroup2('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup2('wear'); }, 60); });
})();
</script>
<script>
(function(){
  var ORDER_WEAR = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];

  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\\r;,]+|\\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getStats(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = window.normOwnedName(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function shortLabel(full){
    var prefixes = ["팔찌 - ", "등 장식 - ", "특수 아이템 - "];
    for (var i=0;i<prefixes.length;i++){
      if (full.indexOf(prefixes[i]) === 0) return full.slice(prefixes[i].length);
    }
    return full;
  }
  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ owned +'/'+ total +'</span>'
         + '</span>';
  }
  function renderChips2(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    var html = [];
    if (groupKey === 'wear'){
      ORDER_WEAR.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    } else if (groupKey === 'acc'){
      // Singles
      ACC_SINGLES.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      }
    else if (groupKey === 'soul'){
      row.innerHTML = (ORDER_SOUL || ['반딧불의 영혼']).map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      
    try{ window.shortenChipLabels(); }catch(e){}
}).join('');
    }
    else if (groupKey === 'beauty'){
      row.innerHTML = (ORDER_BEAUTY || ['뷰티']).map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    });
      // Detailed sub-items with short labels (but data-part stays full for filter)
      var all = ACC_PALJJI.concat(ACC_BACK).concat(ACC_SPEC);
      all.forEach(function(full){
        var lbl = shortLabel(full);
        html.push(chipHtml(lbl, S.ownedPer[full]||0, S.totals[full]||0, full));
      });
    } else if (groupKey === 'beauty'){
      ORDER_BEAUTY.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      });
    }
    row.innerHTML = html.join('');
  }
  function setGroup2(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips2(g);
  }
  // Override previous globals
  window.renderChips = renderChips2;
  window.setGroup = setGroup2;

  // Tab click
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (t) setGroup2(t.getAttribute('data-g'));
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (chip){
      var part = chip.getAttribute('data-part') || '';
      if (!part) return;
      var sel = document.getElementById('partFilter');
      if (sel){
        // match by value (full part); fallback to text
        var found = false;
        for (var i=0;i<sel.options.length;i++){
          var opt = sel.options[i];
          if (opt.value === part || opt.text.trim() === part){
            sel.selectedIndex = i; found = true; break;
          }
        }
        if (!found) sel.value = '';
        sel.dispatchEvent(new Event('change', {bubbles:true}));
      }
    }
  });

  // Owned input change -> refresh
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup2(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // After init
  var __origInit2 = window.init;
  window.init = function(){
    if (typeof __origInit2 === 'function') __origInit2();
    setGroup2('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup2('wear'); }, 60); });
})();
</script>
<script>
// ---- Robust owned-name -> item.part matching + chip counts refresh ----
(function(){
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    // 줄바꿈 / 쉼표 / 세미콜론 / 2칸 이상의 공백 구분
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(function(s){ return s.trim(); })
      .filter(Boolean);
  }

  // Map owned names (입력란) -> item.part 카운트
  function getStatsOwnedAware(){
    var items = (window.items || window.ITEMS || []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i]; if (!it) continue;
      var p = it.part || '';
      totals[p] = (totals[p]||0) + 1;
      var key = window.normOwnedName(it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue; // 입력한 이름이 데이터에 없으면 무시
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0) + 1;
    }
    return { totals: totals, ownedPer: ownedPer };
  }

  // Helper: prefix 제거한 짧은 라벨
  function shortLabel(full){
    var prefixes = ["팔찌 - ", "등 장식 - ", "특수 아이템 - "];
    for (var i=0;i<prefixes.length;i++){
      if (full.indexOf(prefixes[i]) === 0) return full.slice(prefixes[i].length);
    }
    return full;
  }

  // Accessory lists (revised by user's part groups)
var ORDER_WEAR = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];
var ACC_HEAD     = ["장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식","장식 - 귀","장식 - 목 - 목도리","장식 - 목 - 목걸이"];
var ACC_HAND     = ["장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑"];
var ACC_PROP     = ["장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손","장식 - 허리"];
var ACC_SPECIAL  = ["장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리","장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"];
var ACC_OTHER    = ["반딧불의 영혼"];
      // 개별 액세서리 (그룹 접두사 없는 항목)
      ACC_SINGLES.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p], S.totals[p], p));
      });
      // 소그룹 세부 항목들 - 라벨은 짧게, 값은 풀네임
      ACC_PALJJI.concat(ACC_BACK).concat(ACC_SPEC).forEach(function(full){
        html.push(chipHtml(shortLabel(full), S.ownedPer[full], S.totals[full], full));
      });
    } else if (groupKey === 'beauty'){
      ORDER_BEAUTY.forEach(function(p){
        html.push(chipHtml(p, S.ownedPer[p], S.totals[p], p));
      });
    }
    row.innerHTML = html.join('');
  }

  function setGroup_fixed(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    renderChips_fixed(g);
  }

  // Override any previous versions
  window.renderChips = renderChips_fixed;
  window.setGroup = setGroup_fixed;

  // Click on chip -> filter by full part (data-part)
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return;
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        var opt = sel.options[i];
        if (String(opt.value).trim() === part){
          sel.selectedIndex = i; found = true; break;
        }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);

  // Re-render on owned input change
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      setGroup_fixed(on ? on.getAttribute('data-g') : 'wear');
    }
  });

  // Hook into init to ensure counts after data load
  var __orig = window.init;
  window.init = function(){
    if (typeof __orig === 'function') __orig();
    setGroup_fixed('wear');
  };
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){}; setTimeout(function(){ setGroup_fixed('wear'); }, 80); });
})();
</script>
<script>
// --- Robust data resolver: read items from main or from data iframes ---
(function(){
  function resolveItems(){
    // 1) direct on window
    if (Array.isArray(window.items))  return window.items;
    if (Array.isArray(window.ITEMS))  return window.ITEMS;

    // 2) known iframe by id/name
    var f = document.getElementById('itemsFrame') || document.querySelector('iframe#itemsFrame, iframe[name="itemsFrame"]');
    if (f && f.contentWindow){
      try{
        if (Array.isArray(f.contentWindow.items)) return f.contentWindow.items;
        if (Array.isArray(f.contentWindow.ITEMS)) return f.contentWindow.ITEMS;
      }catch(e){ /* cross-origin or not ready */ }
    }

    // 3) scan any iframe on the page
    var ifs = document.querySelectorAll('iframe');
    for (var i=0;i<ifs.length;i++){
      var cw;
      try{ cw = ifs[i].contentWindow; }catch(e){ continue; }
      if (!cw) continue;
      try{
        if (Array.isArray(cw.items)) return cw.items;
        if (Array.isArray(cw.ITEMS)) return cw.ITEMS;
      }catch(e){ /* ignore */ }
    }
    return null;
  }

  // Expose for other scripts
  window.__resolveItems = resolveItems;

  // Patch getStatsOwnedAware (if defined) to use resolver; otherwise define a safe one.
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }

  function getStatsOwnedAwarePatched(){
    var items = resolveItems() || [];
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i]; if (!it) continue;
      var p = it.part || '';
      totals[p] = (totals[p]||0) + 1;
      var key = window.normOwnedName(it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[window.normOwnedName(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0) + 1;
    }
    return { totals: totals, ownedPer: ownedPer };
  }

  // If a previous function exists, overwrite safely
  window.getStatsOwnedAware = getStatsOwnedAwarePatched;

  // When items become available later, re-render chips & badges automatically
  function refreshIfReady(){
    var arr = resolveItems();
    if (arr && arr.length){
      // refresh chips
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      if (typeof window.setGroup === 'function') window.setGroup(g);

      // refresh owned badges if helpers exist
      if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
      return true;
    }
    return false;
  }

  // Poll until items are ready (max ~10s)
  var tries = 0;
  var timer = setInterval(function(){
    tries++;
    if (refreshIfReady() || tries > 100){ clearInterval(timer); }
  }, 100);

  // Also listen for iframe load events
  document.addEventListener('load', function(e){
    if (e.target && e.target.tagName === 'IFRAME'){
      setTimeout(refreshIfReady, 50);
    }
  }, true);
})();
</script>
<style>
.badge.owned{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:6px;background:#4caf50;color:#fff;font-size:11px;}
</style>
<script>
(function(){
  function normName(s){
    if (typeof window.normOwnedName === 'function') return window.normOwnedName(s);
    return String(s||'').normalize('NFKC').replace(/\s+/gu,' ').trim().toLowerCase();
  }
  function parseOwnedRaw(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(s=>s.trim()).filter(Boolean);
  }
  function computeOwnedSet(){
    var ta = document.getElementById('ownedInput');
    if (!ta) return null;
    var names = Array.from(new Set(parseOwnedRaw(ta.value))).map(normName);
    window.ownedNameSet = window.ownedNameSet || new Set();
    // reset
    window.ownedNameSet.clear();
    names.forEach(n => window.ownedNameSet.add(n));
    // expose for other code that closed over old reference
    window.__ownedNamesArray = names;
    return window.ownedNameSet;
  }
  function refreshAll(){
    // refresh chips
    var on = document.querySelector('#partTabs .gtab.is-on');
    var g = on ? on.getAttribute('data-g') : 'wear';
    if (typeof window.setGroup === 'function') window.setGroup(g);
    // refresh table/list view if available
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }
  // Wire input live update
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      computeOwnedSet();
      refreshAll();
    }
  });
  // Buttons
  var applyBtn = document.getElementById('applyOwned');
  if (applyBtn){
    applyBtn.addEventListener('click', function(){
      computeOwnedSet();
      refreshAll();
    });
  }
  var clearBtn = document.getElementById('clearOwned');
  if (clearBtn){
    clearBtn.addEventListener('click', function(){
      var ta = document.getElementById('ownedInput');
      if (ta) ta.value = '';
      computeOwnedSet();
      refreshAll();
    });
  }
  // Init
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    computeOwnedSet();
    setTimeout(refreshAll, 60);
  });
})();
</script>
<script>
// --- Auto save & load owned list to localStorage (silent) ---
(function(){
  var LS_KEY = 'nikki_owned_names_v2';

  function safeGet(){
    try { return localStorage.getItem(LS_KEY) || ''; } catch(e){ return ''; }
  }
  function safeSet(v){
    try { localStorage.setItem(LS_KEY, String(v||'')); } catch(e){ /* ignore */ }
  }
  function refreshAll(){
    if (typeof window.setGroup === 'function'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.setGroup(g);
    }
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }

  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    var ta = document.getElementById('ownedInput');
    if (!ta) return;
    var saved = safeGet();
    if (saved && !ta.value){
      ta.value = saved;
      // trigger existing input handlers to recompute owned set
      ta.dispatchEvent(new Event('input', {bubbles:true}));
      setTimeout(refreshAll, 50);
    }
  });

  var saveTimer = null;
  document.addEventListener('input', function(ev){
    if (!ev.target || ev.target.id !== 'ownedInput') return;
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(function(){ safeSet(ev.target.value); }, 150);
  });
})();
</script>
<script>
// --- Internal persistent owned-set (independent from textarea) ---
(function(){
  var LS_SET = 'nikki_owned_set_v1';
  var LS_DRAFT = 'nikki_owned_draft_v1';

  function norm(s){
    try { return String(s||'').normalize('NFKC').replace(/\s+/gu,' ').trim().toLowerCase(); }
    catch(e){ return String(s||'').toLowerCase().trim(); }
  }
  function parseList(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function safeGet(k, d){ try{ return localStorage.getItem(k); }catch(e){ return d; } }
  function safeSet(k, v){ try{ localStorage.setItem(k, v); }catch(e){} }

  function refreshAll(){
    if (typeof window.setGroup === 'function'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.setGroup(g);
    }
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }

  function loadOwnedSet(){
    var saved = safeGet(LS_SET, '') || '';
    var arr = saved ? saved.split('\n').map(function(s){return s.trim();}).filter(Boolean) : [];
    var set = new Set(arr.map(norm));
    // expose as canonical set used by filters/renderers
    window.ownedNameSet = set;
    window.__ownedNamesArray = Array.from(set);
    return set;
  }

  function saveOwnedSetFromTextarea(){
    var ta = document.getElementById('ownedInput');
    if (!ta) return;
    var names = parseList(ta.value);
    var normed = Array.from(new Set(names.map(norm)));
    safeSet(LS_SET, normed.join('\n'));
    loadOwnedSet();
    refreshAll();
  }

  // Override any earlier computeOwnedSet so typing doesn't clear the set
  window.computeOwnedSet = function(commit){
    if (commit) saveOwnedSetFromTextarea();
    // else: ignore live typing
  };

  // Apply button commits textarea -> internal set
  document.addEventListener('click', function(ev){
    var t = ev.target && ev.target.closest && ev.target.closest('#applyOwned');
    if (t){ saveOwnedSetFromTextarea(); }
  }, true);

  // Save draft only (doesn't affect owned set)
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      safeSet(LS_DRAFT, ev.target.value);
      // DO NOT touch window.ownedNameSet here
    }
  });

  // Initialize on load: load set from LS, but do NOT auto-fill textarea
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    loadOwnedSet();
    setTimeout(refreshAll, 80);
  });
})();
</script>
<script>
(function(){
  function normNewlines(s){ return String(s||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n'); }
  function getOwnedText(){
    var ta = document.getElementById('ownedInput');
    var text = ta ? ta.value : '';
    if (text && text.trim()) return normNewlines(text.trim());
    var set = (window.ownedNameSet instanceof Set) ? Array.from(window.ownedNameSet) : [];
    return set.join('\n');
  }
  function downloadTxt(filename, text){
    var blob = new Blob([text], {type:'text/plain;charset=utf-8'});
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 0);
  }
  function refreshAll(){
    // chips/tabs
    if (typeof window.setGroup === 'function'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.setGroup(g);
    }
    // lists/tables if present
    if (typeof window.renderTable === 'function') window.renderTable();
    if (typeof window.render === 'function') window.render();
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  }
  function applyFromTextarea(){
    var ta = document.getElementById('ownedInput');
    if (!ta) return;
    // trigger any existing listeners that build owned set
    ta.dispatchEvent(new Event('input', {bubbles:true}));
    if (typeof window.computeOwnedSet === 'function') window.computeOwnedSet(true);
    refreshAll();
  }
  function handleFile(file){
    var reader = new FileReader();
    reader.onload = function(ev){
      var text = normNewlines(ev.target.result);
      var ta = document.getElementById('ownedInput');
      if (ta){ ta.value = text; }
      // 바로 적용
      applyFromTextarea();
    };
    reader.readAsText(file, 'utf-8');
  }

  document.addEventListener('click', function(ev){
    var id = ev.target && ev.target.id;
    if (id === 'exportOwned'){
      var text = getOwnedText();
      if (!text){ alert('보유 의상 목록이 비어 있습니다.'); return; }
      downloadTxt('owned_items.txt', text);
    } else if (id === 'importOwned'){
      var inp = document.getElementById('importOwnedFile');
      if (inp) inp.click();
    }
  });
  document.addEventListener('change', function(ev){
    if (ev.target && ev.target.id === 'importOwnedFile' && ev.target.files.length){
      handleFile(ev.target.files[0]);
      ev.target.value = '';
    }
  });
})();
</script>
<footer id="metaFooter" style="margin:24px 0 0; padding:12px; text-align:center; color:#666; font-size:12px; ">
  제작자 : 윤드 · 
</footer>
<script>
// --- Stage-defined extra attributes (no UI) ---
// Expect each stage object can define:
//   extras: ["활발","심플","청량"]         // up to any number
//   extras_pct: 5                         // percent as number (default 5)
(function(){
  window.__getStageExtraAttrs = function(stage){
    if (!stage) return [];
    if (Array.isArray(stage.extras)) return stage.extras;
    if (Array.isArray(stage.extraAttrs)) return stage.extraAttrs;
    return [];
  };
  window.__getStageExtraPct = function(stage){
    if (!stage) return 0.05;
    var p = (typeof stage.extras_pct === 'number') ? stage.extras_pct :
            (typeof stage.extras_pct === 'string' ? (+stage.extras_pct) : NaN);
    if (!isNaN(p) && p > 0) return p / 100;
    return 0.05; // default 5%
  };
})();
</script>
<script>
(function(){
  function moveRequiredFirst(){
    try{
      const tips = document.getElementById('tips');
      if(!tips) return;
      const req = tips.querySelector('.reqlist');
      if(req && tips.firstChild !== req){
        tips/* disabled tips reorder */ void 0;
      }
    }catch(e){}
  }
  function hideStyleRatio(){
    const tips = document.getElementById('tips');
    if(!tips) return;
    const kids = Array.from(tips.children);
    const m=/메인\s*[^,%]+?\d+%/; const s=/서브\s*[^,%]+?\d+%/; const t=/태그\s*[^,%]+?\d+%/;
    kids.forEach(el=>{
      const tx=(el.textContent||'').replace(/\s+/g,' ').trim();
      const c=[m.test(tx),s.test(tx),t.test(tx)].filter(Boolean).length;
      if((c>=2&&tx.length<=120)||(/^메인\s*[^,%]+?\d+%/.test(tx)&&tx.length<=80)){ el.style.display='none'; }
    });
  }
  function postRender(){
    hideStyleRatio();
    moveRequiredFirst();
  }
  function ensureStagesSynced(){
    var tries=0, max=64; var timer=setInterval(function(){ tries++;
      var sf = document.getElementById('stagesFrame');
      var ifw = sf && sf.contentWindow;
      var iframeStages = (ifw && ifw.stages) || null;
      var parentStages = window.stages || null;
      // If iframe has stages but parent doesn't, copy
      if(iframeStages && Array.isArray(iframeStages) && iframeStages.length){
        if(!parentStages || !Array.isArray(parentStages) || parentStages.length < iframeStages.length){
          try{ window.stages = JSON.parse(JSON.stringify(iframeStages)); }catch(e){ window.stages = iframeStages; }
          // Trigger renderAll if available
          try{ if(typeof window.__populateStages==='function'){ window.__populateStages(); }
          if(typeof window.renderAll==='function'){ window.renderAll(); } }catch(e){}
          // Also try to dispatch change on stageSelect
          var sel = document.getElementById('stageSelect');
          if(sel){
            var ev = new Event('change', {bubbles:true});
            sel.dispatchEvent(ev);
          }
          // After syncing, run postRender
          setTimeout(postRender, 0);
        }
      }
      if(tries>=max || (window.stages && Array.isArray(window.stages) && window.stages.length>0)){
        clearInterval(timer);
        setTimeout(postRender, 0);
      }
    },125);
  }
  window.addEventListener('load', function(){
    // Guard: both iframes should exist
    var s = document.querySelector('iframe[src$="stages_frame_v2.html"]');
    var i = document.querySelector('iframe[src$="items_frame_v2.html"]');
    if(!s || !i){ console.warn('[fix] expected stages/items iframes not found'); }
    ensureStagesSynced();
    // Observe tips only (non-intrusive)
    const tips = document.getElementById('tips');
    if(tips){
      const mo = /* MO-off */ (null && new MutationObserver)(postRender);
      mo.observe(tips, {childList:true, subtree:true});
document.addEventListener('DOMContentLoaded', function(){
    // Guard: both iframes should exist
    var s = document.querySelector('iframe[src$="stages_frame_v2.html"]');
    var i = document.querySelector('iframe[src$="items_frame_v2.html"]');
    if(!s || !i){ console.warn('[fix] expected stages/items iframes not found'); }
    ensureStagesSynced();
    // Observe tips only (non-intrusive)
    const tips = document.getElementById('tips');
    if(tips){
      const mo = /* MO-off */ (null && new MutationObserver)(postRender);
      mo.observe(tips, {childList:true, subtree:true});
    }
  });
})();
</script>
<script>
(function(){
  // Safe helpers
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getSelectedStage(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const s = (window.stages||[]).find(x=> x.stage_id === id) || (window.stages||[])[0];
    return s || null;
  }
  function getRequiredMap(stage){
    const m = {};
    if(stage && stage.required_parts){
      try{
        const rp = stage.required_parts;
        Object.keys(rp).forEach(part=>{
          const arr = Array.isArray(rp[part]) ? rp[part] : [rp[part]];
          m[part] = arr.filter(Boolean);
        });
      }catch(e){}
    }
    return m;
  }
  function updateRequiredPanel(stage, reqMap){
    const tips = document.getElementById('tips');
    if(!tips) return;
    const ownedSet = window.ownedNameSet || new Set();
    const list = Object.keys(reqMap).map(part=>{
      const names = (reqMap[part]||[]).map(name=>{
        const owned = ownedSet.has(ownNorm(name));
        const cls = owned ? 'own' : 'miss';
        const icon = owned ? '✔' : '✖';
        return `<span class="pill ${cls}" title="${owned?'보유':'미보유'}">${icon} ${name}</span>`;
      }).join(' ');
      return `<div class="row" style="gap:8px;align-items:center"><span class="part">${part}</span>${names}</div>`;
    }).join('');
    const requiredBlock = Object.keys(reqMap).length ? `<div class="reqlist"><div class="muted" style="margin-bottom:4px">추천 아이템</div>${list}</div>` : '';
    // Put required items FIRST
    // Preserve existing tips content by appending after requiredBlock
    const old = tips.innerHTML;
    tips.innerHTML = requiredBlock + old;
    // Ensure it's at the top even if render re-writes tips later
    const req = tips.querySelector('.reqlist');
    if(req && tips.firstChild !== req){
      tips/* disabled tips reorder */ void 0;
    }
  }
  function addBadgesToCards(stage, reqMap){
    const reqNames = new Set();
    Object.values(reqMap).forEach(arr=> (arr||[]).forEach(n=> reqNames.add(ownNorm(n))));
    const cards = document.querySelectorAll('#list .card');
    cards.forEach(card=>{
      const nameEl = card.querySelector('h3 span');
      const badges = card.querySelector('.badges');
      if(!nameEl || !badges) return;
      const nm = ownNorm(nameEl.textContent||'');
      if(reqNames.has(nm)){
        if(!badges.querySelector('.badge.req')){
          const el = document.createElement('span');
          el.className = 'badge req';
          el.textContent = '추천';
          badges.appendChild(el);
        }
      }else{
        // remove if previously added and no longer required for new stage
        const b = badges.querySelector('.badge.req');
        if(b) b.remove();
      }
    });
  }
  function runRequiredUI(){
    try{
      const stage = getSelectedStage();
      const reqMap = getRequiredMap(stage);
      // Clear previous checklist to avoid stacking
      const tips = document.getElementById('tips');
      if(tips){
        const oldReq = tips.querySelector('.reqlist');
        if(oldReq) oldReq.remove();
      }
      updateRequiredPanel(stage, reqMap);
      addBadgesToCards(stage, reqMap);
    }catch(e){ /* no-op */ }
  }

  // Run after every render without overriding render functions
  document.addEventListener('DOMContentLoaded', ()=>{
    // Initial try
    setTimeout(runRequiredUI, 0);
    setTimeout(runRequiredUI, 200);
    // Respond to stage change
    document.addEventListener('change', (e)=>{
      if(e.target && e.target.id==='stageSelect'){
        setTimeout(runRequiredUI, 0);
      }
    });
    // Observe list & tips for re-renders
    const list = document.getElementById('list');
    if(list){
      /* MO-off */ (null && new MutationObserver)(()=> runRequiredUI()).observe(list, {childList:true, subtree:true});
    }
    const tips = document.getElementById('tips');
    if(tips){
      /* MO-off */ (null && new MutationObserver)(()=>{
        // keep required block FIRST
        const req = tips.querySelector('.reqlist');
        if(req && tips.firstChild !== req) tips/* disabled tips reorder */ void 0;
      }).observe(tips, {childList:true, subtree:true});
    }
  });
})();
</script>
<script>
(function(){
  // Normalize a value into array of strings
  function toNames(v){
    if (v == null) return [];
    if (Array.isArray(v)) return v.map(String);
    if (typeof v === 'object'){
      // flatten object values (e.g., {name:"X"} or {opt1:"X", opt2:["Y"]})
      const out = [];
      Object.values(v).forEach(val=>{
        if (val == null) return;
        if (Array.isArray(val)) out.push(...val.map(String));
        else out.push(String(val));
      });
      return out;
    }
    return [String(v)];
  }

  const PART_ALLOW = new Set(["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","액세서리",,"모자","목걸이","귀걸이","팔찌","반지","가방","기타"]);

  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getSelectedStage(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const list = Array.isArray(window.stages) ? window.stages : [];
    return list.find(x=> x && String(x.stage_id)===String(id)) || list[0] || null;
  }
  function buildReqMap(stage){
    const m = {};
    const rp = stage && stage.required_parts ? stage.required_parts : null;
    if(!rp || typeof rp!=="object") return m;
    Object.keys(rp).forEach(key=>{
      if(!key) return;
      // strip obviously wrong keys
      if (key==="required_parts" || key==="_" || key==="required" || key==="추천아이템") return;
      // only keep allowed part names (fallback: keep anything that isn't obviously wrong)
      const part = PART_ALLOW.has(key) ? key : key;
      const arr = toNames(rp[key]).filter(Boolean);
      if(!arr.length) return;
      m[part] = (m[part]||[]);
      arr.forEach(n=>{
        if(n && !m[part].includes(n)) m[part].push(n);
      });
    });
    return m;
  }

  function renderReqPanel(stage, reqMap){
    const tips = document.getElementById('tips');
    if(!tips) return;
    // Remove any previous checklist
    tips.querySelectorAll('.reqlist').forEach(e=>e.remove());

    const ownedSet = window.ownedNameSet || new Set();
    const rows = Object.keys(reqMap).map(part=>{
      const names = reqMap[part].map(name=>{
        const owned = ownedSet.has(ownNorm(name));
        const cls = owned ? 'own' : 'miss';
        const icon = owned ? '✔' : '✖';
        return `<span class="pill ${cls}" title="${owned?'보유':'미보유'}">${icon} ${name}</span>`;
      }).join(' ');
      return `<div class="row" style="gap:8px;align-items:center"><span class="part">${part}</span>${names}</div>`;
    }).join('');

    const block = Object.keys(reqMap).length
      ? `<div class="reqlist"><div class="muted" style="margin-bottom:4px">추천 아이템</div>${rows}</div>`
      : '';

    if(block){
      // Insert at the very top
      const wrapper = document.createElement('div');
      wrapper.innerHTML = block;
      const node = wrapper.firstElementChild;
      tips.insertBefore(node, tips.firstChild || null);
    }
  }

  function addReqBadges(reqMap){
    const requiredNames = new Set();
    Object.values(reqMap).forEach(arr=> (arr||[]).forEach(n=> requiredNames.add(ownNorm(n))));
    document.querySelectorAll('#list .card').forEach(card=>{
      const nmEl = card.querySelector('h3 span');
      const badges = card.querySelector('.badges');
      if(!nmEl || !badges) return;
      const nm = ownNorm(nmEl.textContent||'');
      const has = requiredNames.has(nm);
      const b = badges.querySelector('.badge.req');
      if(has){
        if(!b){
          const el = document.createElement('span');
          el.className = 'badge req';
          el.textContent = '추천';
          badges.appendChild(el);
        }
      }else{
        if(b) b.remove();
      }
    });
  }

  function run(){
    const stage = getSelectedStage();
    const reqMap = buildReqMap(stage);
    renderReqPanel(stage, reqMap);
    addReqBadges(reqMap);
  }

  // Run safely without overriding render functions
  document.addEventListener('DOMContentLoaded', ()=>{
    setTimeout(run, 0);
    setTimeout(run, 200);
    document.addEventListener('change', (e)=>{
      if(e.target && e.target.id==='stageSelect'){
        setTimeout(run, 0);
      }
    });
    const list = document.getElementById('list');
    if(list){
      /* MO-off */ (null && new MutationObserver)(()=> run()).observe(list, {childList:true, subtree:true});
    }
    const tips = document.getElementById('tips');
    if(tips){
      /* MO-off */ (null && new MutationObserver)(()=>{
        // keep reqlist first
        const req = tips.querySelector('.reqlist');
        if(req && tips.firstChild !== req) tips/* disabled tips reorder */ void 0;
      }).observe(tips, {childList:true, subtree:true});
    }
  });
})();
</script>
<script>
(function(){
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getRequiredNameSet(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id));
    const rp = st && st.required_parts;
    const names = new Set();
    if(rp && typeof rp==='object'){
      Object.values(rp).forEach(v=>{
        if(v==null) return;
        if(Array.isArray(v)) v.forEach(n=> names.add(ownNorm(String(n))));
        else if(typeof v==='object') Object.values(v).forEach(n=> names.add(ownNorm(String(n))));
        else names.add(ownNorm(String(v)));
      });
    }
    return names;
  }

  function reorderRequiredFirst(){
    const list = document.getElementById('list');
    if(!list) return;
    const req = getRequiredNameSet();
    if(!req.size) return;
    const cards = Array.from(list.querySelectorAll(':scope > .card'));
    if(!cards.length) return;

    const isReq = (card)=>{
      const nmEl = card.querySelector('h3 span');
      const nm = ownNorm(nmEl ? nmEl.textContent : '');
      return req.has(nm);
    };

    // Stable partition: required cards first, keep relative order otherwise
    const reqCards = [];
    const others = [];
    cards.forEach(c=> (isReq(c) ? reqCards : others).push(c));

    // If first already required, skip to avoid churn
    if(reqCards.length && cards[0] === reqCards[0]) return;

    const frag = document.createDocumentFragment();
    reqCards.concat(others).forEach(c=> frag.appendChild(c));
    list.appendChild(frag);
  }

  // Run after DOM ready and whenever list/tabs/filters change
  document.addEventListener('DOMContentLoaded', ()=>{
    setTimeout(reorderRequiredFirst, 0);
    setTimeout(reorderRequiredFirst, 200);

    document.addEventListener('change', (e)=>{
      if(e.target && (e.target.id==='stageSelect' || e.target.id==='ownOnly' || e.target.id==='groupSelect' || e.target.id==='sortSelect')){
        setTimeout(reorderRequiredFirst, 0);
      }
    });

    const list = document.getElementById('list');
    if(list){
      /* MO-off */ (null && new MutationObserver)(()=> reorderRequiredFirst()).observe(list, {childList:true, subtree:false});
    }
  });
})();
</script>
<script>
// Single-file datasets removed (use iframe/postMessage only);
window.stages = [{stage_id:"테스트-1", flair:1, simple:1, elegant:1, lively:1, mature:1, cute:1, sexy:1, pure:1, cool:1, 20%, 서브 큐티 10%"}];
window.ITEMS = window.items;


// Render hooks
function __populateStages(){
  const sel = document.getElementById('stageSelect');
  if (!sel) return;
  const prev = sel.value;

  const list = Array.isArray(window.stages) ? window.stages.slice() : [];
  const seen = new Set();
  const dedup = list.filter(s => {
    if (!s || !s.stage_id) return false;
    const key = String(s.stage_id);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  function parseNum(id){
    const m = String(id).match(/\[(?:[^\]]+)\]\s*(\d+)-(\d+)/);
    return m ? [Number(m[1]), Number(m[2])] : [9999, 9999];
  }
  dedup.sort((a,b)=>{
    const A = parseNum(a.stage_id), B = parseNum(b.stage_id);
    if (A[0] !== B[0]) return A[0] - B[0];
    if (A[1] !== B[1]) return A[1] - B[1];
    return String(a.stage_id).localeCompare(String(b.stage_id), 'ko');
  });

  // populate
  sel.innerHTML = '';
  dedup.forEach(s => {
    const o = document.createElement('option');
    o.value = s.stage_id;
    o.textContent = s.stage_id;
    sel.appendChild(o);
  });
  if (prev && Array.from(sel.options).some(o => o.value === prev)) sel.value = prev;

  const cnt = document.getElementById('stageCount');
  if (cnt) cnt.textContent = (window.stages || []).length;
}


document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
  try { __populateStages(); } catch(e) { console.warn(e); }
  try { if (typeof render === 'function') render(); } catch(e) { console.warn(e); }
});
</script>
<!-- data iframes (hidden) -->
<iframe id="itemsFrame" src="./items_frame_v2.html" style="display:none;width:0;height:0;border:0;"></iframe>
<iframe id="stagesFrame" src="./stages_frame_v2.html" style="display:none;width:0;height:0;border:0;"></iframe>
<script>
(function(){
  // Safe override of render() that avoids DOM reorders and freezes
  const by = (k)=> (a,b)=> String(a[k]||'').localeCompare(String(b[k]||''));
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));

  function getRequiredNameSetSafe(){
    try{
      const sel = document.getElementById('stageSelect');
      const id = sel && sel.value;
      const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id));
      const rp = st && st.required_parts;
      const names = new Set();
      if(rp && typeof rp==='object'){
        Object.values(rp).forEach(v=>{
          if(Array.isArray(v)) v.forEach(n=> names.add(ownNorm(String(n))));
          else if(v && typeof v==='object') Object.values(v).forEach(n=> names.add(ownNorm(String(n))));
          else if(v!=null) names.add(ownNorm(String(v)));
        });
      }
      return names;
    }catch(e){ return new Set(); }
  }

  function scoreItemForStageSafe(item, stage){
    try{
      return (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(item, stage) : 0;
    }catch(e){ return 0; }
  }

  window.render = function(){
    try{
      const stageId=document.getElementById('stageSelect').value || (stages[0] && stages[0].stage_id);
      const sortBy=document.getElementById('sortBy').value;
      const ownedOnly=document.getElementById('ownedOnly').checked;
      const stage=(window.stages||[]).find(s=> String(s.stage_id)===String(stageId)) || (window.stages||[])[0];

      let list=(Array.isArray(window.items)?window.items:[]).map(it=> ({...it, part:it.part, score:scoreItemForStageSafe(it, stage)}));
      const part=document.getElementById('partFilter')?.value || '';
      if(part) list=list.filter(it=> it.part===part);
      if(ownedOnly && window.ownedNameSet && window.normOwnedName) list=list.filter(it=> window.ownedNameSet.has(window.normOwnedName(it.name)));

      // required-first sorting (data-level)
      const __reqSet = getRequiredNameSetSafe();
      list = list.map(it=> ({...it, __req: __reqSet.has(ownNorm(it.name||''))}));
      if(sortBy==='score') list.sort((a,b)=> (b.__req - a.__req) || (b.score-a.score));
      else list.sort((a,b)=> (b.__req - a.__req) || by('name')(a,b));

      const listEl=document.getElementById('list'); const empty=document.getElementById('emptyState');
      if(list.length===0){ listEl.style.display='none'; empty.style.display='block'; }
      else { listEl.style.display='grid'; empty.style.display='none'; }

      listEl.innerHTML = list.map(it=>{
        const stars=Math.max(0, Math.min(6, Number(it.stars||0)));
        const tgs = (window.getItemTags?window.parseTags((it && it.tags) ? it.tags : ''):(window.parseTags?window.parseTags(it.tags):[]));
        const img = it.img ? `<img class="thumb" src="${it.img}" alt="${it.name}">` : '';
        return `<div class="card">
          <div class="row thumbrow">${img}<h3 style="margin:0;flex:1;display:flex;justify-content:space-between;align-items:center">
            <span>${it.name||'-'}</span>
            <button class="copy-btn" onclick="copyText('${(it.name||'').replace(/'/g, "\'")}')">이름 복사</button>
          </h3></div>
          <div class="badges"><span class="badge">${(typeof displayShort==='function'?displayShort(it.part):it.part)||'-'}</span><span class="badge">${stars}★</span>${it._owned?'<span class="badge owned">보유</span>':''}</div>
          <div class="badges tags">${tgs.map(x=>`<span class='badge tag'>#${x}</span>`).join('')}</div>
          <div class="score">점수: ${Number(it.score).toFixed(2)}</div>
        </div>`;
      }).join('');
    }catch(e){ /* swallow */ }
  };

  // After override: stop invoking DOM-reorder helpers if present
  window.reorderRequiredFirst = function(){};
  window.moveRequiredFirst = function(){};

  // Kick initial render once items become available
  (function waitItems(){
    if(Array.isArray(window.items) && window.items.length){
      try{ window.renderAll ? window.renderAll() : window.render(); }catch(e){}
    }else{
      setTimeout(waitItems, 100);
    }
  })();
})();
</script>
<script>
(function(){
  const ownNorm = window.normOwnedName || (s=> String(s||'').toLowerCase().replace(/\s+/g,''));
  const by = (k)=> (a,b)=> String(a[k]||'').localeCompare(String(b[k]||''));

  function getStageAndReq(){
    const sel = document.getElementById('stageSelect');
    const id = sel && sel.value;
    const st = (window.stages||[]).find(x=> String(x.stage_id)===String(id)) || (window.stages||[])[0] || null;
    const rp = st && st.required_parts || {};
    const reqNames = new Set();
    const reqByPart = {};
    if(rp && typeof rp==='object'){
      Object.keys(rp).forEach(part=>{
        const arr = Array.isArray(rp[part]) ? rp[part] : [];
        if(arr.length){
          reqByPart[part] = arr.slice();
          arr.forEach(n=> reqNames.add(ownNorm(String(n))));
        }
      });
    }
    return {stage:st, reqSet:reqNames, reqByPart};
  }

  function renderReqPanel(reqByPart){
    const panel = document.getElementById('reqPanel');
    if(!panel) return;
    const parts = Object.keys(reqByPart);
    if(!parts.length){ panel.style.display='none'; panel.innerHTML=''; return; }
    const rows = parts.map(p=>{
      const names = reqByPart[p].map(n=> `<code>${n}</code>`).join(', ');
      return `<tr><th>${(typeof displayShort==='function'?displayShort(p):p)}</th><td>${names}</td></tr>`;
    }).join('');
    panel.innerHTML = `<h3>추천아이템</h3><table class="req-table"><tbody>${rows}</tbody></table>`;
    panel.style.display='block';
  }

  // Preserve original score function if exists
  const scoreSafe = (item, stage)=>{
    try{ return (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(item, stage) : 0; }
    catch(e){ return 0; }
  };

  // Override render ONLY (renderAll는 기존 로직을 쓰되 render를 호출하도록 둠)
  window.render = function(){
    try{
      const {stage, reqSet, reqByPart} = getStageAndReq();
      renderReqPanel(reqByPart);

      const part=document.getElementById('partFilter')?.value || '';
      const sortBy=document.getElementById('sortBy')?.value || 'score';
      const ownedOnly=document.getElementById('ownedOnly')?.checked || false;

      let src = Array.isArray(window.items)? window.items : [];
      let list = src.map(it=> ({...it, score:scoreSafe(it, stage)}));
      if(part) list = list.filter(it=> it.part===part);
      if(ownedOnly && window.ownedNameSet && window.normOwnedName){
        list = list.filter(it=> window.ownedNameSet.has(window.normOwnedName(it.name)));
      }

      list = list.map(it=> ({...it, __req: reqSet.has(ownNorm(it.name||''))}));
      if(sortBy==='score') list.sort((a,b)=> (b.__req - a.__req) || (b.score-a.score));
      else list.sort((a,b)=> (b.__req - a.__req) || by('name')(a,b));

      const listEl=document.getElementById('list'); const empty=document.getElementById('emptyState');
      if(!listEl) return;
      if(list.length===0){ listEl.style.display='none'; if(empty) empty.style.display='block'; }
      else { listEl.style.display='grid'; if(empty) empty.style.display='none'; }

      listEl.innerHTML = list.map(it=>{
        const stars = Math.max(0, Math.min(6, Number(it.stars||0)));
        const tgs = (window.getItemTags?window.parseTags((it && it.tags) ? it.tags : ''):(window.parseTags?window.parseTags(it.tags):[]));
        const img = it.img ? `<img class="thumb" src="${it.img}" alt="${it.name}">` : '';
        const reqBadge = it.__req ? `<span class="req-badge">추천</span>` : '';
        return `<div class="card">
          <div class="row thumbrow">${img}<h3 style="margin:0;flex:1;display:flex;justify-content:space-between;align-items:center">
            <span>${it.name||'-'} ${reqBadge}</span>
            <button class="copy-btn" onclick="copyText('${(it.name||'').replace(/'/g, "\\'")}')">이름 복사</button>
          </h3></div>
          <div class="badges"><span class="badge">${(typeof displayShort==='function'?displayShort(it.part):it.part)||'-'}</span><span class="badge">${stars}★</span>${it._owned?'<span class="badge owned">보유</span>':''}</div>
          <div class="badges tags">${tgs.map(x=>`<span class='badge tag'>#${x}</span>`).join('')}</div>
          <div class="score">점수: ${Number(it.score).toFixed(2)}</div>
        </div>`;
      }).join('');
    }catch(e){ /* swallow */ }
  };

  // Ensure first render when items become available
  (function waitItems(){
    if(Array.isArray(window.items) && window.items.length){
      try{ window.renderAll ? window.renderAll() : window.render(); }catch(e){}
    }else{
      setTimeout(waitItems, 100);
    }
  })();
})();
</script>
<script>
(function(){
  const norm = s => String(s||'').trim();
  const split = s => String(s||'').split(/[;,\|\/·\u3001\u3002\uFF0C\uFF0E\[\]\(\)\{\}\s]+/).map(x=>x.trim()).filter(Boolean);
  const uniq = arr => Array.from(new Set(arr.map(norm))).filter(Boolean);
  function deepCollectStrings(obj, bucket){
    if(!obj) return;
    const t = typeof obj;
    if(t==='string'){ bucket.push(obj); return; }
    if(t!=='object') return;
    if(Array.isArray(obj)){ for(const v of obj) deepCollectStrings(v, bucket); return; }
    for(const k in obj){
      if(/img|image|thumb|url/i.test(k)) continue;
      deepCollectStrings(obj[k], bucket);
    }
  }
  window.getItemTags = function(it){
    try{
      let raw = it.tags ?? it.tag ?? it["태그"] ?? "";
      let list = Array.isArray(raw) ? raw.map(norm) : split(raw);
      if(list.length===0){
        if(it.tag_list) list = Array.isArray(it.tag_list) ? it.tag_list : split(it.tag_list);
        if(it.Tags) list = list.concat(split(it.Tags));
      }
      if(list.length===0){
        const buf=[]; deepCollectStrings(it, buf);
        const words = buf.join(" ");
        list = uniq((words.match(/[#\u0023]?([가-힣A-Za-z0-9]+(?:스타일)?)/g) || []).map(s=>s.replace(/^#/,"")));
      }
      return uniq(list);
    }catch(e){ return []; }
  };
})();
</script>
<script>
// Shorten decoration labels for display only (keep full value for logic)
(function(){
  function shortLabel(txt){
    try{
      var s = String(txt||"");
      if (s.indexOf("장식") !== -1 && s.indexOf(" - ") !== -1){
        var segs = s.split(" - ");
        return segs[segs.length-1];
      }
      return s;
    }catch(e){ return txt; }
  }
  function relabelDecorations(root){
    try{
      var scope = root || document;
      var nodes = scope.querySelectorAll("span,button,a,div,label,option");
      nodes.forEach(function(n){
        var t = n.textContent;
        if(!t) return;
        if(t.indexOf("장식 - ")===-1) return;
        // keep the original text in data-full for debugging
        if(!n.dataset) n.dataset = {};
        if(!n.dataset.full) n.dataset.full = t;
        n.textContent = shortLabel(t);
      });
    }catch(e){ /* noop */ }
  }
  // Initial run
  document.addEventListener("DOMContentLoaded", function(){ setTimeout(relabelDecorations, 50); });
  window.addEventListener("load", function(){ setTimeout(relabelDecorations, 100); });

  // Patch renderAll to relabel after UI updates
  if (typeof window.renderAll === "function"){
    var __origRenderAll = window.renderAll;
    window.renderAll = function(){
      try{ __origRenderAll(); } finally { try{ relabelDecorations(); }catch(e){} }
    };
  }
  // Also observe dynamic changes
  try{
    var mo = new MutationObserver(function(muts){
      relabelDecorations();
    });
    mo.observe(document.documentElement, {childList:true, subtree:true});
  }catch(e){}
  console.log("[UI] Decoration labels shortened for display (e.g., '장식 - 손 - 장갑' → '장갑').");
})();
</script>
<script>
// Robust chip label shortener for '장식 - ...' → last segment (e.g., '헤어핀')
(function(){
  function shortenText(t){
    try{
      var s = String(t||'').replace(/\u00A0/g,' ').trim(); // nbsp→space
      if (/장식\s*-\s*/.test(s)){
        var segs = s.split(/\s*-\s*/);
        return segs[segs.length-1].trim();
      }
      return s;
    }catch(e){ return t; }
  }
  window.shortenChipLabels = function(root){
    try{
      var scope = root || document;
      var nodes = scope.querySelectorAll('#partChips .chip .k, #partBar .pill-small .k, #partBar .chip .k');
      nodes.forEach(function(n){
        var orig = n.textContent;
        var sh = shortenText(orig);
        if (sh && sh !== orig) n.textContent = sh;
      });
    }catch(e){}
  };
  // run now and on load
  document.addEventListener('DOMContentLoaded', function(){ setTimeout(window.shortenChipLabels, 50); });
  window.addEventListener('load', function(){ setTimeout(window.shortenChipLabels, 100); });

  // Observe mutations specifically under chip rows
  try{
    var target = document.getElementById('partChips');
    if (target){
      var mo = new MutationObserver(function(){ window.shortenChipLabels(target); });
      mo.observe(target, {childList:true, subtree:true});
    } else {
      // fallback observer on body to hook later
      var mo2 = new MutationObserver(function(){
        var t = document.getElementById('partChips');
        if (t){ window.shortenChipLabels(t); mo2.disconnect(); }
      });
      mo2.observe(document.documentElement, {childList:true, subtree:true});
    }
  }catch(e){}
})();
</script>
<script>
(function(){
  function lastSeg(s){
    try{
      var segs = String(s||'').split('-').map(function(x){return x.trim();}).filter(Boolean);
      return segs.length ? segs[segs.length-1] : String(s||'');
    }catch(e){ return s; }
  }
  window.shortenChipLabels = function(){
    var nodes = document.querySelectorAll('.pill-small .k, .chip .k, .tag-pill, #partChips *');
    nodes.forEach(function(el){
      var t = (el.textContent||'').trim();
      if (t.indexOf('-') !== -1){
        el.textContent = lastSeg(t);
      }
    });
  };
  document.addEventListener('DOMContentLoaded', function(){
    try{ window.shortenChipLabels(); }catch(e){}
  });
  (function(){
    if (typeof window.renderAll === 'function'){
      var orig = window.renderAll;
      window.renderAll = function(){
        var r = orig.apply(this, arguments);
        try{ window.shortenChipLabels(); }catch(e){}
        return r;
      };
    } else {
      setTimeout(function(){ try{ window.shortenChipLabels(); }catch(e){} }, 50);
    }
  })();
})();
</script>
<script>
// Shorten chip/option labels visually while preserving values and titles.
(function(){
  function relabelChips(){
    var chips = document.querySelectorAll('.chip .k, .pill-small .k');
    chips.forEach(function(el){
      var wrap = el.closest('.chip, .pill-small');
      var key = (wrap && wrap.getAttribute('data-part')) || el.textContent;
      try{
        var short = (typeof displayShort==='function') ? displayShort(key) : key;
        el.textContent = short;
      }catch(e){}
    });
  }
  function relabelSelect(){
    var sel = document.getElementById('partFilter');
    if(!sel) return;
    for(var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      try{
        // keep opt.value as-is (full key), shorten only visible text
        var short = (typeof displayShort==='function') ? displayShort(opt.textContent || '') : (opt.textContent || '');
        opt.textContent = short;
      }catch(e){}
    }
  }
  // Expose so other scripts can call if needed
  window.shortenChipLabels = function(){ relabelChips(); relabelSelect(); };

  // Run on DOM ready
  document.addEventListener('DOMContentLoaded', function(){
    try{ window.shortenChipLabels(); }catch(e){}
  });

  // Also wrap renderAll to run after any re-render
  (function wrapRender(){
    if(typeof window.renderAll === 'function'){
      var orig = window.renderAll;
      window.renderAll = function(){
        var r = orig.apply(this, arguments);
        try { queueMicrotask(function(){ window.shortenChipLabels(); }); } catch(e){ try{ setTimeout(window.shortenChipLabels, 0); }catch(_){} }
        return r;
      };
    }
  })();
})();
</script>
<script>
(function(){
  function isEditable(el){
    return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable;
  }
  function isOptionOrSelect(el){
    return el.tagName === 'OPTION' || el.tagName === 'SELECT';
  }
  function looksHierarchicalText(t){
    return typeof t === 'string' && t.indexOf(' - ') !== -1;
  }
  function shortenNodeText(el){
    if (!el) return;
    if (isEditable(el) || isOptionOrSelect(el)) return;
    // Only touch simple text containers (no nested interactive controls)
    if (el.childNodes && el.childNodes.length === 1 && el.childNodes[0].nodeType === Node.TEXT_NODE){
      var full = el.textContent.trim();
      if (looksHierarchicalText(full)){
        var short = (typeof displayShort==='function') ? displayShort(full) : full;
        if (short && short !== full){
          el.setAttribute('title', full); // preserve original as tooltip
          el.textContent = short;
        }
      }
    }
  }
  function relabelGeneric(root){
    var scope = root || document;
    // Prefer elements that likely represent filter/chip UI
    var candidates = scope.querySelectorAll([
      '.chip','.pill','.pill-small','.pill-outline','.badge','.tag','.tab','.filter','.filters',
      '.part-tabs','.category-tabs','.category','.part','.part-chip','.scroll-chips'
    ].join(','));
    // Also fall back to scanning any inline simple text elements that contain " - "
    var extras = scope.querySelectorAll('span,button,a,div');
    var set = new Set();
    candidates.forEach(function(e){ set.add(e); });
    extras.forEach(function(e){
      try{
        if (e.childNodes && e.childNodes.length === 1 && e.childNodes[0].nodeType === Node.TEXT_NODE){
          if (looksHierarchicalText(e.textContent)){
            set.add(e);
          }
        }
      }catch(_){}
    });
    set.forEach(shortenNodeText);
  }

  // Run on DOM ready
  document.addEventListener('DOMContentLoaded', function(){
    try{ relabelGeneric(document); }catch(e){}
  });

  // Also expose and hook into existing shorten function if present
  window.shortenChipLabels = (function(orig){
    return function(){
      try{ if (typeof orig === 'function') orig(); }catch(_){}
      try{ relabelGeneric(document); }catch(_){}
    };
  })(window.shortenChipLabels);

  // Observe future DOM changes to keep labels short
  var mo = new MutationObserver(function(muts){
    for (var i=0;i<muts.length;i++){
      var m = muts[i];
      if (m.type === 'childList'){
        m.addedNodes && m.addedNodes.forEach(function(n){
          try{ if (n.nodeType === 1) relabelGeneric(n); }catch(_){}
        });
      } else if (m.type === 'characterData') {
        var el = m.target && m.target.parentElement;
        try{ if (el) relabelGeneric(el); }catch(_){}
      }
    }
  });
  try{
    mo.observe(document.documentElement, { subtree:true, childList:true, characterData:true });
  }catch(_){}
})();
</script>
<script>
/* === Special tab (특수) support & removal from '장식' group === */
(function(){
  var SPECIAL_PARTS = [
    "장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개",
    "장식 - 특수 - 꼬리","장식 - 특수 - 전경","장식 - 특수 - 배경",
    "장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"
  ];

  // Filter these out of ORDER_ACC if it exists
  try{
    if (typeof window.ORDER_ACC !== 'undefined' && Array.isArray(window.ORDER_ACC)){
      window.ORDER_ACC = window.ORDER_ACC.filter(function(p){ return p.indexOf("장식 - 특수 -") !== 0 ? true : false; });
    }
  }catch(e){}

  function ensureSpecialTab(){
    var wrap = document.getElementById('partTabs');
    if (!wrap) return;
    var has = wrap.querySelector('[data-g="special"]');
    if (!has){
      var btn = document.createElement('button');
      btn.className = 'gtab';
      btn.setAttribute('data-g', 'special');
      btn.textContent = '특수';
      // Place after '장식' if found, else append at end
      var acc = wrap.querySelector('[data-g="acc"]');
      if (acc && acc.nextSibling){
        acc.parentNode.insertBefore(btn, acc.nextSibling);
      }else{
        wrap.appendChild(btn);
      }
    }
  }

  // Utilities
  function normName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'').trim(); }
  function getOwnedNameSet(){
    var ta = document.getElementById('ownedInput');
    var text = ta ? ta.value : '';
    var parts = String(text).split(/[\n\r;,]+|\s{2,}/g).map(function(s){ return s.trim(); }).filter(Boolean);
    var set = new Set();
    for (var i=0;i<parts.length;i++){ set.add(normName(parts[i])); }
    return set;
  }

  function computeStatsFor(partsList){
    var list = Array.isArray(partsList) ? partsList : [];
    var items = Array.isArray(window.items) ? window.items : [];
    var ownedSet = getOwnedNameSet();
    var stats = {};
    for (var i=0;i<list.length;i++){ stats[list[i]] = {owned:0,total:0}; }
    // Build map name->item for owned matching
    var byName = Object.create(null);
    for (var it of items){
      var k = normName(it && it.name);
      if (k && !(k in byName)) byName[k] = it;
    }
    for (var it of items){
      var p = it && it.part || '';
      if (!stats[p]) continue;
      stats[p].total++;
      if (ownedSet.has(normName(it.name))) stats[p].owned++;
    }
    return stats;
  }

  function chipHtml(label, o, t, value){
    var lbl = String(label||'');
    try{
      if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
        var segs = lbl.split(' - ');
        lbl = segs[segs.length-1];
      }
    }catch(e){}
    var pv = value || label || '';
    return '<span class="chip" data-part="'+ String(pv).replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ (o||0) +'/'+ (t||0) +'</span>'
         + '</span>';
  }

  function renderSpecialChips(){
    var row = document.getElementById('partChips');
    if (!row) return;
    var stats = computeStatsFor(SPECIAL_PARTS);
    var html = SPECIAL_PARTS.map(function(p){
      var s = stats[p] || {owned:0,total:0};
      return chipHtml(p, s.owned, s.total, p);
    }).join('');
    row.innerHTML = html;
    try{ if (typeof window.shortenChipLabels==='function') window.shortenChipLabels(); }catch(e){}
  }

  )();
</script>
<script>
/* === FORCE Special tab render & correct 특수 option values === */
(function(){
  var SPECIAL_PARTS = [
    "장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개",
    "장식 - 특수 - 꼬리","장식 - 특수 - 전경","장식 - 특수 - 배경",
    "장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"
  ];
  var SPECIAL_LABELS = ["얼굴","가슴","문신","날개","꼬리","전경","배경","상단","하단","스킨"];

  function fixSpecialOptions(){
    var sel = document.getElementById('partFilter');
    if (!sel) return;
    // Find optgroup with label "특수"
    var groups = sel.querySelectorAll('optgroup');
    var found = null;
    groups.forEach(function(g){
      if ((g.getAttribute('label')||'').trim() === '특수') found = g;
    });
    if (!found) return;
    // rewrite options to exact values
    found.innerHTML = SPECIAL_PARTS.map(function(v, i){
      var lab = SPECIAL_LABELS[i] || v;
      return '<option value="'+ v +'">'+ lab +'</option>';
    }).join('');
  }

  function normName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'').trim(); }
  function getOwnedNameSet(){
    var ta = document.getElementById('ownedInput');
    var text = ta ? ta.value : '';
    var parts = String(text).split(/[\n\r;,]+|\s{2,}/g).map(function(s){ return s.trim(); }).filter(Boolean);
    var set = new Set(); for (var i=0;i<parts.length;i++){ set.add(normName(parts[i])); }
    return set;
  }
  function computeStats(){
    var items = Array.isArray(window.items) ? window.items : [];
    var owned = getOwnedNameSet();
    var stats = {};
    SPECIAL_PARTS.forEach(function(p){ stats[p] = {owned:0,total:0}; });
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = it && it.part || '';
      if (!(p in stats)) continue;
      stats[p].total++;
      if (owned.has(normName(it.name))) stats[p].owned++;
    }
    return stats;
  }
  function chipHtml(label, o, t, value){
    var lbl = String(label||'');
    return '<span class="chip" data-part="'+ String(value||label).replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ (o||0) +'/'+ (t||0) +'</span>'
         + '</span>';
  }
  function renderSpecialChips(){
    var row = document.getElementById('partChips'); if (!row) return;
    var stats = computeStats();
    var html = SPECIAL_PARTS.map(function(p, i){
      var s = stats[p] || {owned:0,total:0};
      return chipHtml(SPECIAL_LABELS[i]||p, s.owned, s.total, p);
    }).join('');
    row.innerHTML = html;
    try{ if (typeof window.shortenChipLabels==='function') window.shortenChipLabels(); }catch(e){}
  }
  function activateTab(btn){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b===btn); });
  }
  function bindSpecialTab(){
    var wrap = document.getElementById('partTabs');
    if (!wrap) return;
    var btn = wrap.querySelector('[data-g="special"]');
    if (!btn){
      // create button if missing
      btn = document.createElement('button');
      btn.className = 'gtab';
      btn.setAttribute('data-g','special');
      btn.textContent = '특수';
      var acc = wrap.querySelector('[data-g="acc"]');
      if (acc && acc.nextSibling) acc.parentNode.insertBefore(btn, acc.nextSibling);
      else wrap.appendChild(btn);
    }
    btn.addEventListener('click', function(e){
      e.preventDefault();
      activateTab(btn);
      fixSpecialOptions();
      renderSpecialChips();
    }, {passive:false});
  }
  // Clicking a chip -> sync to partFilter
  document.addEventListener('click', function(ev){
    var chip = ev.target && ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return;
    var sel = document.getElementById('partFilter');
    if (sel){
      var foundIdx = -1;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ foundIdx = i; break; }
      }
      if (foundIdx >= 0) sel.selectedIndex = foundIdx; else sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);

  document.addEventListener('DOMContentLoaded', function(){
    // Ensure values and button bind
    fixSpecialOptions();
    bindSpecialTab();
  });
  // If user edits owned list while special is active, refresh chips
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      if (on && on.getAttribute('data-g')==='special') renderSpecialChips();
    }
  });
})();
</script>
<!-- === SPECIAL TAB PATCH (adds proper chips for 특수 group) === -->
<script>
(function(){
  // Order of Special parts
  window.ORDER_SPECIAL = ["얼굴","가슴","문신","날개","꼬리","전경","배경","상단","하단","스킨"];

  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(function(s){ return s.trim(); })
      .filter(Boolean);
  }
  function norm(s){
    return String(s||'')
      .normalize('NFKC')
      .toLowerCase()
      .replace(/[\s\u00A0]+/g,'');
  }
  function getStats(){
    var items = Array.isArray(window.items) ? window.items : [];
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i];
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = norm(it && it.name);
      if (key && !(key in byName)) byName[key] = it;
    }
    var ownedPer = Object.create(null);
    var input = document.getElementById('ownedInput');
    var names = input ? Array.from(new Set(parseOwned(input.value))) : [];
    for (var j=0;j<names.length;j++){
      var it2 = byName[norm(names[j])];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return {totals: totals, ownedPer: ownedPer};
  }
  function chipHtml(label, owned, total){
    var lbl = String(label||'');
    return '<span class="chip" data-part="'+ lbl.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ (owned||0) +'/'+ (total||0) +'</span>'
         + '</span>';
  }
  function renderSpecialChips(){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = getStats();
    var order = window.ORDER_SPECIAL || [];
    row.innerHTML = order.map(function(p){
      var o = S.ownedPer[p] || 0;
      var t = S.totals[p] || 0;
      return chipHtml(p, o, t);
    }).join('');
    try{ if (window.shortenChipLabels) window.shortenChipLabels(); }catch(e){}
  }
  function activateSpecial(){ renderSpecialChips(); }

  // Click handler for the "특수" tab
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab[data-g="special"]');
    if (t){ activateSpecial(); }
  }, false);

  // If page loads with "특수" active, render once
  document.addEventListener('DOMContentLoaded', function(){
    var on = document.querySelector('#partTabs .gtab.is-on');
    if (on && on.getAttribute('data-g')==='special'){ renderSpecialChips(); }
  });

  // Re-render chips when owned list changes while "특수" is active
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      if (on && on.getAttribute('data-g')==='special'){ renderSpecialChips(); }
    }
  });

  // Clicking a chip should set the part filter accordingly (match by option value or visible text)
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    var sel = document.getElementById('partFilter'); if (!sel) return;
    var found = false;
    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      if (opt.value === part){ sel.selectedIndex = i; found = true; break; }
      if (opt.text && opt.text.trim() === part){ sel.selectedIndex = i; found = true; break; }
    }
    if (!found){ sel.value = ''; }
    sel.dispatchEvent(new Event('change', {bubbles:true}));
  }, false);
})();
</script>
<!-- === ACCESSORY TAB CLEANUP PATCH (hide '장식 - 특수 - ...' from Acc group) === -->
<script>
(function(){
  function pruneAccSpecial(){
    try{
      var active = document.querySelector('#partTabs .gtab.is-on');
      if(!active || active.getAttribute('data-g')!=='acc') return;
      var row = document.getElementById('partChips');
      if(!row) return;
      var chips = Array.from(row.querySelectorAll('.chip'));
      chips.forEach(function(chip){
        var part = chip.getAttribute('data-part') || '';
        var label = chip.textContent || '';
        if (part.indexOf('장식 - 특수 - ') === 0) {
          chip.remove();
        } else if (label.trim() === '특수 아이템' || part === '특수 아이템') {
          chip.remove();
        }
      });
    }catch(e){ /* noop */ }
  }

  // If a global setGroup exists, wrap it so pruning runs right after switching to 'acc'
  (function wrapSetGroup(){
    try{
      var orig = window.setGroup;
      if(typeof orig === 'function'){
        window.setGroup = function(g){
          var r = orig.apply(this, arguments);
          if (g === 'acc') {
            // run after chips render
            setTimeout(pruneAccSpecial, 0);
          }
          return r;
        };
      } else {
        // Fallback: listen for acc tab clicks
        document.addEventListener('click', function(ev){
          var t = ev.target.closest && ev.target.closest('#partTabs .gtab[data-g="acc"]');
          if (t){
            setTimeout(pruneAccSpecial, 0);
          }
        }, false);
      }
    }catch(e){}
  })();

  // Re-prune when owned list changes while acc is active
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      if (on && on.getAttribute('data-g')==='acc'){
        setTimeout(pruneAccSpecial, 0);
      }
    }
  });

  // Also run shortly after load in case acc is active by default
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(pruneAccSpecial, 50);
  });
})();
</script>
<!-- === STRONG ACC PATCH: remove '장식 - 특수 - ...' from Accessory tab at the source and renderer === -->
<script>
(function(){
  function now(){ return (window.performance && performance.now) ? performance.now() : Date.now(); }

  // 1) Remove '장식 - 특수 - ...' from ORDER_ACC if present
  function stripOrderAcc(){
    try{
      if (!window.ORDER_ACC && typeof window.getStats !== 'function'){
        // Not loaded yet; try again soon
        return false;
      }
      if (Array.isArray(window.ORDER_ACC)){
        window.ORDER_ACC = window.ORDER_ACC.filter(function(p){
          return String(p||'').indexOf('장식 - 특수 - ') !== 0;
        });
      }
      // If GROUPS exists, ensure it points to updated ORDER_ACC
      if (window.GROUPS && window.GROUPS.acc){
        window.GROUPS.acc = window.ORDER_ACC || window.GROUPS.acc;
      }
      // If there are helper arrays, blank out special groupings
      if (Array.isArray(window.ACC_SPEC)) window.ACC_SPEC = [];
      if (Array.isArray(window.ACC_BACK)) window.ACC_BACK = window.ACC_BACK || []; // keep others
      if (Array.isArray(window.ACC_PALJJI)) window.ACC_PALJJI = window.ACC_PALJJI || [];
      if (Array.isArray(window.ACC_SINGLES)){
        // also purge any special from singles just in case
        window.ACC_SINGLES = window.ACC_SINGLES.filter(function(p){
          return String(p||'').indexOf('장식 - 특수 - ') !== 0 && String(p||'') !== '특수 아이템';
        });
      }
      return true;
    }catch(e){ return false; }
  }

  // 2) Override accessory chip renderer to never add "특수 아이템" aggregate
  function overrideAccRenderer(){
    try{
      // Some builds attach a named function; if so, replace it
      if (typeof window.renderChips_acc === 'function'){
        var origGetStats = (typeof window.getStats === 'function') ? window.getStats : function(){ return {totals:{}, ownedPer:{}}; };
        window.renderChips_acc = function(S){
          var row = document.getElementById('partChips'); if (!row) return '';
          S = S || origGetStats();
          var order = Array.isArray(window.ORDER_ACC) ? window.ORDER_ACC : [];
          function chipHtml(label, owned, total, partValue){
            var pv = partValue || '';
            var lbl = String(label||'');
            try{
              if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
                var segs = lbl.split(' - ');
                lbl = segs[segs.length-1];
              }
            }catch(e){}
            return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
                 +   '<span class="k">'+ lbl +'</span>'
                 +   '<span class="v">'+ (owned||0) +'/'+ (total||0) +'</span>'
                 + '</span>';
          }
          // Only render singles that are not special
          var html = order.filter(function(p){
            return String(p||'').indexOf('장식 - 특수 - ') !== 0;
          }).map(function(p){
            var o = (S.ownedPer && S.ownedPer[p]) || 0;
            var t = (S.totals && S.totals[p]) || 0;
            return chipHtml(p, o, t, p);
          }).join('');
          row.innerHTML = html;
          try{ if (window.shortenChipLabels) window.shortenChipLabels(); }catch(e){}
          return html;
        };
      }
      // Wrap setGroup so that when 'acc' is selected, our overridden render runs
      if (typeof window.setGroup === 'function'){
        var __origSetGroup = window.setGroup;
        window.setGroup = function(g){
          var r = __origSetGroup.apply(this, arguments);
          if (g === 'acc' && typeof window.renderChips_acc === 'function'){
            try{
              var S = (typeof window.getStats === 'function') ? window.getStats() : null;
              window.renderChips_acc(S);
            }catch(e){}
          }
          return r;
        };
      }
    }catch(e){}
  }

  // 3) As a failsafe, prune any rendered chips that slipped through
  function pruneRenderedAcc(){
    try{
      var active = document.querySelector('#partTabs .gtab.is-on');
      if(!active || active.getAttribute('data-g')!=='acc') return;
      var row = document.getElementById('partChips');
      if(!row) return;
      Array.from(row.querySelectorAll('.chip')).forEach(function(chip){
        var part = chip.getAttribute('data-part') || '';
        var labelEl = chip.querySelector('.k');
        var label = labelEl ? labelEl.textContent.trim() : chip.textContent.trim();
        if (part.indexOf('장식 - 특수 - ') === 0 || label === '특수 아이템'){
          chip.remove();
        }
      });
    }catch(e){}
  }

  // 4) Tie everything together
  (function initStrongAccPatch(){
    var deadline = now() + 3000; // try for up to ~3s
    (function tick(){
      var ok = stripOrderAcc();
      if (!ok && now() < deadline){
        return setTimeout(tick, 60);
      }
      overrideAccRenderer();
      // First prune pass
      setTimeout(pruneRenderedAcc, 0);
    })();

    // Re-prune on common triggers
    document.addEventListener('click', function(ev){
      if (ev.target.closest && ev.target.closest('#partTabs .gtab[data-g="acc"]')){
        setTimeout(pruneRenderedAcc, 0);
      }
    }, false);
    document.addEventListener('input', function(ev){
      if (ev.target && ev.target.id === 'ownedInput'){
        var on = document.querySelector('#partTabs .gtab.is-on');
        if (on && on.getAttribute('data-g')==='acc'){
          setTimeout(pruneRenderedAcc, 0);
        }
      }
    });
    document.addEventListener('DOMContentLoaded', function(){
      setTimeout(function(){
        var on = document.querySelector('#partTabs .gtab.is-on');
        if (on && on.getAttribute('data-g')==='acc') pruneRenderedAcc();
      }, 50);
    });
  })();
})();
</script>
<!-- === ACC TAB CLEANUP EXTENDED PATCH (also removes '반딧불의 영혼') === -->
<script>
(function(){
  function stripAccSpecialAndSoul(){
    try{
      if (Array.isArray(window.ORDER_ACC)){
        window.ORDER_ACC = window.ORDER_ACC.filter(function(p){
          var s = String(p||'');
          return !(s.indexOf('장식 - 특수 - ')===0 || s==='반딧불의 영혼');
        });
      }
      if (window.GROUPS && Array.isArray(window.GROUPS.acc)){
        window.GROUPS.acc = window.GROUPS.acc.filter(function(p){
          var s = String(p||'');
          return !(s.indexOf('장식 - 특수 - ')===0 || s==='반딧불의 영혼');
        });
      }
    }catch(e){}
  }
  function pruneAccChips(){
    try{
      var active = document.querySelector('#partTabs .gtab.is-on');
      if(!active || active.getAttribute('data-g')!=='acc') return;
      var row = document.getElementById('partChips');
      if(!row) return;
      Array.from(row.querySelectorAll('.chip')).forEach(function(chip){
        var part = chip.getAttribute('data-part') || '';
        var labelEl = chip.querySelector('.k');
        var label = labelEl ? labelEl.textContent.trim() : chip.textContent.trim();
        if (part.indexOf('장식 - 특수 - ')===0 || label==='특수 아이템' || label==='반딧불의 영혼' || part==='반딧불의 영혼'){
          chip.remove();
        }
      });
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    stripAccSpecialAndSoul();
    setTimeout(pruneAccChips, 80);
  });
  document.addEventListener('click', function(ev){
    if (ev.target.closest && ev.target.closest('#partTabs .gtab[data-g="acc"]')){
      setTimeout(function(){ stripAccSpecialAndSoul(); pruneAccChips(); }, 50);
    }
  }, false);
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id==='ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      if (on && on.getAttribute('data-g')==='acc'){
        setTimeout(pruneAccChips, 50);
      }
    }
  });
})();
</script>
<!-- === CHIP→FILTER SYNC + SUBPART FILTER LOGIC PATCH === -->
<script>
(function(){
  // Utility to shorten hierarchical labels like "장식 - 머리 - 헤어핀" -> "헤어핀"
  function displayShortLocal(txt){
    try{
      var s = String(txt==null ? '' : txt).replace(/\u00A0/g,' ').trim();
      s = s.replace(/\s*-\s*/g, ' - ');
      if (s.indexOf(' - ') !== -1){
        var segs = s.split(' - ').map(function(t){ return t.trim(); }).filter(Boolean);
        s = segs[segs.length - 1];
      }
      return s;
    }catch(e){ return txt; }
  }

  // 1) When a chip is clicked, try to select matching option by visible TEXT first.
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var chipPart = chip.getAttribute('data-part') || '';
    var chipLabel = displayShortLocal(chipPart);
    var sel = document.getElementById('partFilter');
    if (!sel) return;

    var matchedIndex = -1;
    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      var optText = (opt.text || '').trim();
      if (!opt.value) continue; // skip '전체'
      // Prefer exact label match against option TEXT
      if (optText === chipLabel){ matchedIndex = i; break; }
      // Fallback: exact match against value
      if (opt.value === chipPart){ matchedIndex = i; break; }
    }
    if (matchedIndex >= 0){
      sel.selectedIndex = matchedIndex;
    } else {
      // If no match, reset to 전체
      sel.value = '';
    }
    // Remember the chip's intended *subpart* so filter function can use it
    window.__chipSubpartLabel = chipLabel;
    sel.dispatchEvent(new Event('change', {bubbles:true}));
  }, false);

  // 2) Wrap/override getFilteredList to respect subpart label (e.g., 헤어핀/얼굴/날개)
  (function patchGetFilteredList(){
    var orig = window.getFilteredList;
    window.getFilteredList = function(stage){
      try{
        var partEl = document.getElementById('partFilter');
        var selValue = partEl ? partEl.value : '';
        var selIndex = partEl ? partEl.selectedIndex : -1;
        var selText = '';
        if (partEl && selIndex >= 0) selText = (partEl.options[selIndex].text || '').trim();

        var subLabel = window.__chipSubpartLabel || ''; // set by chip click
        // If user manually changes the dropdown, update subLabel accordingly
        if (partEl && (document.activeElement === partEl || !subLabel)){
          // If the selected option text is a specific subpart (e.g., 헤어핀, 베일, 얼굴), use it
          if (selText && selText !== '전체' && selText !== selValue){
            subLabel = selText;
            window.__chipSubpartLabel = subLabel;
          }
        }

        var selectedTags=(window.getSelectedTags?window.getSelectedTags():[]);
        var mode=(document.querySelector('input[name="tagMode"]:checked')||{}).value||'AND';
        var src = Array.isArray(window.items)? window.items : [];

        // Base list with scores
        var list = src.map(function(it){
          return Object.assign({}, it, {
            part: it.part,
            _disp: displayShortLocal(it.part),
            score: (window.scoreItemForStage?window.scoreItemForStage(it,stage):0)
          });
        });

        // Primary filtering logic:
        if (selValue){
          // If we have a subLabel (e.g., 헤어핀/얼굴) then filter by it, not the broad value
          if (subLabel && subLabel !== selValue){
            list = list.filter(function(it){
              // Match either exact short label or hierarchical suffix
              return it._disp === subLabel || String(it.part||'').indexOf(' - ' + subLabel) !== -1 || String(it.part||'') === subLabel;
            });
          } else {
            // Broad filter (legacy behavior)
            list = list.filter(function(it){ return it.part === selValue; });
          }
        } else if (subLabel){
          // No explicit dropdown value (전체) but we clicked a chip => filter by subLabel
          list = list.filter(function(it){
            return it._disp === subLabel || String(it.part||'').indexOf(' - ' + subLabel) !== -1 || String(it.part||'') === subLabel;
          });
        }

        // Tag filter
        if(window.tagsInclude && window.parseTags){
          list=list.filter(function(it){
            return window.tagsInclude(window.parseTags(it.tags), selectedTags, mode);
          });
        }
        // Owned marker
        return list.map(function(it){
          var owned = (window.ownedNameSet && window.normOwnedName) ? window.ownedNameSet.has(window.normOwnedName(it.name)) : false;
          return Object.assign({}, it, {_owned: owned});
        });
      }catch(e){
        try{ return typeof orig==='function' ? orig(stage) : []; }catch(_){ return []; }
      }
    };
  })();

  // 3) If the user changes the dropdown manually, clear chip sub-filter when set to 전체
  document.addEventListener('change', function(ev){
    var el = ev.target;
    if (el && el.id === 'partFilter'){
      if (!el.value){ window.__chipSubpartLabel = ''; }
    }
  }, false);
})();
</script>
<!-- === STAGE SELECT POPULATION + FRAME FALLBACKS === -->
<script>
(function(){
  function $(id){ return document.getElementById(id); }

  // Build <select id="stageSelect"> from window.stages
  window.__populateStages = function(){
    try{
      var sel = $('stageSelect');
      if(!sel) return;
      var list = Array.isArray(window.stages) ? window.stages : [];
      var cur = sel.value;
      sel.innerHTML = ""; // reset
      // placeholder
      var opt0 = document.createElement('option');
      opt0.value = "";
      opt0.textContent = list.length ? "스테이지 선택" : "(스테이지 없음)";
      sel.appendChild(opt0);
      // options
      list.forEach(function(st){
        var id = String(st && st.stage_id || "").trim();
        if(!id) return;
        var opt = document.createElement('option');
        opt.value = id;
        opt.textContent = id;
        sel.appendChild(opt);
      });
      // restore previous
      if (cur) sel.value = cur;
      // update counter
      var cnt = $('stageCount'); if (cnt) cnt.textContent = String(list.length||0);
      // auto-select first valid stage if none selected
      if (!sel.value && list.length){
        sel.selectedIndex = 1; // first after placeholder
        sel.dispatchEvent(new Event('change', {bubbles:true}));
      }
    }catch(e){ /* noop */ }
  };

  // When stage changes, re-render
  document.addEventListener('change', function(ev){
    var el = ev.target;
    if (el && el.id === 'stageSelect'){
      try{ if(typeof window.renderAll === 'function') window.renderAll(); }catch(e){}
    }
  }, false);

  // Frame fallbacks: if items iframe doesn't postMessage, read window.ITEMS directly
  function bindFrameFallbacks(){
    try{
      var itf = $('itemsFrame');
      if (itf){
        itf.addEventListener('load', function(){
          try{
            var arr = (itf.contentWindow && itf.contentWindow.ITEMS) || [];
            if (Array.isArray(arr) && arr.length >= 0){
              window.items = arr;
              try{ $('itemCount').textContent = String(arr.length||0); }catch(_){}
              try{ if(typeof window.renderAll === 'function') window.renderAll(); }catch(_){}
            }
          }catch(e){}
        });
      }
      var stf = $('stagesFrame');
      if (stf){
        stf.addEventListener('load', function(){
          // stages_frame_v2.html posts via postMessage, but as a backup try to read globals
          try{
            var cw = stf.contentWindow;
            // Some builds expose a global like STAGES or data; try common names
            var guess = cw && (cw.STAGES || cw.data);
            if (Array.isArray(guess) && guess.length){
              window.stages = guess;
              window.__populateStages();
              try{ if(typeof window.renderAll === 'function') window.renderAll(); }catch(_){}
            }
          }catch(e){}
        });
      }
    }catch(e){}
  }

  document.addEventListener('DOMContentLoaded', function(){
    bindFrameFallbacks();
    // If stages already present inline, just populate
    setTimeout(function(){
      if (Array.isArray(window.stages) && window.stages.length){
        window.__populateStages();
      }
    }, 50);
  });

  // Also hook into any existing init pipeline
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    window.__populateStages();
  };

  // When postMessage delivers stages (existing listener), __populateStages will run there if present.
  // (We didn't override that listener; we only provide the function it tries to call.)
})();
</script>
<!-- === TABS + TABLE RENDER PATCH === -->
<script>
(function(){
  // Utility
  function $(id){ return document.getElementById(id); }
  function el(tag, attrs){ var e=document.createElement(tag); if(attrs){ for(var k in attrs){ if(k==='text') e.textContent=attrs[k]; else e.setAttribute(k, attrs[k]); } } return e; }
  function esc(s){ return String(s==null?'':s).replace(/[&<>"]/g, s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s])); }
  function shortPart(p){ try{ if(typeof displayShort==='function') return displayShort(p); var s=String(p||''); var i=s.lastIndexOf(' - '); return i>=0?s.slice(i+3):s; }catch(e){ return p; } }
  function toNum(v){ var n=Number(v); return Number.isFinite(n)?n:0; }
  function star(n){ return '★'.repeat(toNum(n)); }
  function imgSrc(it){ try{ return (typeof toThumb==='function') ? toThumb(it.img) : (it.img||''); }catch(e){ return it.img||''; } }

  // Column builder for itemsTable
  function renderItemsTable(){
    var tbody = document.querySelector('#itemsTable tbody');
    if(!tbody) return;
    var stSel = $('stageSelect');
    var stage = null;
    if(stSel && Array.isArray(window.stages)){
      stage = window.stages.find(function(s){ return String(s.stage_id)===String(stSel.value); }) || null;
    }
    var list = (typeof window.getFilteredList==='function') ? window.getFilteredList(stage) : (window.items||[]);
    // sort
    var sortSel = $('sortBy'); var sortKey = sortSel ? sortSel.value : 'score';
    list = list.slice();
    if(sortKey === 'name'){
      list.sort(function(a,b){ return String(a.name||'').localeCompare(String(b.name||''),'ko'); });
    }else{ // score
      list.sort(function(a,b){ return toNum(b.score)-toNum(a.score); });
    }
    // Build rows
    var rows = list.map(function(it){
      var attrs = ['flair','simple','elegant','lively','mature','cute','sexy','pure','cool','warm'];
      var tds = [];
      var src = imgSrc(it);
      tds.push('<td class="imgcol">'+ (src?('<img class="thumb" alt="" src="'+ esc(src) +'">'):'') +'</td>');
      tds.push('<td>'+ esc(shortPart(it.part)) +'</td>');
      tds.push('<td>'+ esc(it.name||'') +'</td>');
      tds.push('<td class="num">'+ esc(it.stars||'') +'</td>');
      for(var i=0;i<attrs.length;i++){ var v = it[attrs[i]]||''; tds.push('<td>'+ esc(v) +'</td>'); }
      tds.push('<td>'+ esc((it.tags||'').toString()) +'</td>');
      tds.push('<td class="num">'+ (typeof it.score!=='undefined'? esc(Math.round(toNum(it.score))) : '') +'</td>');
      return '<tr>'+ tds.join('') +'</tr>';
    }).join('');
    tbody.innerHTML = rows || '<tr><td colspan="16" class="empty">표시할 데이터가 없습니다.</td></tr>';
  }

  // Grouped by-part renderer
  function renderByPartTable(){
    var wrap = $('byPartWrap'); if(!wrap) return;
    var stSel = $('stageSelect');
    var stage = null;
    if(stSel && Array.isArray(window.stages)){
      stage = window.stages.find(function(s){ return String(s.stage_id)===String(stSel.value); }) || null;
    }
    var src = (typeof window.getFilteredList==='function') ? (window.items||[]).map(function(it){ 
      var s = (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(it, stage) : 0;
      return Object.assign({}, it, {score:s});
    }) : (window.items||[]);

    // group by part (top-level category like 헤어/원피스/… or full part string if 장식/특수)
    var groups = {};
    for(var i=0;i<src.length;i++){
      var it = src[i];
      var key = it && it.part || '';
      groups[key] = groups[key] || [];
      groups[key].push(it);
    }
    // sort parts alpha (ko)
    var parts = Object.keys(groups).sort(function(a,b){ return String(a).localeCompare(String(b),'ko'); });

    // build HTML
    var html = parts.map(function(part){
      var list = groups[part].slice().sort(function(a,b){ return toNum(b.score)-toNum(a.score); });
      var rows = list.map(function(it){
        return '<tr>'
          + '<td class="imgcol">'+ (imgSrc(it)?('<img class="thumb sm" alt="" src="'+ esc(imgSrc(it)) +'">'):'') +'</td>'
          + '<td>'+ esc(it.name||'') +'</td>'
          + '<td class="num">'+ esc(it.stars||'') +'</td>'
          + '<td class="num">'+ esc(Math.round(toNum(it.score))) +'</td>'
          + '</tr>';
      }).join('');
      var table = '<div class="group"><details open>'
        + '<summary>'+ esc(part) +' <span class="countpill">'+ list.length +'</span></summary>'
        + '<div class="inner"><table><thead><tr><th class="imgcol">이미지</th><th>이름</th><th class="num">별</th><th class="num">점수</th></tr></thead><tbody>'
        + (rows || '<tr><td colspan="4" class="empty">없음</td></tr>')
        + '</tbody></table></div></details></div>';
      return table;
    }).join('');
    wrap.innerHTML = html || '<div class="empty">데이터가 없습니다.</div>';
  }

  // Tab wiring
  function activateTab(key){
    var panels = {
      'calc': $('panel-calc'),
      'table': $('panel-table'),
      'by-part': $('panel-by-part')
    };
    // toggle classes
    document.querySelectorAll('nav.tabs .tab').forEach(function(btn){
      btn.classList.toggle('active', btn.getAttribute('data-tab')===key);
    });
    Object.keys(panels).forEach(function(k){
      var on = (k===key);
      if(panels[k]) panels[k].classList.toggle('active', on);
      if(panels[k]) panels[k].style.display = on ? 'block' : 'none';
    });
    // render target view
    try{
      if(key==='table') renderItemsTable();
      if(key==='by-part') renderByPartTable();
      if(key==='calc' && typeof window.renderAll==='function') window.renderAll();
    }catch(e){}
  }

  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('nav.tabs .tab');
    if(!t) return;
    var key = t.getAttribute('data-tab');
    if(!key) return;
    activateTab(key);
  }, false);

  // Keep tables in sync when key filters change
  document.addEventListener('change', function(ev){
    var id = ev.target && ev.target.id;
    if(id==='stageSelect' || id==='partFilter' || id==='sortBy'){
      var active = document.querySelector('nav.tabs .tab.active');
      var key = active ? active.getAttribute('data-tab') : 'calc';
      if(key==='table') renderItemsTable();
      if(key==='by-part') renderByPartTable();
    }
  }, false);

  // Hook renderAll so score changes reflect in the tables too
  (function wrapRenderAll(){
    if(typeof window.renderAll==='function'){
      var orig = window.renderAll;
      window.renderAll = function(){
        var r = orig.apply(this, arguments);
        try{
          var active = document.querySelector('nav.tabs .tab.active');
          var key = active ? active.getAttribute('data-tab') : 'calc';
          if(key==='table') renderItemsTable();
          if(key==='by-part') renderByPartTable();
        }catch(e){}
        return r;
      };
    }
  })();

  // Initial state after data load
  document.addEventListener('DOMContentLoaded', function(){
    // ensure only calc is visible initially
    activateTab('calc');
  });
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    activateTab('calc');
  };

  // Expose for debugging
  window.__renderItemsTable = renderItemsTable;
  window.__renderByPartTable = renderByPartTable;
})();
</script>
<!-- === ITEM CODE INPUT/UPDATE PATCH === -->
<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function normName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'').trim(); }
  function parseLines(txt){
    var lines = String(txt||'').split(/[\r\n]+/).map(function(s){ return s.trim(); }).filter(Boolean);
    var pairs = [];
    for(var i=0;i<lines.length;i++){
      var line = lines[i];
      var name='', code='';
      // 1) name:code
      if(line.indexOf(':')>-1){
        var seg = line.split(':');
        name = seg[0].trim();
        code = seg.slice(1).join(':').trim();
      } else if(line.indexOf(',')>-1){
        var seg2 = line.split(',');
        name = seg2[0].trim();
        code = seg2.slice(1).join(',').trim();
      } else {
        // split by whitespace; last token as code
        var seg3 = line.split(/\s+/);
        if(seg3.length>=2){
          code = seg3.pop().trim();
          name = seg3.join(' ').trim();
        } else {
          continue;
        }
      }
      if(name && code) pairs.push({name:name, code:code});
    }
    return pairs;
  }
  function copyPartOptions(){
    var src = $('partFilter');
    var dst = $('codePartSelect');
    if(!src || !dst) return;
    dst.innerHTML = '';
    // add "(선택)" placeholder
    var ph = document.createElement('option'); ph.value=''; ph.textContent='(부위 선택)'; dst.appendChild(ph);
    for(var i=0;i<src.options.length;i++){
      var opt = src.options[i];
      if(!opt.value) continue; // skip 전체
      var o = document.createElement('option');
      o.value = opt.value;
      o.textContent = opt.textContent || opt.text || opt.value;
      dst.appendChild(o);
    }
  }
  function applyCodes(){
    var partSel = $('codePartSelect');
    var txt = $('codeInput');
    if(!partSel || !txt) return;
    var part = partSel.value;
    if(!part){ alert('부위를 먼저 선택하세요.'); return; }
    var pairs = parseLines(txt.value);
    if(!pairs.length){ alert('코드 입력이 비어있어요.'); return; }

    var items = Array.isArray(window.items)? window.items : [];
    // Build map by normalized name within the selected part
    var map = Object.create(null);
    for(var i=0;i<items.length;i++){
      var it = items[i];
      if(String(it.part||'')!==String(part)) continue;
      var key = normName(it.name);
      if(key && !(key in map)) map[key] = it;
    }
    var updated = 0, missing = [];
    for(var j=0;j<pairs.length;j++){
      var p = pairs[j];
      var key2 = normName(p.name);
      var it2 = map[key2];
      if(it2){
        it2.code = p.code; // set/overwrite
        updated++;
      }else{
        missing.push(p.name);
      }
    }
    // feedback toast
    try{
      var t=document.getElementById('toast'); 
      if(t){ 
        t.textContent = '코드 갱신: '+updated+'개'+(missing.length?(' / 못찾음 '+missing.length+'개'):''); 
        t.classList.add('show'); 
        setTimeout(function(){ t.classList.remove('show'); }, 1500); 
      }
    }catch(e){}
    // re-render current view
    try{ if(typeof window.renderAll==='function') window.renderAll(); }catch(e){}
    try{
      var active = document.querySelector('nav.tabs .tab.active');
      var key = active ? active.getAttribute('data-tab') : 'calc';
      if (key==='table' && typeof window.__renderItemsTable==='function') window.__renderItemsTable();
      if (key==='by-part' && typeof window.__renderByPartTable==='function') window.__renderByPartTable();
    }catch(e){}
    if(missing.length){
      console.warn('[코드 미매칭]', missing);
    }
  }
  function clearCodesForPart(){
    var partSel = $('codePartSelect');
    if(!partSel) return;
    var part = partSel.value;
    if(!part){ alert('부위를 먼저 선택하세요.'); return; }
    var items = Array.isArray(window.items)? window.items : [];
    var cleared = 0;
    for(var i=0;i<items.length;i++){
      var it = items[i];
      if(String(it.part||'')!==String(part)) continue;
      if(it.code){ delete it.code; cleared++; }
    }
    try{
      var t=document.getElementById('toast'); 
      if(t){ 
        t.textContent = '코드 제거: '+cleared+'개'; 
        t.classList.add('show'); 
        setTimeout(function(){ t.classList.remove('show'); }, 1200); 
      }
    }catch(e){}
    try{ if(typeof window.renderAll==='function') window.renderAll(); }catch(e){}
    try{
      var active = document.querySelector('nav.tabs .tab.active');
      var key = active ? active.getAttribute('data-tab') : 'calc';
      if (key==='table' && typeof window.__renderItemsTable==='function') window.__renderItemsTable();
      if (key==='by-part' && typeof window.__renderByPartTable==='function') window.__renderByPartTable();
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{ copyPartOptions(); }catch(e){}
  });
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id==='applyCodesBtn'){ applyCodes(); }
    if(ev.target && ev.target.id==='clearCodesBtn'){ clearCodesForPart(); }
    if(ev.target && ev.target.id==='codeCopyParts'){ copyPartOptions(); }
  }, false);
  // Also refresh part list after init
  var __origInitCodes = window.init;
  window.init = function(){
    if (typeof __origInitCodes === 'function') __origInitCodes();
    try{ copyPartOptions(); }catch(e){}
  };
})();
</script>
<script>
(function(){
  // Override the table renderers to include '코드' column (after 부위)
  var _oldItemsTable = window.__renderItemsTable;
  if (typeof _oldItemsTable === 'function'){
    window.__renderItemsTable = function(){
      // Rebuild entirely with 'code' column
      var tbody = document.querySelector('#itemsTable tbody');
      if(!tbody) return;
      function $(id){ return document.getElementById(id); }
      function toNum(v){ var n=Number(v); return Number.isFinite(n)?n:0; }
      function esc(s){ return String(s==null?'':s).replace(/[&<>"]/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m];}); }
      function shortPart(p){ try{ if(typeof displayShort==='function') return displayShort(p); var s=String(p||''); var i=s.lastIndexOf(' - '); return i>=0?s.slice(i+3):s; }catch(e){ return p; } }
      function imgSrc(it){ try{ return (typeof toThumb==='function') ? toThumb(it.img) : (it.img||''); }catch(e){ return it.img||''; } }
      var stSel = $('stageSelect');
      var stage = null;
      if(stSel && Array.isArray(window.stages)){
        stage = window.stages.find(function(s){ return String(s.stage_id)===String(stSel.value); }) || null;
      }
      var list = (typeof window.getFilteredList==='function') ? window.getFilteredList(stage) : (window.items||[]);
      var sortSel = $('sortBy'); var sortKey = sortSel ? sortSel.value : 'score';
      list = list.slice();
      if(sortKey === 'name'){
        list.sort(function(a,b){ return String(a.name||'').localeCompare(String(b.name||''),'ko'); });
      }else{
        list.sort(function(a,b){ return toNum(b.score)-toNum(a.score); });
      }
      var attrs = ['flair','simple','elegant','lively','mature','cute','sexy','pure','cool','warm'];
      var rows = list.map(function(it){
        var tds = [];
        var src = imgSrc(it);
        tds.push('<td class="imgcol">'+ (src?('<img class="thumb" alt="" src="'+ esc(src) +'">'):'') +'</td>');
        tds.push('<td>'+ esc(shortPart(it.part)) +'</td>');
        tds.push('<td>'+ esc(it.code||'') +'</td>'); // 코드 column
        tds.push('<td>'+ esc(it.name||'') +'</td>');
        tds.push('<td class="num">'+ esc(it.stars||'') +'</td>');
        for(var i=0;i<attrs.length;i++){ var v = it[attrs[i]]||''; tds.push('<td>'+ esc(v) +'</td>'); }
        tds.push('<td>'+ esc((it.tags||'').toString()) +'</td>');
        tds.push('<td class="num">'+ (typeof it.score!=='undefined'? esc(Math.round(toNum(it.score))) : '') +'</td>');
        return '<tr>'+ tds.join('') +'</tr>';
      }).join('');
      tbody.innerHTML = rows || '<tr><td colspan="17" class="empty">표시할 데이터가 없습니다.</td></tr>';
    };
  }

  var _oldByPart = window.__renderByPartTable;
  if (typeof _oldByPart === 'function'){
    window.__renderByPartTable = function(){
      var wrap = document.getElementById('byPartWrap'); if(!wrap) return;
      function $(id){ return document.getElementById(id); }
      function esc(s){ return String(s==null?'':s).replace(/[&<>"]/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m];}); }
      function toNum(v){ var n=Number(v); return Number.isFinite(n)?n:0; }
      function imgSrc(it){ try{ return (typeof toThumb==='function') ? toThumb(it.img) : (it.img||''); }catch(e){ return it.img||''; } }
      var stSel = $('stageSelect');
      var stage = null;
      if(stSel && Array.isArray(window.stages)){
        stage = window.stages.find(function(s){ return String(s.stage_id)===String(stSel.value); }) || null;
      }
      var src = (typeof window.getFilteredList==='function') ? (window.items||[]).map(function(it){ 
        var s = (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(it, stage) : 0;
        return Object.assign({}, it, {score:s});
      }) : (window.items||[]);

      var groups = {};
      for(var i=0;i<src.length;i++){
        var it = src[i];
        var key = it && it.part || '';
        groups[key] = groups[key] || [];
        groups[key].push(it);
      }
      var parts = Object.keys(groups).sort(function(a,b){ return String(a).localeCompare(String(b),'ko'); });
      var html = parts.map(function(part){
        var list = groups[part].slice().sort(function(a,b){ return toNum(b.score)-toNum(a.score); });
        var rows = list.map(function(it){
          return '<tr>'
            + '<td class="imgcol">'+ (imgSrc(it)?('<img class="thumb sm" alt="" src="'+ esc(imgSrc(it)) +'">'):'') +'</td>'
            + '<td>'+ esc(it.name||'') +'</td>'
            + '<td>'+ esc(it.code||'') +'</td>'
            + '<td class="num">'+ esc(it.stars||'') +'</td>'
            + '<td class="num">'+ esc(Math.round(toNum(it.score))) +'</td>'
            + '</tr>';
        }).join('');
        var table = '<div class="group"><details open>'
          + '<summary>'+ esc(part) +' <span class="countpill">'+ list.length +'</span></summary>'
          + '<div class="inner"><table><thead><tr><th class="imgcol">이미지</th><th>이름</th><th>코드</th><th class="num">별</th><th class="num">점수</th></tr></thead><tbody>'
          + (rows || '<tr><td colspan="5" class="empty">없음</td></tr>')
          + '</tbody></table></div></details></div>';
        return table;
      }).join('');
      wrap.innerHTML = html || '<div class="empty">데이터가 없습니다.</div>';
    };
  }
})();
</script>
<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function normName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'').trim(); }
  function parseLines(txt){
    var lines = String(txt||'').split(/[\r\n]+/).map(function(s){ return s.trim(); }).filter(Boolean);
    var pairs = [];
    for(var i=0;i<lines.length;i++){
      var line = lines[i];
      var name='', code='';
      if(line.indexOf(':')>-1){
        var seg = line.split(':');
        name = seg[0].trim();
        code = seg.slice(1).join(':').trim();
      } else if(line.indexOf(',')>-1){
        var seg2 = line.split(',');
        name = seg2[0].trim();
        code = seg2.slice(1).join(',').trim();
      } else {
        var seg3 = line.split(/\s+/);
        if(seg3.length>=2){
          code = seg3.pop().trim();
          name = seg3.join(' ').trim();
        } else { continue; }
      }
      if(name && code) pairs.push({name:name, code:code});
    }
    return pairs;
  }
  function copyPartOptionsInline(){
    var src = $('partFilter');
    var dst = $('codePartSelectInline');
    if(!src || !dst) return;
    dst.innerHTML = '';
    var ph = document.createElement('option'); ph.value=''; ph.textContent='(부위 선택)'; dst.appendChild(ph);
    for(var i=0;i<src.options.length;i++){
      var opt = src.options[i];
      if(!opt.value) continue; // skip 전체
      var o = document.createElement('option');
      o.value = opt.value;
      o.textContent = opt.textContent || opt.text || opt.value;
      dst.appendChild(o);
    }
  }
  function switchOwnedMode(mode){
    var ta = $('ownedInput');
    var inline = $('codeInlineControls');
    if(!ta) return;
    if(mode==='code'){
      if(inline){ inline.style.display = 'flex'; }
      ta.placeholder = "예) 아이템이름: C00123\\n또는 '아이템이름, C00123' / '아이템이름 C00123'";
    }else{
      if(inline){ inline.style.display = 'none'; }
      ta.placeholder = "";
    }
  }
  function applyCodesInline(){
    var sel = $('codePartSelectInline');
    var ta = $('ownedInput');
    if(!sel || !ta) return;
    var part = sel.value;
    if(!part){ alert('부위를 먼저 선택하세요.'); return; }
    var pairs = parseLines(ta.value);
    if(!pairs.length){ alert('코드 입력이 비어있어요.'); return; }
    var items = Array.isArray(window.items)? window.items : [];
    var map = Object.create(null);
    for(var i=0;i<items.length;i++){
      var it = items[i];
      if(String(it.part||'')!==String(part)) continue;
      var key = normName(it.name);
      if(key && !(key in map)) map[key] = it;
    }
    var updated = 0, missing = [];
    for(var j=0;j<pairs.length;j++){
      var p = pairs[j];
      var key2 = normName(p.name);
      var it2 = map[key2];
      if(it2){ it2.code = p.code; updated++; } else { missing.push(p.name); }
    }
    // toast
    try{
      var t=document.getElementById('toast'); 
      if(t){ 
        t.textContent = '코드 갱신: '+updated+'개'+(missing.length?(' / 못찾음 '+missing.length+'개'):''); 
        t.classList.add('show'); 
        setTimeout(function(){ t.classList.remove('show'); }, 1500); 
      }
    }catch(e){}
    // refresh
    try{ if(typeof window.renderAll==='function') window.renderAll(); }catch(e){}
    try{
      var active = document.querySelector('nav.tabs .tab.active');
      var key = active ? active.getAttribute('data-tab') : 'calc';
      if (key==='table' && typeof window.__renderItemsTable==='function') window.__renderItemsTable();
      if (key==='by-part' && typeof window.__renderByPartTable==='function') window.__renderByPartTable();
    }catch(e){}
  }

  document.addEventListener('DOMContentLoaded', function(){
    copyPartOptionsInline();
    // default mode is 'owned'
    switchOwnedMode('owned');
  });
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id==='applyCodesBtnInline'){ applyCodesInline(); }
  }, false);
  document.addEventListener('change', function(ev){
    var el = ev.target;
    if (el && el.name==='ownedMode'){
      switchOwnedMode(el.value);
    }
  }, false);
  // also fill options after init
  var __origInitOwnedMode = window.init;
  window.init = function(){
    if (typeof __origInitOwnedMode === 'function') __origInitOwnedMode();
    copyPartOptionsInline();
  };
})();
</script>
<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function toNum(v){ var n=Number(v); return Number.isFinite(n)?n:0; }
  function esc(s){ return String(s==null?'':s).replace(/[&<>"]/g, function(m){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m];}); }

  // Build a map of { part: { code: [items...] } }
  function buildCodeIndex(){
    var items = Array.isArray(window.items)? window.items : [];
    var idx = Object.create(null);
    for(var i=0;i<items.length;i++){
      var it = items[i];
      var part = String(it.part||'');
      var code = String(it.code||'').trim();
      if(!code) continue;
      if(!idx[part]) idx[part] = Object.create(null);
      if(!idx[part][code]) idx[part][code] = [];
      idx[part][code].push(it);
    }
    return idx;
  }

  // Duplicate count for a given part
  function dupCountForPart(part){
    var idx = buildCodeIndex();
    var d = 0;
    var m = idx[part] || {};
    for (var c in m){
      if (m[c] && m[c].length > 1) d++;
    }
    return d;
  }

  // Expose for debugging
  window.__codeIndex = buildCodeIndex;

  // Patch: integrate search box to filter also by code (and part/tags/name as before)
  function searchMatch(it, q){
    if(!q) return true;
    q = q.toLowerCase();
    var fields = [
      String(it.name||''),
      String(it.part||''),
      String(it.tags||''),
      String(it.code||'')
    ];
    for(var i=0;i<fields.length;i++){
      if(fields[i].toLowerCase().indexOf(q)!==-1) return true;
    }
    return false;
  }

  // Override renderers to include search & duplicate badges
  var _oldIT = window.__renderItemsTable;
  if (typeof _oldIT === 'function'){
    window.__renderItemsTable = function(){
      var tbody = document.querySelector('#itemsTable tbody');
      if(!tbody) return;
      var stSel = $('stageSelect');
      var stage = null;
      if(stSel && Array.isArray(window.stages)){
        stage = window.stages.find(function(s){ return String(s.stage_id)===String(stSel.value); }) || null;
      }
      var list = (typeof window.getFilteredList==='function') ? window.getFilteredList(stage) : (window.items||[]);
      // Apply search
      var qEl = $('tableSearch'); var q = qEl ? qEl.value : '';
      if(q){ list = list.filter(function(it){ return searchMatch(it, q); }); }

      // Sorting
      var sortSel = $('sortBy'); var sortKey = sortSel ? sortSel.value : 'score';
      list = list.slice();
      if(sortKey === 'name'){
        list.sort(function(a,b){ return String(a.name||'').localeCompare(String(b.name||''),'ko'); });
      }else{
        list.sort(function(a,b){ return toNum(b.score)-toNum(a.score); });
      }

      // Duplicate badge logic (per-part)
      var codeIdx = __codeIndex();
      function codeCell(it){
        var code = String(it.code||'');
        if(!code) return '';
        var dup = (codeIdx[String(it.part||'')] && codeIdx[String(it.part||'')][code] && codeIdx[String(it.part||'')][code].length>1);
        return esc(code) + (dup ? ' <span class="badge" title="같은 부위에서 중복 코드">중복</span>' : '');
      }

      // Build rows
      var attrs = ['flair','simple','elegant','lively','mature','cute','sexy','pure','cool','warm'];
      var rows = list.map(function(it){
        var src = (typeof toThumb==='function') ? toThumb(it.img) : (it.img||'');
        return '<tr>'
          + '<td class="imgcol">'+ (src?('<img class="thumb" alt="" src="'+ esc(src) +'">'):'') +'</td>'
          + '<td>'+ esc((typeof displayShort==='function')?displayShort(it.part):it.part) +'</td>'
          + '<td>'+ codeCell(it) +'</td>'
          + '<td>'+ esc(it.name||'') +'</td>'
          + '<td class="num">'+ esc(it.stars||'') +'</td>'
          + attrs.map(function(a){ return '<td>'+ esc(it[a]||'') +'</td>'; }).join('')
          + '<td>'+ esc((it.tags||'').toString()) +'</td>'
          + '<td class="num">'+ (typeof it.score!=='undefined'? esc(Math.round(toNum(it.score))) : '') +'</td>'
          + '</tr>';
      }).join('');
      tbody.innerHTML = rows || '<tr><td colspan="17" class="empty">표시할 데이터가 없습니다.</td></tr>';
    };
  }

  var _oldBP = window.__renderByPartTable;
  if (typeof _oldBP === 'function'){
    window.__renderByPartTable = function(){
      var wrap = document.getElementById('byPartWrap'); if(!wrap) return;
      var stSel = $('stageSelect');
      var stage = null;
      if(stSel && Array.isArray(window.stages)){
        stage = window.stages.find(function(s){ return String(s.stage_id)===String(stSel.value); }) || null;
      }
      var src = (typeof window.getFilteredList==='function') ? (window.items||[]).map(function(it){
        var s = (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(it, stage) : 0;
        return Object.assign({}, it, {score:s});
      }) : (window.items||[]);

      // Optional: filter by search in this view too
      var qEl = $('tableSearch'); var q = qEl ? qEl.value : '';
      if(q){ src = src.filter(function(it){ return searchMatch(it, q); }); }

      var groups = {};
      for(var i=0;i<src.length;i++){
        var it = src[i];
        var key = it && it.part || '';
        groups[key] = groups[key] || [];
        groups[key].push(it);
      }
      var parts = Object.keys(groups).sort(function(a,b){ return String(a).localeCompare(String(b),'ko'); });

      var codeIdx = __codeIndex();
      function codeCell(it){
        var code = String(it.code||'');
        if(!code) return '';
        var dup = (codeIdx[String(it.part||'')] && codeIdx[String(it.part||'')][code] && codeIdx[String(it.part||'')][code].length>1);
        return esc(code) + (dup ? ' <span class="badge" title="같은 부위에서 중복 코드">중복</span>' : '');
      }

      var html = parts.map(function(part){
        var list = groups[part].slice().sort(function(a,b){ return toNum(b.score)-toNum(a.score); });
        var rows = list.map(function(it){
          var src = (typeof toThumb==='function') ? toThumb(it.img) : (it.img||'');
          return '<tr>'
            + '<td class="imgcol">'+ (src?('<img class="thumb sm" alt="" src="'+ esc(src) +'">'):'') +'</td>'
            + '<td>'+ esc(it.name||'') +'</td>'
            + '<td>'+ codeCell(it) +'</td>'
            + '<td class="num">'+ esc(it.stars||'') +'</td>'
            + '<td class="num">'+ esc(Math.round(toNum(it.score))) +'</td>'
            + '</tr>';
        }).join('');
        var table = '<div class="group"><details open>'
          + '<summary>'+ esc(part) +' <span class="countpill">'+ list.length +'</span></summary>'
          + '<div class="inner"><table><thead><tr><th class="imgcol">이미지</th><th>이름</th><th>코드</th><th class="num">별</th><th class="num">점수</th></tr></thead><tbody>'
          + (rows || '<tr><td colspan="5" class="empty">없음</td></tr>')
          + '</tbody></table></div></details></div>';
        return table;
      }).join('');
      wrap.innerHTML = html || '<div class="empty">데이터가 없습니다.</div>';
    };
  }

  // Wire search input & clear button
  document.addEventListener('input', function(ev){
    if(ev.target && ev.target.id==='tableSearch'){
      try{
        var active = document.querySelector('nav.tabs .tab.active');
        var key = active ? active.getAttribute('data-tab') : 'calc';
        if (key==='table' && typeof window.__renderItemsTable==='function') window.__renderItemsTable();
        if (key==='by-part' && typeof window.__renderByPartTable==='function') window.__renderByPartTable();
      }catch(e){}
    }
  }, false);
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id==='tableClear'){
      var el = $('tableSearch'); if(el){ el.value=''; }
      try{
        var active = document.querySelector('nav.tabs .tab.active');
        var key = active ? active.getAttribute('data-tab') : 'calc';
        if (key==='table' && typeof window.__renderItemsTable==='function') window.__renderItemsTable();
        if (key==='by-part' && typeof window.__renderByPartTable==='function') window.__renderByPartTable();
      }catch(e){}
    }
  }, false);

  // On inline code apply, warn about duplicates scoped to the selected part
  var _applyInline = window.applyCodesInline;
  if (typeof _applyInline === 'function'){
    window.applyCodesInline = function(){
      _applyInline();
      try{
        var partSel = $('codePartSelectInline');
        var part = partSel ? partSel.value : '';
        if(part){
          var d = dupCountForPart(part);
          if(d>0){
            var t = $('toast');
            if(t){
              t.textContent = '경고: 같은 부위에 중복 코드 ' + d + '개';
              t.classList.add('show');
              setTimeout(function(){ t.classList.remove('show'); }, 1600);
            }
          }
        }
      }catch(e){}
    };
  }
})();
</script>
<script>
// Robust boot: ensure stageSelect gets populated even if message timing is odd
(function(){
  function safePopulate(){ try{ if(typeof window.__populateStages === 'function') window.__populateStages(); }catch(e){} }
  // On DOM ready
  document.addEventListener('DOMContentLoaded', safePopulate);
  // After load
  window.addEventListener('load', safePopulate);
  // Poll until stages exist and select has options
  (function(){
    let n=0; const t=setInterval(function(){
      n++;
      const sel = document.getElementById('stageSelect');
      if (Array.isArray(window.stages) && window.stages.length && sel && sel.options && sel.options.length===0){
        safePopulate();
      }
      if (n>30) clearInterval(t);
    }, 200);
  })();
})();
</script>
<script>
// Filter stages to ONLY those that have required_parts (at least one non-empty entry)
(function(){
  function hasRequired(stage){
    try{
      var rp = stage && stage.required_parts;
      if(!rp || typeof rp!=='object') return False;
    }catch(e){}
    rp = stage.required_parts || {};
    for (var k in rp){
      if(!Object.prototype.hasOwnProperty.call(rp,k)) continue;
      var v = rp[k];
      if(Array.isArray(v) && v.length>0) return true;
      if(v && typeof v==='string' && v.trim()) return true;
      if(v && typeof v==='object'){
        for (var kk in v){
          if(!Object.prototype.hasOwnProperty.call(v,kk)) continue;
          if(String(v[kk]||'').trim()){ return true; }
        }
      }
    }
    return false;
  }

  // Patch the message handler that receives stages
  try{
    var _origAddEventListener = window.addEventListener;
    // Wrap only once
    if(!window.__requiredOnlyPatched){
      window.__requiredOnlyPatched = true;
      var handlerRef = null;
      // Monkey patch addEventListener to intercept our specific 'message' listener
      window.addEventListener = function(type, listener, opts){
        if(type==='message' && !handlerRef){
          handlerRef = function(ev){
            try{
              var msg = ev.data;
              if(msg && msg.__splitData && msg.key==='stages'){
                // Filter stages
                var src = Array.isArray(msg.data) ? msg.data : [];
                var filt = src.filter(hasRequired);
                // Replace the payload before passing on
                ev = Object.assign({}, ev, { data: Object.assign({}, msg, { data: filt }) });
              }
            }catch(e){}
            try{ return listener.apply(this, arguments); }catch(e){}
          };
          return _origAddEventListener.call(this, type, handlerRef, opts);
        }
        return _origAddEventListener.call(this, type, listener, opts);
      };
    }
  }catch(e){}

  // Fallback: if stages already present, filter immediately
  document.addEventListener('DOMContentLoaded', function(){
    try{
      if(Array.isArray(window.stages)){
        window.stages = window.stages.filter(hasRequired);
      }
      if(typeof window.__populateStages==='function'){ window.__populateStages(); }
      if(typeof window.renderAll==='function'){ window.renderAll(); }
    }catch(e){}
  });
})();
</script>
<script>
// Keep original stage scaling: stage[a] * (stage.weight/9); no profiles.
(function(){
  window.scoreItemForStage = function(item, stage){
    try{
      if(!stage) return 0;
      const attrs=['flair','simple','elegant','lively','mature','cute','sexy','pure','cool','warm'];

      // Name-only mine-items zeroing
      try{
        const nameStr = (item && item.name) ? String(item.name).trim() : "";
        const mineNames = (stage && Array.isArray(stage.mine_items)) ? stage.mine_items : [];
        if (mineNames.length && mineNames.includes(nameStr)) return 0;
      }catch(e){}

      const toNum=(v)=>{const n=Number(v);return Number.isFinite(n)?n:0;};
      const factor = toNum(stage.weight||9) / 9;
      const stageW = Object.assign({}, stage);
      let base = 0;
      for(const a of attrs){
        const grade = (typeof gradeToScore==='function') ? (item[a]) : toNum(item[a]);
        const bonus = toNum(item[a + "_bonus"] || 0);
        const w = toNum(stageW[a] || 0) * factor; // ← keep stage[a] * (weight/9)
        base += w * (grade + bonus);
      }
      const starMul = (typeof starMultiplier==='function') ? starMultiplier(item.stars) : 1;
      const partMul = (window.PART_WEIGHTS && window.PART_WEIGHTS[item.part]) ? window.PART_WEIGHTS[item.part] : 1;
      return base * starMul * partMul;
    }catch(e){ return 0; }
  };
})();
</script>
<!-- scoring patch (inline, logic only; no template changes) -->
<script>
/* PATCH CODE START */
(function(){
  'use strict';
  const REQUIRED_MULTIPLIER = 1.3;
  const ATTRS = ['flair','simple','elegant','lively','mature','cute','sexy','pure','cool','warm'];
  const GRADE_INDEX = { 'SS':0, 'S':1, 'A':2, 'B':3, 'C':4 };
  const DEFAULT_LEVEL_TABLE = [0.6, 0.9, 1.0, 1.2, 1.5];
  const DEFAULT_GRADE_VECTOR = [5,4,3,2,1];
  function toNum(x){ var n = Number(x); return Number.isFinite(n) ? n : 0; }
  function clamp(n, lo, hi){ n = toNum(n); if(n<lo) return lo; if(n>hi) return hi; return n; }
  function normName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,''); }
  function getRequiredNameSetSafe(){ try { if (typeof window.getRequiredNameSet === 'function') return window.getRequiredNameSet(); } catch(e){} return new Set(); }
  function isMinedItem(item, stage){ try{ const nameStr = (item && item.name) ? String(item.name).trim() : ""; const mineNames = (stage && Array.isArray(stage.mine_items)) ? stage.mine_items : []; return (mineNames.length && mineNames.includes(nameStr)); }catch(e){ return false; } }
  function effectiveLevelTable(stage){ const t = stage && Array.isArray(stage.level_table) && stage.level_table.length>=5 ? stage.level_table : DEFAULT_LEVEL_TABLE; return [0,1,2,3,4].map(i => toNum(t[i] ?? DEFAULT_LEVEL_TABLE[i])); }
  function styleWeightFor(stage, attr){
    try{ if (stage && stage.style_weights && (attr in stage.style_weights)){ const v = toNum(stage.style_weights[attr]); return v; } }catch(e){}
    try{ if (stage && stage.style_levels && stage.style_levels[attr]){ const table = effectiveLevelTable(stage); const lvl = clamp(stage.style_levels[attr], 1, 5); return table[lvl-1]; } }catch(e){}
    const factor = toNum(stage && stage.weight || 9)/9; return toNum(stage && stage[attr]) * factor;
  }
  function gradeToWeightedScore(stage, attr, gradeStr){ try{ const idx = GRADE_INDEX[String(gradeStr||'').toUpperCase()]; if (idx == null) return 0; const vec = (stage && stage.grade_vectors && Array.isArray(stage.grade_vectors[attr])) ? stage.grade_vectors[attr] : DEFAULT_GRADE_VECTOR; const v = vec[idx]; return toNum(v); }catch(e){ return 0; } }
  (function patch(){
    const orig = window.scoreItemForStage;
    window.scoreItemForStage = function(item, stage){
      if(!stage) return 0;
      if (isMinedItem(item, stage)) return 0;
      let base = 0;
      for (const a of ATTRS){
        const gradeVal = gradeToWeightedScore(stage, a, item && item[a]);
        const bonus = toNum(item && item[`${a}_bonus`]);
        const w = styleWeightFor(stage, a);
        base += w * (gradeVal + bonus);
      }
      const starMul = (typeof window.starMultiplier === 'function') ? window.starMultiplier(item && item.stars) : 1;
      const partMul = (window.PART_WEIGHTS && (window.PART_WEIGHTS[item && item.part]||1)) || 1;
      let score = base * starMul * partMul + GRADE_OFFSET[item.grade];
      try{ const reqSet = getRequiredNameSetSafe(); const nameNorm = (typeof window.normOwnedName === 'function') ? window.normOwnedName(item && item.name) : normName(item && item.name); if (reqSet && (reqSet.has(nameNorm) || reqSet.has(String(item && item.name)))){ score *= REQUIRED_MULTIPLIER; } }catch(e){}
      return score;
    };
    window.__NIKKI_PATCH__ = {
      REQUIRED_MULTIPLIER,
      DEFAULT_LEVEL_TABLE,
      DEFAULT_GRADE_VECTOR,
      setStageLevels(stage, levels){ if (!stage) return; stage.style_levels = Object.assign({}, stage.style_levels||{}, levels||{}); },
      setStageLevelTable(stage, table5){ if (!stage) return; if (!Array.isArray(table5) || table5.length < 5) return; stage.level_table = table5.slice(0,5).map(toNum); },
      setStageGrades(stage, gradeVectors){ if (!stage) return; stage.grade_vectors = Object.assign({}, stage.grade_vectors||{}, gradeVectors||{}); },
      setStageStyleWeights(stage, weights){ if (!stage) return; stage.style_weights = Object.assign({}, stage.style_weights||{}, weights||{}); },
      clearStageOverrides(stage){ if (!stage) return; delete stage.style_levels; delete stage.level_table; delete stage.grade_vectors; delete stage.style_weights; }
    };
  })();
})(); /* PATCH CODE END */

</script>
<!-- chips fix patch (logic-only) -->
<script>

/* ===============================================================
   chips_fix_20251017.js (drop-in)
   - Ensures that when clicking group tabs (의상/장식/특수/뷰티/반딧불의 영혼),
     the sub-chips render correctly.
   - Keeps template/DOM unchanged. Logic-only patch.
   =============================================================== */
(function(){
  'use strict';

  // Helpers
  function $(id){ return document.getElementById(id); }
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }

  // Part selection helper: tries by value, then by visible text
  function selectPartInFilter(partLabel){
    var sel = $('partFilter');
    if(!sel) return;
    var targetText = String(partLabel||'').trim();
    var found = false;

    // 1) exact match by value
    for (var i=0;i<sel.options.length;i++){
      if (sel.options[i].value === targetText){
        sel.selectedIndex = i; found = true; break;
      }
    }
    // 2) fallback: match by visible text (for cases where value is wrong or duplicated)
    if (!found){
      for (var j=0;j<sel.options.length;j++){
        var txt = (sel.options[j].text || '').trim();
        if (txt === targetText){
          sel.selectedIndex = j; found = true; break;
        }
      }
    }
    // 3) fallback: contains match on text
    if (!found){
      for (var k=0;k<sel.options.length;k++){
        var txt2 = (sel.options[k].text || '').trim();
        if (txt2.indexOf(targetText) !== -1){
          sel.selectedIndex = k; found = true; break;
        }
      }
    }
    sel.dispatchEvent(new Event('change', {bubbles:true}));
  }

  // Chip HTML
  function chipHtml(label, partValue){
    var pv = partValue || label;
    var lbl = String(label||'');
    try{
      if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
        var segs = lbl.split(' - ');
        lbl = segs[segs.length-1];
      }
    }catch(e){}
    return '<span class="chip" data-part="'+ String(pv).replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         + '</span>';
  }

  // Orders
  var ORDER_WEAR = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];
  var ORDER_BEAUTY = ["뷰티"];
  var ORDER_SOUL = ["반딧불의 영혼"];

  // Accessory detailed subparts (full labels so we can show fine-grained chips)
  var ORDER_ACC_DETAIL = [
    "장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식",
    "장식 - 귀",
    "장식 - 목 - 목도리","장식 - 목 - 목걸이",
    "장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑",
    "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손",
    "장식 - 허리",
    "장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리",
    "장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"
  ];

  // Render functions
  function renderChipsWear(){
    var row = $('partChips'); if (!row) return;
    row.innerHTML = ORDER_WEAR.map(function(p){ return chipHtml(p, p); }).join('');
  }
  function renderChipsAcc(){
    var row = $('partChips'); if (!row) return;
    row.innerHTML = ORDER_ACC_DETAIL.map(function(p){ return chipHtml(p, p); }).join('');
  }
  function renderChipsBeauty(){
    var row = $('partChips'); if (!row) return;
    row.innerHTML = ORDER_BEAUTY.map(function(p){ return chipHtml(p, p); }).join('');
  }
  function renderChipsSoul(){
    var row = $('partChips'); if (!row) return;
    row.innerHTML = ORDER_SOUL.map(function(p){ return chipHtml(p, p); }).join('');
  }

  // setGroup override
  function setGroupPatched(g){
    try{
      var tabs = document.querySelectorAll('#partTabs .gtab');
      tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    }catch(e){}

    if (g === 'wear') return renderChipsWear();
    if (g === 'acc') return renderChipsAcc();
    if (g === 'beauty') return renderChipsBeauty();
    if (g === 'soul') return renderChipsSoul();
    if (g === 'special'){
      // 기존 특수 렌더러가 있으면 사용, 없으면 acc의 특수 서브셋으로 대체
      if (typeof window.renderSpecialChips === 'function'){
        try{ return window.renderSpecialChips(); }catch(e){}
      }
      return renderChipsAcc(); // fallback
    }
    // default fallback
    renderChipsWear();
  }

  // Click handlers: chip -> sync to partFilter
  document.addEventListener('click', function(ev){
    var chip = ev.target && ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return;
    // Try to map "장식 - X - Y" to a reasonable filter option.
    // 1) If exact value exists, select by value
    // 2) Else, try the last token (Y), then middle token (X), then full text
    var label = part;
    var segs = part.split(' - ');
    if (segs.length >= 3){
      // Prefer the leaf label (e.g., "베일","헤어핀"...)
      selectPartInFilter(segs[segs.length-1]);
    } else if (segs.length === 2){
      selectPartInFilter(segs[1]);
    } else {
      selectPartInFilter(label);
    }
  }, false);

  // Bind tab buttons to new setGroup
  document.addEventListener('click', function(ev){
    var btn = ev.target && ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (!btn) return;
    var g = btn.getAttribute('data-g');
    if (!g) return;
    setGroupPatched(g);
  }, false);

  // Initial render: ensure default (의상) shows
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      setGroupPatched(g);
    }catch(e){ setGroupPatched('wear'); }
  });

  // Expose for debug
  window.__CHIPS_FIX__ = { setGroup: setGroupPatched };
})();

</script>
<!-- chips counts patch (logic-only) -->
<script>

/* ===============================================================
   chips_counts_fix_20251017.js (drop-in)
   - Adds "보유/전체" counts onto each sub-chip label.
   - Works with existing template; logic only.
   - Updates counts live when ownedInput changes or data loads.
   =============================================================== */
(function(){
  'use strict';
  function $(id){ return document.getElementById(id); }
  function normName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/[\s\u00A0]+/g,''); }

  // Parse owned list from textarea
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }

  // Build quick index: normalized name -> first item
  function buildNameIndex(items){
    var map = Object.create(null);
    for (var i=0;i<(items||[]).length;i++){
      var it = items[i];
      var key = normName(it && it.name);
      if (key && !map[key]) map[key] = it;
    }
    return map;
  }

  // Compute counts for a list of "parts" (strings). Returns { part: {owned,total} }
  function computeCounts(parts){
    var items = Array.isArray(window.ITEMS) ? window.ITEMS : (Array.isArray(window.items) ? window.items : []);
    var nameIndex = buildNameIndex(items);
    var totals = Object.create(null);
    var owned = Object.create(null);

    // total by exact part string
    for (var i=0;i<items.length;i++){
      var p = String(items[i] && items[i].part || '');
      totals[p] = (totals[p]||0) + 1;
    }

    // owned by mapping textarea names -> item -> part
    var ta = $('ownedInput');
    var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    for (var j=0;j<names.length;j++){
      var it = nameIndex[normName(names[j])];
      if (!it) continue;
      var pp = String(it.part||'');
      owned[pp] = (owned[pp]||0) + 1;
    }

    // assemble result only for requested parts
    var out = Object.create(null);
    for (var k=0;k<parts.length;k++){
      var p2 = String(parts[k]);
      out[p2] = { owned: owned[p2]||0, total: totals[p2]||0 };
    }
    return out;
  }

  // Chip HTML with counts
  function chipHtmlWithCount(label, partValue, counts){
    var pv = partValue || label;
    var lbl = String(label||'');
    try{
      if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
        var segs = lbl.split(' - ');
        lbl = segs[segs.length-1];
      }
    }catch(e){}
    var c = counts && counts[partValue] || {owned:0,total:0};
    return '<span class="chip" data-part="'+ String(pv).replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v"> '+ c.owned + '/' + c.total + '</span>'
         + '</span>';
  }

  // Orders (same as prior patch)
  var ORDER_WEAR   = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];
  var ORDER_BEAUTY = ["뷰티"];
  var ORDER_SOUL   = ["반딧불의 영혼"];
  var ORDER_ACC_DETAIL = [
    "장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식",
    "장식 - 귀",
    "장식 - 목 - 목도리","장식 - 목 - 목걸이",
    "장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑",
    "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손",
    "장식 - 허리",
    "장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리",
    "장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"
  ];

  // Renders
  function renderWear(){
    var row = $('partChips'); if (!row) return;
    var counts = computeCounts(ORDER_WEAR);
    row.innerHTML = ORDER_WEAR.map(function(p){ return chipHtmlWithCount(p, p, counts); }).join('');
  }
  function renderAcc(){
    var row = $('partChips'); if (!row) return;
    var counts = computeCounts(ORDER_ACC_DETAIL);
    row.innerHTML = ORDER_ACC_DETAIL.map(function(p){ return chipHtmlWithCount(p, p, counts); }).join('');
  }
  function renderBeauty(){
    var row = $('partChips'); if (!row) return;
    var counts = computeCounts(ORDER_BEAUTY);
    row.innerHTML = ORDER_BEAUTY.map(function(p){ return chipHtmlWithCount(p, p, counts); }).join('');
  }
  function renderSoul(){
    var row = $('partChips'); if (!row) return;
    var counts = computeCounts(ORDER_SOUL);
    row.innerHTML = ORDER_SOUL.map(function(p){ return chipHtmlWithCount(p, p, counts); }).join('');
  }

  function selectPartInFilter(partLabel){
    var sel = $('partFilter');
    if(!sel) return;
    var targetText = String(partLabel||'').trim();
    var found = false;
    for (var i=0;i<sel.options.length;i++){
      if (sel.options[i].value === targetText){ sel.selectedIndex = i; found = true; break; }
    }
    if (!found){
      for (var j=0;j<sel.options.length;j++){
        var txt = (sel.options[j].text || '').trim();
        if (txt === targetText){ sel.selectedIndex = j; found = true; break; }
      }
    }
    if (!found){
      for (var k=0;k<sel.options.length;k++){
        var txt2 = (sel.options[k].text || '').trim();
        if (txt2.indexOf(targetText)!==-1){ sel.selectedIndex = k; found = true; break; }
      }
    }
    sel.dispatchEvent(new Event('change', {bubbles:true}));
  }

  function setGroupCounts(g){
    try{
      var tabs = document.querySelectorAll('#partTabs .gtab');
      tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    }catch(e){}
    if (g === 'wear')   return renderWear();
    if (g === 'acc')    return renderAcc();
    if (g === 'beauty') return renderBeauty();
    if (g === 'soul')   return renderSoul();
    // special: try existing renderSpecialChips if present
    if (g === 'special'){
      if (typeof window.renderSpecialChips === 'function'){
        try{ return window.renderSpecialChips(); }catch(e){}
      }
      return renderAcc(); // fallback
    }
    renderWear();
  }

  // Chip click -> filter sync
  document.addEventListener('click', function(ev){
    var chip = ev.target && ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var label = chip.getAttribute('data-part') || '';
    var segs = label.split(' - ');
    if (segs.length >= 3)      selectPartInFilter(segs[segs.length-1]);
    else if (segs.length ===2) selectPartInFilter(segs[1]);
    else                       selectPartInFilter(label);
  }, false);

  // Tab click -> re-render with counts
  document.addEventListener('click', function(ev){
    var btn = ev.target && ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (!btn) return;
    var g = btn.getAttribute('data-g');
    if (!g) return;
    setGroupCounts(g);
  }, false);

  // Live update on ownedInput change
  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      setGroupCounts(g);
    }
  });

  // Initial render
  document.addEventListener('DOMContentLoaded', function(){
    var on = document.querySelector('#partTabs .gtab.is-on');
    var g = on ? on.getAttribute('data-g') : 'wear';
    setGroupCounts(g);
  });

  // expose
  window.__CHIPS_COUNTS_FIX__ = { setGroup: setGroupCounts };
})();

</script>
<script>
// === TAG GRADE + WEIGHT PATCH (SSS~C) ===
(function(){
  'use strict';
  var ORIG = window.scoreItemForStage;
  if (typeof ORIG !== 'function') return;

  var GRADE_INDEX = { 'SSS':0, 'SS':1, 'S':2, 'A':3, 'B':4, 'C':5 };
  /* GRADE_VECTOR removed in v17 */

  function norm(s){ return String(s||'').normalize('NFKC').toLowerCase().trim(); }
  function toNum(x){ var n=Number(x); return Number.isFinite(n)?n:0; }
  function gradeToMul(g){
    if (g == null) return 1;
    var key = String(g).trim().toUpperCase();
    return Object.prototype.hasOwnProperty.call(GRADE_INDEX, key)
      ? GRADE_VECTOR[ GRADE_INDEX[key] ] : 1;
  }

  function computePerTagFactor(tag, stage){
    var t = norm(tag), mul = 1;
    // Combined rules
    var rules = stage && stage.tag_rules;
    if (rules && rules[t] && typeof rules[t] === 'object'){
      if (rules[t].grade != null) mul *= gradeToMul(rules[t].grade);
      if (rules[t].weight != null) { var w=toNum(rules[t].weight); if (w>0) mul *= w; }
    }
    // Separate tables
    var grades = stage && stage.tag_grades;
    if (grades && grades[t] != null) mul *= gradeToMul(grades[t]);
    var weights = stage && stage.tag_weights;
    if (weights){ var w2 = toNum(weights[t]); if (w2>0) mul *= w2; }
    // Optional percent table
    var pct = stage && stage.tag_weights_pct;
    if (pct){ var p = toNum(pct[t]); if (p) mul *= (1+p/100); }
    return mul;
  }

  function computeTagFactor(item, stage){
    var tags = Array.isArray(item && item.tags) ? item.tags : [];
    if (!tags.length) return 1;
    var f = 1;
    for (var i=0;i<tags.length;i++) f *= computePerTagFactor(tags[i], stage);
    if (f < 0.1) f = 0.1; if (f > 5.0) f = 5.0;
    return f;
  }

  window.scoreItemForStage = function(item, stage){
    var base = ORIG(item, stage);
    if (!Number.isFinite(base) || base <= 0) return 0; // keep mine-item zero rule
    return base * computeTagFactor(item, stage);
  };
  console.log('[TAG GRADE+WEIGHT] enabled (SSS~C)');
})();
</script>
<!-- === PATCH: robust chip counter (wear/acc/beauty/soul) === -->
<script>
(function(){
  // Guard: only apply once
  if (window.__chipPatchApplied) return;
  window.__chipPatchApplied = true;

  // Safe helpers
  function normName(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }

  // Orders
  var ORDER_WEAR   = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티"];
  var ORDER_BEAUTY = ["뷰티"];
  var ORDER_SOUL   = ["반딧불의 영혼"];

  // Accessory detailed lists (used to compute totals even if partFilter values differ)
  var ACC_SINGLES = [
    "장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식",
    "장식 - 귀",
    "장식 - 목 - 목도리","장식 - 목 - 목걸이",
    "장식 - 손 - 장갑",
    "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손",
    "장식 - 허리"
  ];
  var ACC_PALJJI = ["장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)"];
  var ACC_BACK   = []; // 등 장식 세분류가 있으면 여기에 추가
  var ACC_SPEC   = ["장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리",
                    "장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"];

  function computeStats(){
    var items = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var it of items){
      var p = (it && it.part) || '';
      totals[p] = (totals[p]||0)+1;
      var key = (window.normOwnedName ? window.normOwnedName(it && it.name) : normName(it && it.name));
      if (key && !(key in byName)) byName[key] = it;
    }
    var ta = document.getElementById('ownedInput');
    var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    var ownedPer = Object.create(null);
    for (var n of names){
      var it2 = byName[(window.normOwnedName ? window.normOwnedName(n) : normName(n))];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }
    return { totals, ownedPer };
  }

  function sumCounts(keys, map){
    var s = 0;
    for (var i=0;i<keys.length;i++){ s += map[keys[i]] || 0; }
    return s;
  }

  function chipHtml(label, owned, total, partValue){
    var pv = partValue || '';
    var lbl = String(label||'');
    try{
      // shorten decoration label for view
      if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
        var segs = lbl.split(' - ');
        lbl = segs[segs.length-1];
      }
    }catch(e){}
    return '<span class="chip" data-part="'+ pv.replace(/"/g,'&quot;') +'">'
         +   '<span class="k">'+ lbl +'</span>'
         +   '<span class="v">'+ (owned||0) +'/'+ (total||0) +'</span>'
         + '</span>';
  }

  // Public renderer (overrides any broken earlier one)
  window.renderChips = function(groupKey){
    var row = document.getElementById('partChips'); if (!row) return;
    var S = computeStats();
    var html = '';

    if (groupKey === 'acc'){
      // Accessory: singles + grouped badges (non-clickable for aggregates)
      var pieces = [];
      for (var p of ACC_SINGLES){
        pieces.push(chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p));
      }
      pieces.push(chipHtml("팔찌",        sumCounts(ACC_PALJJI, S.ownedPer), sumCounts(ACC_PALJJI, S.totals), ""));
      pieces.push(chipHtml("등 장식",     sumCounts(ACC_BACK,   S.ownedPer), sumCounts(ACC_BACK,   S.totals), ""));
      pieces.push(chipHtml("특수 아이템", sumCounts(ACC_SPEC,   S.ownedPer), sumCounts(ACC_SPEC,   S.totals), ""));
      html = pieces.join('');
    } else if (groupKey === 'beauty'){
      html = ORDER_BEAUTY.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    } else if (groupKey === 'soul'){
      html = ORDER_SOUL.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    } else {
      // default -> wear
      html = ORDER_WEAR.map(function(p){
        return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p);
      }).join('');
    }

    row.innerHTML = html;
    try{ if (window.shortenChipLabels) window.shortenChipLabels(); }catch(e){}
  };

  // Tab switching (override / define)
  window.setGroup = function(g){
    var tabs = document.querySelectorAll('#partTabs .gtab');
    tabs.forEach(function(b){ b.classList.toggle('is-on', b.getAttribute('data-g')===g); });
    window.renderChips(g);
  };

  // Click chip -> sync to partFilter if it carries a part value
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (!part) return; // aggregated badges do nothing
    var sel = document.getElementById('partFilter');
    if (sel){
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === part){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);

  // Wire up tabs & initial render
  document.addEventListener('click', function(ev){
    var t = ev.target.closest && ev.target.closest('#partTabs .gtab');
    if (!t) return;
    var g = t.getAttribute('data-g') || 'wear';
    window.setGroup(g);
  }, false);

  // Render after init and on owned input changes
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    // keep current active tab if exist, else default to wear
    var on = document.querySelector('#partTabs .gtab.is-on');
    var g = on ? on.getAttribute('data-g') : 'wear';
    window.renderChips(g || 'wear');
  };

  document.addEventListener('input', function(ev){
    if (ev.target && ev.target.id === 'ownedInput'){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      window.renderChips(g || 'wear');
    }
  });

  // Safety: render on DOM ready as well (in case init wrapping fails)
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(function(){
      var on = document.querySelector('#partTabs .gtab.is-on');
      var g = on ? on.getAttribute('data-g') : 'wear';
      try{ window.renderChips(g || 'wear'); }catch(e){ console.warn(e); }
    }, 120);
  });
})();
</script>
<!-- === PATCH v2: add correct '특수' group rendering === -->
<script>
(function(){
  // Avoid duplicate application
  if (window.__specialPatchApplied) return;
  window.__specialPatchApplied = true;

  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(s=> s.trim())
      .filter(Boolean);
  }
  function normName(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }

  // Subcategories for '특수'
  var SPECIAL_SUBS = ["얼굴","가슴","문신","날개","꼬리","전경","배경","상단","하단","스킨"];

  function collectStats(){
    var items = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    // Build maps
    var totalsByPart = Object.create(null);
    var byName = Object.create(null);
    for (var it of items){
      var p = (it && it.part) || '';
      totalsByPart[p] = (totalsByPart[p]||0)+1;
      var key = (window.normOwnedName ? window.normOwnedName(it && it.name) : normName(it && it.name));
      if (key && !(key in byName)) byName[key] = it;
    }
    // Owned mapping -> count by part (same keying as totalsByPart)
    var ta = document.getElementById('ownedInput');
    var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    var ownedByPart = Object.create(null);
    for (var n of names){
      var it2 = byName[(window.normOwnedName ? window.normOwnedName(n) : normName(n))];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedByPart[pp] = (ownedByPart[pp]||0)+1;
    }
    return { totalsByPart, ownedByPart };
  }

  // helper: safe sum over all parts that include '특수' and specific sub label
  function sumForSpecial(label, map){
    var s = 0;
    if (!map) return 0;
    var keys = Object.keys(map);
    for (var k of keys){
      // match any of: '특수 - 얼굴', '장식 - 특수 - 얼굴', '특수 얼굴' 등
      if (k && k.indexOf('특수') !== -1 && k.indexOf(label) !== -1){
        s += map[k] || 0;
      }
    }
    return s;
  }

  // Re-open/override renderChips to support groupKey === 'special'
  var __origRenderChips = window.renderChips;
  window.renderChips = function(groupKey){
    if (groupKey !== 'special'){
      if (typeof __origRenderChips === 'function') return __origRenderChips(groupKey);
      return;
    }
    var row = document.getElementById('partChips'); if (!row) return;
    var S = collectStats();

    function chip(label){
      var o = sumForSpecial(label, S.ownedByPart);
      var t = sumForSpecial(label, S.totalsByPart);
      // chips in '특수' are *aggregates*; clicking sets partFilter to '특수'
      return '<span class="chip" data-part="특수"><span class="k">'+ label +'</span><span class="v">'+ o +'/'+ t +'</span></span>';
    }

    row.innerHTML = SPECIAL_SUBS.map(chip).join('');
    try{ if (window.shortenChipLabels) window.shortenChipLabels(); }catch(e){}
  };

  // Ensure clicking a chip in '특수' selects '특수' in partFilter
  document.addEventListener('click', function(ev){
    var chip = ev.target.closest && ev.target.closest('#partChips .chip');
    if (!chip) return;
    var part = chip.getAttribute('data-part') || '';
    if (part !== '특수') return;
    var sel = document.getElementById('partFilter');
    if (sel){
      // find an option whose value is exactly '특수'
      var found = false;
      for (var i=0;i<sel.options.length;i++){
        if (sel.options[i].value === '특수'){ sel.selectedIndex = i; found = true; break; }
      }
      if (!found) sel.value = '';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }, false);

  // When switching to '특수' tab, render it
  var __origSetGroup = window.setGroup;
  window.setGroup = function(g){
    if (typeof __origSetGroup === 'function') __origSetGroup(g);
    // After original toggles class, ensure render for special
    if (g === 'special'){
      try { window.renderChips('special'); } catch(e){ console.warn(e); }
    }
  };

  // Also render on init if '특수' is already active
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    var on = document.querySelector('#partTabs .gtab.is-on');
    var g = on ? on.getAttribute('data-g') : 'wear';
    if (g === 'special'){
      try { window.renderChips('special'); } catch(e){}
    }
  };
})();
</script>
<!-- === PATCH v3: keep '특수' sublabels (얼굴/가슴/...) from being relabeled === -->
<script>
(function(){
  // apply once
  if (window.__specialLabelGuardApplied) return;
  window.__specialLabelGuardApplied = true;

  // Wrap global shortener so it skips when special is active
  var __origShorten = window.shortenChipLabels;
  window.__skipShortenForSpecial = false;
  window.shortenChipLabels = function(){
    if (window.__skipShortenForSpecial) return; // do nothing while on '특수'
    if (typeof __origShorten === 'function') return __origShorten();
  };

  // Rewrap setGroup to flip the guard flag
  var __origSetGroup2 = window.setGroup;
  window.setGroup = function(g){
    window.__skipShortenForSpecial = (g === 'special');
    if (typeof __origSetGroup2 === 'function') __origSetGroup2(g);
  };

  // Force the current state at load
  document.addEventListener('DOMContentLoaded', function(){
    var on = document.querySelector('#partTabs .gtab.is-on');
    var g = on ? on.getAttribute('data-g') : 'wear';
    window.__skipShortenForSpecial = (g === 'special');
  });

  // Re-render '특수' chips with explicit sublabels and opt-out from shortener
  var __origRenderChips2 = window.renderChips;
  window.renderChips = function(groupKey){
    if (groupKey !== 'special'){
      if (typeof __origRenderChips2 === 'function') return __origRenderChips2(groupKey);
      return;
    }
    var row = document.getElementById('partChips'); if (!row) return;

    // we'll compute stats similarly to v2
    function parseOwned(text){
      return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
    }
    function normName(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
    var SPECIAL_SUBS = ["얼굴","가슴","문신","날개","꼬리","전경","배경","상단","하단","스킨"];

    function collectStats(){
      var items = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
      var totalsByPart = Object.create(null);
      var byName = Object.create(null);
      for (var i=0;i<items.length;i++){
        var it = items[i] || {};
        var p = it.part || '';
        totalsByPart[p] = (totalsByPart[p]||0)+1;
        var key = (window.normOwnedName ? window.normOwnedName(it.name) : normName(it.name));
        if (key && !(key in byName)) byName[key] = it;
      }
      var ta = document.getElementById('ownedInput');
      var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
      var ownedByPart = Object.create(null);
      for (var j=0;j<names.length;j++){
        var it2 = byName[(window.normOwnedName ? window.normOwnedName(names[j]) : normName(names[j]))];
        if (!it2) continue;
        var pp = it2.part || '';
        ownedByPart[pp] = (ownedByPart[pp]||0)+1;
      }
      return { totalsByPart, ownedByPart };
    }

    function sumForSpecial(label, map){
      var s = 0; if (!map) return 0;
      var keys = Object.keys(map);
      for (var i=0;i<keys.length;i++){
        var k = keys[i];
        if (k && k.indexOf('특수') !== -1 && k.indexOf(label) !== -1){
          s += map[k] || 0;
        }
      }
      return s;
    }

    var S = collectStats();

    var html = SPECIAL_SUBS.map(function(lbl){
      var o = sumForSpecial(lbl, S.ownedByPart);
      var t = sumForSpecial(lbl, S.totalsByPart);
      // data-special="1" is a marker for our guard; data-part left as '특수' so click filters to 특수
      return '<span class="chip" data-part="특수" data-special="1">'
           +   '<span class="k">'+ lbl +'</span>'
           +   '<span class="v">'+ o +'/'+ t +'</span>'
           + '</span>';
    }).join('');
    row.innerHTML = html;

    // do NOT call shortenChipLabels here; our guard is also on
  };
})();
</script>
<!-- === PATCH v4: Accessory chips show 팔찌(우)/팔찌(좌) as singles; remove aggregate '팔찌' === -->
<script>
(function(){
  if (window.__accSinglesPatchApplied) return;
  window.__accSinglesPatchApplied = true;

  // Define an override for renderChips('acc') only
  var __origRenderChips = window.renderChips;
  window.renderChips = function(groupKey){
    if (groupKey !== 'acc'){
      if (typeof __origRenderChips === 'function') return __origRenderChips(groupKey);
      return;
    }
    var row = document.getElementById('partChips'); if (!row) return;

    function parseOwned(text){
      return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
    }
    function normName(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }

    var ACC_SINGLES = [
      // 머리
      "장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식",
      // 귀
      "장식 - 귀",
      // 목
      "장식 - 목 - 목도리","장식 - 목 - 목걸이",
      // 손 (팔찌 우/좌, 장갑)
      "장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑",
      // 소품
      "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손",
      // 허리
      "장식 - 허리",
      // 특수 (세부는 '특수' 탭에서 집계하므로 여기서는 싱글 미포함)
    ];

    // Build stats by exact part string
    var items = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    var totals = Object.create(null);
    var byName = Object.create(null);
    for (var i=0;i<items.length;i++){
      var it = items[i] || {};
      var p = it.part || '';
      totals[p] = (totals[p]||0)+1;
      var key = (window.normOwnedName ? window.normOwnedName(it.name) : normName(it.name));
      if (key && !(key in byName)) byName[key] = it;
    }
    var ta = document.getElementById('ownedInput');
    var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    var ownedPer = Object.create(null);
    for (var j=0;j<names.length;j++){
      var it2 = byName[(window.normOwnedName ? window.normOwnedName(names[j]) : normName(names[j]))];
      if (!it2) continue;
      var pp = it2.part || '';
      ownedPer[pp] = (ownedPer[pp]||0)+1;
    }

    function chipHtml(label, partValue){
      var o = ownedPer[partValue] || 0;
      var t = totals[partValue] || 0;
      // data-part uses the exact part string so filtering can work (if select options support it)
      var lbl = label;
      try{
        if (lbl.indexOf('장식 - ')===0 && lbl.indexOf(' - ')!==-1){
          var segs = lbl.split(' - ');
          lbl = segs[segs.length-1];
        }
      }catch(e){}
      return '<span class="chip" data-part="'+ partValue.replace(/"/g,'&quot;') +'">'
           +   '<span class="k">'+ lbl +'</span>'
           +   '<span class="v">'+ o +'/'+ t +'</span>'
           + '</span>';
    }

    var html = ACC_SINGLES.map(function(p){ return chipHtml(p, p); }).join('');
    row.innerHTML = html;
    try{ if (window.shortenChipLabels && !window.__skipShortenForSpecial) window.shortenChipLabels(); }catch(e){}
  };
})();
</script>
<!-- === PATCH v5: Code-mode apply (부위+코드 → 이름 추가) === -->
<script>
(function(){
  if (window.__codeModePatchApplied) return;
  window.__codeModePatchApplied = true;

  const OWNED_KEY = window.OWNED_KEY || 'nikki_owned_names';

  function $(id){ return document.getElementById(id); }
  function parseCodes(txt){
    return String(txt||'')
      .split(/[\n\r,\s;]+/g)
      .map(s=> s.trim())
      .filter(Boolean)
      .map(s=> Number(s))
      .filter(n=> Number.isFinite(n));
  }
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }

  // Ensure an input next to part select exists
  function ensureCodeInlineUI(){
    const wrap = $('codeInlineControls');
    if (!wrap) return;
    if (!$('codeNumbersInline')){
      const inp = document.createElement('input');
      inp.type = 'text';
      inp.id = 'codeNumbersInline';
      inp.placeholder = '코드번호 입력 (예: 1, 2, 3)';
      inp.style.minWidth = '180px';
      wrap.insertBefore(inp, $('applyCodesBtnInline'));
    }
  }

  // Build a fast index: { "<part>#<code>": itemName }
  function buildCodeIndex(){
    const idx = Object.create(null);
    const arr = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    for (const it of arr){
      if (!it) continue;
      const part = it.part || '';
      const code = Number(it.code);
      const name = it.name || '';
      if (!part || !Number.isFinite(code) || !name) continue;
      const key = part + '#' + code;
      // keep first occurrence
      if (idx[key] == null) idx[key] = name;
    }
    return idx;
  }

  // Populate part select with parts existing in data
  function populatePartSelect(){
    const sel = $('codePartSelectInline');
    if (!sel) return;
    // If already filled, skip
    if (sel.options && sel.options.length > 0) return;
    const parts = new Set();
    const arr = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    for (const it of arr){
      if (it && it.part) parts.add(String(it.part));
    }
    const orderHint = ["헤어","원피스","아우터","상의","하의","양말","양말장식","신발","뷰티",
                       "장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식",
                       "장식 - 귀","장식 - 목 - 목도리","장식 - 목 - 목걸이",
                       "장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑",
                       "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손","장식 - 허리",
                       "특수","반딧불의 영혼"];
    const ordered = orderHint.filter(p=> parts.has(p)).concat([...parts].filter(p=> !orderHint.includes(p)));
    sel.innerHTML = ordered.map(p=> '<option value="'+ p.replace(/"/g,'&quot;') +'">'+ p +'</option>').join('');
  }

  // Read current owned names from textarea
  function getOwnedNames(){
    const ta = $('ownedInput');
    const text = ta ? ta.value : '';
    return String(text).split(/[\n\r]+/g).map(s=> s.trim()).filter(Boolean);
  }
  // Write owned names to textarea and persist
  function setOwnedNames(list){
    const ta = $('ownedInput');
    if (ta){
      ta.value = list.join('\n');
      ta.dispatchEvent(new Event('input', {bubbles:true}));
      try { localStorage.setItem(OWNED_KEY, ta.value); } catch(e){}
    }
    if (typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
    if (typeof window.renderPartBar === 'function') window.renderPartBar();
    if (typeof window.renderAll === 'function') window.renderAll();
  }

  // Handler for "코드 적용"
  function onApplyCodes(){
    const sel = $('codePartSelectInline');
    const inp = $('codeNumbersInline');
    const ta  = $('ownedInput');
    if (!sel || !ta){
      alert('초기화가 덜 되었어요. 페이지를 새로고침 해주세요.');
      return;
    }
    const part = sel.value || '';

    // Try the dedicated code input first; if empty, try textarea contents (code 모드일 때)
    const fromInline = parseCodes(inp ? inp.value : '');
    const fromTextarea = (document.querySelector('input[name="ownedMode"]:checked')?.value === 'code')
      ? parseCodes(ta.value)
      : [];

    const codes = (fromInline.length ? fromInline : fromTextarea);
    if (!codes.length){
      alert('코드 입력이 비어있습니다. 코드번호를 입력하거나 붙여넣어 주세요.');
      return;
    }

    const idx = buildCodeIndex();
    const namesToAdd = [];
    for (const c of codes){
      const key = part + '#' + c;
      const nm = idx[key];
      if (nm) namesToAdd.push(nm);
    }

    if (!namesToAdd.length){
      alert('해당 부위에 일치하는 코드가 없습니다.');
      return;
    }

    // Merge into owned list (de-duplicate, preserve existing)
    const owned = getOwnedNames();
    const set = new Set(owned.map(n=> norm(n)));
    for (const nm of namesToAdd){
      const k = norm(nm);
      if (!set.has(k)){
        owned.push(nm);
        set.add(k);
      }
    }
    setOwnedNames(owned);

    // Small toast if available
    const t = document.getElementById('toast');
    if (t){ t.textContent = '코드 적용 완료'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1000); }
  }

  function bind(){
    ensureCodeInlineUI();
    populatePartSelect();
    const btn = $('applyCodesBtnInline');
    if (btn && !btn.__bindApplied){
      btn.__bindApplied = true;
      btn.addEventListener('click', onApplyCodes);
    }
    // Toggle controls by radio
    document.addEventListener('change', function(ev){
      if (ev.target && ev.target.name === 'ownedMode'){
        const mode = ev.target.value;
        const ctrl = $('codeInlineControls');
        if (ctrl) ctrl.style.display = (mode === 'code') ? 'flex' : 'none';
      }
    });
    // Initialize visibility according to current radio selection
    const cur = document.querySelector('input[name="ownedMode"]:checked');
    const ctrl = $('codeInlineControls');
    if (ctrl) ctrl.style.display = (cur && cur.value === 'code') ? 'flex' : 'none';
  }

  // Bind now and also after init
  document.addEventListener('DOMContentLoaded', function(){
    try { bind(); } catch(e){ console.warn(e); }
    // If items load async via iframe, try again later
    setTimeout(function(){ try { bind(); } catch(e){} }, 200);
    setTimeout(function(){ try { bind(); } catch(e){} }, 600);
  });

  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    try { bind(); } catch(e){}
  };
})();
</script>
<!-- === PATCH v6: remove legacy click handler on '코드 적용' button === -->
<script>
(function(){
  if (window.__codeApplyDebouncePatch) return;
  window.__codeApplyDebouncePatch = true;

  function $(id){ return document.getElementById(id); }

  // Replace the button with a fresh clone to strip any earlier listeners/onclick
  function sanitizeApplyButton(){
    var btn = $('applyCodesBtnInline');
    if (!btn || btn.__sanitized) return btn;
    var clone = btn.cloneNode(true);          // copy attributes/text
    clone.removeAttribute('onclick');         // drop inline onclick if any
    clone.__sanitized = true;
    btn.parentNode.replaceChild(clone, btn);
    return clone;
  }

  // Re-bind our handler exclusively (uses the one from v5 if present)
  function rebind(){
    var btn = sanitizeApplyButton();
    if (!btn) return;
    // Find our v5 handler (window.onApplyCodes) or define a safe fallback that triggers click event for v5
    var handler = (window.onApplyCodes) ? window.onApplyCodes : function(){
      try {
        // If v5 attached to btn earlier, dispatching a fresh event won't call it;
        // but we expect v5 exposed onApplyCodes globally.
        console.warn('onApplyCodes not found; no-op');
      } catch(e){}
    };
    // Avoid multiple bindings
    btn.replaceWith(btn.cloneNode(true));
    btn = $('applyCodesBtnInline');
    btn.removeAttribute('onclick');
    btn.__sanitized = true;
    btn.addEventListener('click', function(ev){
      ev.preventDefault();
      ev.stopPropagation();
      try { handler(); } catch(e){ console.error(e); }
      return false;
    }, { once: false });
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(rebind, 0);
    setTimeout(rebind, 150);
    setTimeout(rebind, 500);
  });

  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    rebind();
  };
})();
</script>
<!-- === PATCH v7: Copy buttons for names === -->
<script>
(function(){
  if (window.__copyButtonsPatchApplied) return;
  window.__copyButtonsPatchApplied = true;

  function $(id){ return document.getElementById(id); }
  function showToast(msg){
    var t = $('toast');
    if (!t) return;
    t.textContent = msg || '복사됨';
    t.classList.add('show');
    setTimeout(()=> t.classList.remove('show'), 1000);
  }
  async function copyText(txt){
    try{
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(txt);
      }else{
        var ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      return true;
    }catch(e){
      console.warn('copy failed', e);
      return false;
    }
  }

  // Track last added names (from 코드 적용)
  window.__lastAddedNames = window.__lastAddedNames || [];

  // Hook into existing onApplyCodes to capture last added names
  var __origOnApplyCodes = window.onApplyCodes;
  window.onApplyCodes = function(){
    // call original
    var before = (function(){
      var ta = $('ownedInput');
      return ta ? (ta.value || '') : '';
    })();
    if (typeof __origOnApplyCodes === 'function') __origOnApplyCodes();
    // compute delta
    try {
      var after = (function(){
        var ta = $('ownedInput');
        return ta ? (ta.value || '') : '';
      })();
      var setBefore = new Set(before.split(/[\n\r]+/g).map(s=> s.trim()).filter(Boolean));
      var added = after.split(/[\n\r]+/g).map(s=> s.trim()).filter(Boolean).filter(n=> !setBefore.has(n));
      window.__lastAddedNames = added;
    } catch(e){ window.__lastAddedNames = []; }
  };

  function ensureButtons(){
    var row = document.querySelector('.owned-buttons');
    if (!row) return;
    if (!$('#copyAllNames')){
      var b1 = document.createElement('button');
      b1.id = 'copyAllNames';
      b1.type = 'button';
      b1.textContent = '이름 복사';
      row.appendChild(b1);
    }
    if (!$('#copyRecentNames')){
      var b2 = document.createElement('button');
      b2.id = 'copyRecentNames';
      b2.type = 'button';
      b2.textContent = '최근 추가 이름 복사';
      row.appendChild(b2);
    }
  }

  function bind(){
    ensureButtons();
    var btnAll = $('#copyAllNames');
    var btnRecent = $('#copyRecentNames');
    var ta = $('#ownedInput');

    if (btnAll && !btnAll.__bind){
      btnAll.__bind = true;
      btnAll.addEventListener('click', async function(){
        if (!ta) return;
        // copy selected, else all
        var sel = '';
        try { sel = ta.value.substring(ta.selectionStart, ta.selectionEnd); } catch(e){ sel = ''; }
        var txt = sel && sel.trim() ? sel : ta.value;
        txt = String(txt || '').trim();
        if (!txt){ showToast('복사할 이름이 없어요'); return; }
        var ok = await copyText(txt);
        showToast(ok ? '복사됨' : '복사 실패');
      });
    }

    if (btnRecent && !btnRecent.__bind){
      btnRecent.__bind = true;
      btnRecent.addEventListener('click', async function(){
        var arr = Array.isArray(window.__lastAddedNames) ? window.__lastAddedNames : [];
        var txt = arr.join('\\n').trim();
        if (!txt){ showToast('최근 추가된 이름이 없어요'); return; }
        var ok = await copyText(txt);
        showToast(ok ? '복사됨' : '복사 실패');
      });
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(bind, 0);
    setTimeout(bind, 200);
  });

  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    bind();
  };
})();
</script>
<!-- === PATCH v8: Fix item-card '이름 복사' button === -->
<script>
(function(){
  if (window.__cardCopyPatchApplied) return;
  window.__cardCopyPatchApplied = true;

  function showToast(msg){
    var t = document.getElementById('toast');
    if (!t) return;
    t.textContent = msg || '복사됨';
    t.classList.add('show');
    setTimeout(()=> t.classList.remove('show'), 900);
  }
  async function copyText(txt){
    try{
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(txt);
      } else {
        var ta = document.createElement('textarea');
        ta.value = txt;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      return true;
    }catch(e){ console.warn(e); return false; }
  }

  function getItemNameFromCard(card){
    if (!card) return '';
    // 1) explicit data-name
    if (card.dataset && card.dataset.name) return String(card.dataset.name).trim();
    // 2) common name nodes
    var selList = [
      '[data-field="name"]',
      '.item-name',
      '.card h3 .title',
      '.card h3 .name',
      '.card h3',
      '.title',
      '.name'
    ];
    for (var i=0;i<selList.length;i++){
      var el = card.querySelector(selList[i]);
      if (el && el.textContent && el.textContent.trim()){
        return el.textContent.trim();
      }
    }
    // 3) aria/alt fallback
    var a = card.getAttribute && (card.getAttribute('aria-label') || card.getAttribute('title'));
    if (a) return String(a).trim();
    return '';
  }

  // Delegate click for any "이름 복사" button inside a card
  document.addEventListener('click', async function(ev){
    var btn = ev.target.closest && ev.target.closest('.card .copy-btn, .card button');
    if (!btn) return;
    // Require visible label to contain '이름 복사'
    var label = (btn.textContent || '').trim();
    if (label !== '이름 복사') return;

    var card = btn.closest('.card') || btn.closest('[data-item]') || btn.parentElement;
    var name = getItemNameFromCard(card);
    if (!name){
      showToast('이름을 찾지 못했어요');
      return;
    }
    var ok = await copyText(name);
    showToast(ok ? '복사됨' : '복사 실패');
    ev.preventDefault();
    ev.stopPropagation();
    return false;
  }, false);
})();
</script>
<!-- === PATCH v9: Remove extra copy buttons from owned area === -->
<script>
(function(){
  if (window.__removeExtraCopiesOnce) return;
  window.__removeExtraCopiesOnce = true;

  function removeExtra(){
    var ids = ['copyAllNames','copyRecentNames'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if (el && el.parentNode) el.parentNode.removeChild(el);
    });
    // If earlier script tries to add again, neutralize its helper
    try { window.ensureButtons = function(){}; } catch(e){}
  }

  document.addEventListener('DOMContentLoaded', function(){
    removeExtra();
    setTimeout(removeExtra, 100);
    setTimeout(removeExtra, 400);
  });

  // Also after init
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    removeExtra();
  };
})();
</script>
<!-- === PATCH v10: Copy only pure item name (exclude button text) === -->
<script>
(function(){
  if (window.__pureNameCopyPatchApplied) return;
  window.__pureNameCopyPatchApplied = true;

  // Override the helper only for card copy
  window.__getPureText = function(el){
    if (!el) return '';
    var out = '';
    var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
    var node;
    while ((node = walker.nextNode())){
      var t = (node.nodeValue || '').replace(/\s+/g, ' ').trim();
      if (t) out += (out ? ' ' : '') + t;
    }
    return out;
  };

  // Re-wrap the delegated handler defined earlier in v8 by overriding getItemNameFromCard if available
  var prevGetter = window.getItemNameFromCard;
  window.getItemNameFromCard = function(card){
    if (!card){
      return (typeof prevGetter === 'function') ? prevGetter(card) : '';
    }
    // Prefer explicit fields
    var selList = [
      '[data-field="name"]',
      '.item-name',
      '.title .name',
      '.name'
    ];
    for (var i=0;i<selList.length;i++){
      var el = card.querySelector(selList[i]);
      if (el){
        var txt = window.__getPureText(el);
        if (txt) return txt;
      }
    }
    // Fallback to h3 but only text nodes (exclude buttons/icons)
    var h3 = card.querySelector('h3');
    if (h3){
      var txt = window.__getPureText(h3);
      if (txt) return txt.replace(/\b이름\s*복사\b/g,'').replace(/\s+/g,' ').trim();
    }
    // Data attribute
    if (card.dataset && card.dataset.name){
      return String(card.dataset.name).trim();
    }
    // Last resort: previous getter then strip
    var raw = (typeof prevGetter === 'function') ? prevGetter(card) : '';
    return String(raw||'').replace(/\b이름\s*복사\b/g,'').replace(/\s+/g,' ').trim();
  };
})();
</script>
<!-- === PATCH v11: Pure name copy by removing button nodes === -->
<script>
(function(){
  if (window.__pureNameCopyPatch2Applied) return;
  window.__pureNameCopyPatch2Applied = true;

  function stripControlsAndGetText(node){
    if (!node) return '';
    // Work on a clone so we don't mutate UI
    var clone = node.cloneNode(true);
    // Remove common control elements
    var selectors = ['button', '.copy-btn', '[role="button"]', 'a', 'svg', 'i'];
    selectors.forEach(function(sel){
      var list = clone.querySelectorAll(sel);
      for (var i=0;i<list.length;i++){ list[i].remove(); }
    });
    var txt = (clone.textContent || '').replace(/\s+/g,' ').trim();
    return txt;
  }

  // Override getItemNameFromCard again with stronger logic
  window.getItemNameFromCard = function(card, clickedBtn){
    if (!card) return '';
    // Try explicit name field first
    var selList = ['[data-field="name"]','.item-name','.title .name','.name'];
    for (var i=0;i<selList.length;i++){
      var el = card.querySelector(selList[i]);
      if (el){
        var t = stripControlsAndGetText(el);
        if (t) return t;
      }
    }
    // Fallback to h3
    var h3 = card.querySelector('h3');
    if (h3){
      var t = stripControlsAndGetText(h3);
      if (t) return t;
    }
    // Data attribute
    if (card.dataset && card.dataset.name){
      return String(card.dataset.name).trim();
    }
    // Last resort: entire card text minus the button text
    var whole = stripControlsAndGetText(card);
    if (clickedBtn){
      var btnText = (clickedBtn.textContent || '').replace(/\s+/g,' ').trim();
      if (btnText){
        whole = whole.replace(btnText, '').replace(/\s+/g,' ').trim();
      }
    }
    // Also strip any residual keywords just in case
    return whole.replace(/이름\s*복사/gi,'').replace(/\s+/g,' ').trim();
  };

  // Rebind the delegated click so we pass the clicked button to the getter
  document.addEventListener('click', async function(ev){
    var btn = ev.target.closest && ev.target.closest('.card .copy-btn, .card button');
    if (!btn) return;
    var label = (btn.textContent || '').replace(/\s+/g,' ').trim();
    if (label !== '이름 복사') return;
    var card = btn.closest('.card') || btn.closest('[data-item]') || btn.parentElement;
    var name = window.getItemNameFromCard(card, btn);
    if (!name){
      // try one more time: read card dataset
      name = (card && card.dataset && card.dataset.name) ? String(card.dataset.name).trim() : '';
    }
    try {
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(name);
      } else {
        var ta = document.createElement('textarea');
        ta.value = name;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      var t = document.getElementById('toast'); if (t){ t.textContent = '복사됨'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 900); }
    } catch(e){
      var t2 = document.getElementById('toast'); if (t2){ t2.textContent = '복사 실패'; t2.classList.add('show'); setTimeout(()=> t2.classList.remove('show'), 900); }
    }
    ev.preventDefault();
    ev.stopPropagation();
    return false;
  }, true); // capture to win against other handlers
})();
</script>
<!-- === PATCH v12: Sanitize card buttons and force pure-name copy === -->
<script>
(function(){
  if (window.__cardCopyFinalPatch) return;
  window.__cardCopyFinalPatch = true;

  function stripControlsAndGetText(node){
    if (!node) return '';
    var clone = node.cloneNode(true);
    var selectors = ['button','.copy-btn','[role="button"]','a','svg','i'];
    selectors.forEach(function(sel){
      var list = clone.querySelectorAll(sel);
      for (var i=0; i<list.length; i++){ list[i].remove(); }
    });
    return (clone.textContent || '').replace(/\s+/g,' ').replace(/이름\s*복사|이름복사/gi,'').trim();
  }

  function setCardDataName(card){
    if (!card) return '';
    var name = '';
    var prefer = card.querySelector('[data-field="name"], .item-name, .title .name, .name');
    if (prefer) name = stripControlsAndGetText(prefer);
    if (!name){
      var h3 = card.querySelector('h3');
      if (h3) name = stripControlsAndGetText(h3);
    }
    if (!name && card.dataset && card.dataset.name) name = String(card.dataset.name).trim();
    if (card && name){
      try { card.dataset.name = name; } catch(e){}
    }
    return name;
  }

  // Sanitize existing buttons
  function sanitizeCardButtons(){
    var btns = Array.from(document.querySelectorAll('.card button, .card .copy-btn'));
    btns.forEach(function(b){
      var label = (b.textContent || '').replace(/\s+/g,' ').trim();
      if (label !== '이름 복사') return;
      if (b.__sanitized) return;
      var clone = b.cloneNode(true);
      clone.removeAttribute('onclick');
      clone.__sanitized = true;
      b.parentNode.replaceChild(clone, b);
    });
  }

  // Attach our single handler (capture) that kills bubbling/clicks
  function bindCardCopy(){
    document.addEventListener('click', async function(ev){
      var btn = ev.target.closest && ev.target.closest('.card button, .card .copy-btn');
      if (!btn) return;
      var label = (btn.textContent || '').replace(/\s+/g,' ').trim();
      if (label !== '이름 복사') return;
      ev.preventDefault();
      ev.stopPropagation();
      if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();

      var card = btn.closest('.card') || btn.closest('[data-item]') || btn.parentElement;
      var name = setCardDataName(card);
      if (!name && card && card.dataset) name = card.dataset.name || '';

      try{
        if (navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(name);
        } else {
          var ta = document.createElement('textarea');
          ta.value = name;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
        var t = document.getElementById('toast'); if (t){ t.textContent = '복사됨'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 900); }
      }catch(e){
        var t2 = document.getElementById('toast'); if (t2){ t2.textContent = '복사 실패'; t2.classList.add('show'); setTimeout(()=> t2.classList.remove('show'), 900); }
      }
      return false;
    }, true); // capture
  }

  function afterRenderFix(){
    try { sanitizeCardButtons(); } catch(e){}
    // set data-name on visible cards
    var cards = Array.from(document.querySelectorAll('.card, [data-item]'));
    cards.forEach(setCardDataName);
  }

  // Run now and after future renders
  document.addEventListener('DOMContentLoaded', function(){
    afterRenderFix();
    setTimeout(afterRenderFix, 150);
    setTimeout(afterRenderFix, 600);
  });

  if (typeof window.renderAll === 'function'){
    var orig = window.renderAll;
    window.renderAll = function(){
      var r = orig.apply(this, arguments);
      setTimeout(afterRenderFix, 0);
      return r;
    };
  }

  bindCardCopy();
})();
</script>
<!-- === PATCH v13: Stage main/sub weights UI & logic === -->
<script>
(function(){
  if (window.__stageWeightsUIPatchApplied) return;
  window.__stageWeightsUIPatchApplied = true;

  const STYLE_LABELS = [
    ["flair","화려"],["simple","심플"],["elegant","우아"],["lively","활발"],["mature","성숙"],
    ["cute","큐티"],["sexy","섹시"],["pure","청순"],["cool","청량"],["warm","따뜻"]
  ];
  const KEY = 'nikki_stage_style_weights_overrides';

  function $(id){ return document.getElementById(id); }
  function byId(id){ return document.getElementById(id); }
  function toNum(v){ const n = Number(v); return Number.isFinite(n)? n : 0; }

  function loadMap(){
    try{ return JSON.parse(localStorage.getItem(KEY)||'{}') || {}; }catch(e){ return {}; }
  }
  function saveMap(m){
    try{ localStorage.setItem(KEY, JSON.stringify(m||{})); }catch(e){}
  }
  function getStageId(stage){
    if (!stage) return '';
    return String(stage.stage_id || stage.id || stage.name || '').trim();
  }

  function ensureUI(){
    const ctrlRow = document.querySelector('#controls .filter-row');
    if (!ctrlRow) return;

    // Host container (once)
    if (!byId('stageWeightBox')){
      const wrap = document.createElement('div');
      wrap.id = 'stageWeightBox';
      wrap.style.display = 'inline-flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '6px';
      wrap.style.marginLeft = '8px';
      wrap.innerHTML = ''
        + '<label style="font-size:13px;">가중치</label>'
        + '<select id="mainStyleSel" title="메인 스타일"></select>'
        + '<input id="mainWeightInp" type="number" step="0.01" value="1.33" style="width:64px" title="메인 가중치">'
        + '<span style="opacity:.7">/</span>'
        + '<select id="subStyleSel" title="서브 스타일"></select>'
        + '<input id="subWeightInp" type="number" step="0.01" value="1.00" style="width:64px" title="서브 가중치">'
        + '<button id="applyStageWeightsBtn" class="gtab" type="button">적용</button>';
      ctrlRow.appendChild(wrap);

      // Fill dropdowns
      const fill = (sel)=>{
        sel.innerHTML = '<option value="">(없음)</option>'
          + STYLE_LABELS.map(([k,lab])=> '<option value="'+k+'">'+lab+'</option>').join('');
      };
      fill(byId('mainStyleSel')); fill(byId('subStyleSel'));
    }
  }

  function applyToStage(stage, mainKey, mainW, subKey, subW){
    if (!stage) return;
    // Build weights object
    const weights = {};
    if (mainKey) weights[mainKey] = toNum(mainW || 0);
    if (subKey)  weights[subKey]  = toNum(subW  || 0);
    // Persist per stage
    const id = getStageId(stage);
    if (id){
      const m = loadMap();
      m[id] = { mainKey, mainW: toNum(mainW||0), subKey, subW: toNum(subW||0) };
      saveMap(m);
    }
    // Apply live via helper if available
    try{
      if (window.__NIKKI_PATCH__ && typeof window.__NIKKI_PATCH__.setStageStyleWeights === 'function'){
        window.__NIKKI_PATCH__.setStageStyleWeights(stage, weights);
      }else{
        // Fallback: attach directly
        stage.style_weights = Object.assign({}, stage.style_weights||{}, weights);
      }
    }catch(e){}
  }

  function syncUIFromStage(stage){
    const id = getStageId(stage);
    const saved = loadMap()[id] || null;

    const mainSel = byId('mainStyleSel');
    const subSel  = byId('subStyleSel');
    const mainInp = byId('mainWeightInp');
    const subInp  = byId('subWeightInp');
    if (!mainSel || !subSel || !mainInp || !subInp) return;

    if (saved){
      mainSel.value = saved.mainKey || '';
      subSel.value  = saved.subKey  || '';
      mainInp.value = (saved.mainW != null ? saved.mainW : 1.33);
      subInp.value  = (saved.subW  != null ? saved.subW  : 1.00);
      // Re-apply to stage object to be safe
      applyToStage(stage, saved.mainKey, saved.mainW, saved.subKey, saved.subW);
    }else{
      // Try to infer from existing style_weights on stage
      let mk = '', sk = '', mv = 1.33, sv = 1.00;
      if (stage && stage.style_weights){
        // pick top-2 weights
        const entries = Object.entries(stage.style_weights).filter(([k,v])=> toNum(v)>0).sort((a,b)=>toNum(b[1])-toNum(a[1]));
        if (entries[0]) { mk = entries[0][0]; mv = toNum(entries[0][1]) || 1.33; }
        if (entries[1]) { sk = entries[1][0]; sv = toNum(entries[1][1]) || 1.00; }
      }
      mainSel.value = mk;
      subSel.value  = sk;
      mainInp.value = mv;
      subInp.value  = sv;
    }
  }

  function getCurrentStage(){
    const sel = byId('stageSelect');
    const id = sel && sel.value;
    if (!id) return null;
    const arr = Array.isArray(window.stages) ? window.stages : [];
    return arr.find(s => String(s.stage_id)===String(id) || String(s.id)===String(id) || String(s.name)===String(id)) || null;
  }

  function bind(){
    ensureUI();
    const btn = byId('applyStageWeightsBtn');
    if (btn && !btn.__bind){
      btn.__bind = true;
      btn.addEventListener('click', function(){
        const st = getCurrentStage(); if (!st) return;
        const mk = byId('mainStyleSel').value;
        const sk = byId('subStyleSel').value;
        const mw = toNum(byId('mainWeightInp').value);
        const sw = toNum(byId('subWeightInp').value);
        applyToStage(st, mk, mw, sk, sw);
        // Re-render
        try{ if (typeof window.renderAll === 'function') window.renderAll(); }catch(e){}
        const t = document.getElementById('toast'); if (t){ t.textContent='가중치 적용'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 900); }
      });
    }

    // Stage change -> refresh UI and apply saved
    const sel = byId('stageSelect');
    if (sel && !sel.__bindWeights){
      sel.__bindWeights = true;
      sel.addEventListener('change', function(){
        const st = getCurrentStage();
        if (st){
          syncUIFromStage(st);
          // ensure saved overrides applied
          const id = getStageId(st);
          const saved = loadMap()[id] || null;
          if (saved){
            applyToStage(st, saved.mainKey, saved.mainW, saved.subKey, saved.subW);
            try{ if (typeof window.renderAll === 'function') window.renderAll(); }catch(e){}
          }
        }
      });
    }

    // First sync once data exists
    const st = getCurrentStage();
    if (st) syncUIFromStage(st);
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(bind, 0);
    setTimeout(bind, 200);
    setTimeout(bind, 600);
  });

  // Also hook init
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    bind();
  };
})();
</script>
<!-- === PATCH v14: Remove weight box UI; auto-detect per-stage weights === -->
<script>
(function(){
  if (window.__autoStageWeightPatchApplied) return;
  window.__autoStageWeightPatchApplied = true;

  // 1) Remove any previously added weight UI and prevent future creation
  function removeWeightUI(){
    var box = document.getElementById('stageWeightBox');
    if (box && box.parentNode) box.parentNode.removeChild(box);
    // neuter any creators from prior patches
    try {
      window.__stageWeightsUIPatchApplied = true; // trick v13 to think it's already applied
    } catch(e){}
  }

  // 2) Map Korean/English style labels to internal keys used by scorer
  var STYLE_MAP = {
    "화려":"flair","심플":"simple","우아":"elegant","활발":"lively","성숙":"mature",
    "큐티":"cute","섹시":"sexy","청순":"pure","청량":"cool","따뜻":"warm",
    "flair":"flair","simple":"simple","elegant":"elegant","lively":"lively","mature":"mature",
    "cute":"cute","sexy":"sexy","pure":"pure","cool":"cool","warm":"warm"
  };
  function normKey(s){ return (s||'').toString().trim(); }
  function toNum(v){ var n=Number(v); return Number.isFinite(n)?n:0; }

  function getCurrentStage(){
    var sel = document.getElementById('stageSelect');
    var id = sel && sel.value;
    if (!id) return null;
    var arr = Array.isArray(window.stages) ? window.stages : [];
    for (var i=0;i<arr.length;i++){
      var s = arr[i];
      if (String(s.stage_id)===String(id) || String(s.id)===String(id) || String(s.name)===String(id)) return s;
    }
    return null;
  }

  // 3) Extract weights from a stage object heuristically
  function detectWeights(stage){
    if (!stage) return null;

    // A) If explicit weights object exists
    var obj = stage.style_weights || stage.weights || stage.weight_map;
    if (obj && typeof obj === 'object'){
      // Normalize keys
      var out = {};
      Object.keys(obj).forEach(function(k){
        var mapped = STYLE_MAP[k] || STYLE_MAP[k.replace(/\s+/g,'')] || k;
        var v = toNum(obj[k]);
        if (v>0) out[mapped] = v;
      });
      if (Object.keys(out).length) return out;
    }

    // B) main/sub fields + weights
    var mainLabel = stage.main || stage.main_style || stage.mainStyle || stage.primary || stage.primary_style;
    var subLabel  = stage.sub  || stage.sub_style  || stage.subStyle  || stage.secondary || stage.secondary_style;
    var mainW = stage.weight_main || stage.main_weight || stage.mainWeight || stage.weightMain || stage.weight1;
    var subW  = stage.weight_sub  || stage.sub_weight  || stage.subWeight  || stage.weightSub  || stage.weight2;

    var out2 = {};
    if (mainLabel && mainW != null){
      var mk = STYLE_MAP[normKey(mainLabel)] || null;
      if (mk) out2[mk] = toNum(mainW);
    }
    if (subLabel && subW != null){
      var sk = STYLE_MAP[normKey(subLabel)] || null;
      if (sk) out2[sk] = toNum(subW);
    }
    if (Object.keys(out2).length) return out2;

    // C) If stage lists ranked attributes like: stage.main="심플", stage.sub="청순" without weight -> use defaults (1.33/1.0)
    if (mainLabel || subLabel){
      var o3 = {};
      if (mainLabel){ var mk2 = STYLE_MAP[normKey(mainLabel)]; if (mk2) o3[mk2]=1.33; }
      if (subLabel){  var sk2 = STYLE_MAP[normKey(subLabel)];  if (sk2) o3[sk2]=1.00; }
      if (Object.keys(o3).length) return o3;
    }

    return null;
  }

  // 4) Apply detected weights to stage so existing scorer picks it up
  function applyStageWeights(stage){
    if (!stage) return;
    var w = detectWeights(stage);
    if (!w) return;

    try{
      if (window.__NIKKI_PATCH__ && typeof window.__NIKKI_PATCH__.setStageStyleWeights === 'function'){
        window.__NIKKI_PATCH__.setStageStyleWeights(stage, w);
      } else {
        stage.style_weights = Object.assign({}, stage.style_weights||{}, w);
      }
    }catch(e){}
  }

  function onStageChanged(){
    removeWeightUI();
    var st = getCurrentStage();
    if (st){ applyStageWeights(st); }
    try{ if (typeof window.renderAll === 'function') window.renderAll(); }catch(e){}
  }

  // Bind stage change
  document.addEventListener('DOMContentLoaded', function(){
    removeWeightUI();
    // initial
    setTimeout(onStageChanged, 0);
    setTimeout(onStageChanged, 200);
    setTimeout(onStageChanged, 600);
    var sel = document.getElementById('stageSelect');
    if (sel && !sel.__autoStageWeightsBound){
      sel.__autoStageWeightsBound = true;
      sel.addEventListener('change', onStageChanged);
    }
  });

  // Also hook init
  var __origInit = window.init;
  window.init = function(){
    if (typeof __origInit === 'function') __origInit();
    onStageChanged();
  };
})();
</script>
<!-- === PATCH v15: stage-aware recalc + score scaling === -->
<script>
(function(){
  if (window.__scoreScalePatchApplied) return;
  window.__scoreScalePatchApplied = true;

  var SCALE = 60; // tune to target SSS ~= 3200

  // 1) Wrap scoreItemForStage to apply scaling
  (function(){
    var orig = window.scoreItemForStage;
    window.__ORIG_scoreItemForStage = orig;
    window.scoreItemForStage = function(item, stage){
      try{
        var base = (typeof orig === 'function') ? orig(item, stage) : 0;
        return base * SCALE;
      }catch(e){ return 0; }
    };
  })();

  // 2) Make renderAll always trigger a fresh render (scores are recomputed in render())
  (function(){
    var origAll = window.renderAll;
    var origRender = window.render;
    window.renderAll = function(){
      // call original if exists
      if (typeof origAll === 'function') { try{ origAll(); }catch(e){} }
      // then force a single render pass (render() computes scores via scoreItemForStage)
      if (typeof origRender === 'function') { try{ origRender(); }catch(e){} }
    };
  })();

  // 3) Also when stage changes, re-render after weights auto-apply (safety)
  document.addEventListener('change', function(ev){
    var sel = ev.target && ev.target.id === 'stageSelect';
    if (!sel) return;
    setTimeout(function(){
      try{ if (typeof window.renderAll === 'function') window.renderAll(); }catch(e){}
    }, 30);
  }, true);
})();
</script>
<!-- === PATCH v16: grade-offset additive scoring === -->
<script>
(function(){
  if (window.__gradeOffsetPatchApplied) return;
  window.__gradeOffsetPatchApplied = true;

  // Offsets table (additive)
  var GRADE_OFFSET = {
    "SSS": 3200,
    "SS": 2612.7,
    "S": 2089.35,
    "A": 1690.65,
    "B": 1309.8,
    "C": 817.5
  };

  function detectGrade(item){
    var g = null;
    if (item){
      g = item.grade || item.rank || item.rating || item.tier || item.level;
      if (!g && item.Grade) g = item.Grade;
      if (!g && item.Rank) g = item.Rank;
      if (!g && item.RATING) g = item.RATING;
    }
    g = (g==null ? '' : String(g)).toUpperCase().replace(/\s+/g,'');
    if (GRADE_OFFSET.hasOwnProperty(g)) return g;
    // fallback: nothing → no offset
    return '';
  }

  // Build a *clean* base scorer without the v15 scaling.
  // If v15 saved the original scorer, prefer that.
  var BASE = (typeof window.__ORIG_scoreItemForStage === 'function')
               ? window.__ORIG_scoreItemForStage
               : (typeof window.scoreItemForStage === 'function' ? window.scoreItemForStage : function(){ return 0; });

  window.scoreItemForStage = function(item, stage){
    var base = 0;
    try { base = BASE(item, stage) || 0; } catch(e){ base = 0; }
    var g = detectGrade(item);
    var add = GRADE_OFFSET[g] || 0;
    return base + add;
  };

  // Make sure a render happens so new formula shows up
  setTimeout(function(){ try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){} }, 20);
})();
</script>
<!-- === PATCH v17: RAW numeric attribute scoring + stage weights + grade offsets === -->
<script>
(function(){
  if (window.__rawAttrScoringPatchApplied) return;
  window.__rawAttrScoringPatchApplied = true;

  // Map style name variants -> canonical key
  var STYLE_CANON = {
    "화려":"flair","심플":"simple","우아":"elegant","활발":"lively","성숙":"mature",
    "큐티":"cute","섹시":"sexy","청순":"pure","청량":"cool","따뜻":"warm",
    "flair":"flair","simple":"simple","elegant":"elegant","lively":"lively","mature":"mature",
    "cute":"cute","sexy":"sexy","pure":"pure","cool":"cool","warm":"warm"
  };

  // For each canonical style, define candidate field names to probe on item
  var FIELD_CANDIDATES = {
    flair:   ["화려","flair","Flair","FLAIR","flair_points","flairPoint","flairScore","flair_score"],
    simple:  ["심플","simple","Simple","SIMPLE","simple_points","simplePoint","simpleScore","simple_score"],
    elegant: ["우아","elegant","Elegant","ELEGANT","elegant_points","elegantPoint","elegantScore","elegant_score"],
    lively:  ["활발","lively","Lively","LIVELY","lively_points","livelyPoint","livelyScore","lively_score"],
    mature:    ["성숙","mature","Chic","CHIC","chic_points","chicPoint","chicScore","chic_score"],
    cute:    ["큐티","cute","Cute","CUTE","cute_points","cutePoint","cuteScore","cute_score"],
    sexy:    ["섹시","sexy","Sexy","SEXY","sexy_points","sexyPoint","sexyScore","sexy_score"],
    pure:    ["청순","pure","Pure","PURE","pure_points","purePoint","pureScore","pure_score"],
    cool:    ["청량","cool","Cool","COOL","cool_points","coolPoint","coolScore","cool_score"],
    warm:    ["따뜻","warm","Warm","WARM","warm_points","warmPoint","warmScore","warm_score"]
  };

  // Grade offsets (from v16)
  var GRADE_OFFSET = {
    "SSS": 3200,
    "SS": 2612.7,
    "S": 2089.35,
    "A": 1690.65,
    "B": 1309.8,
    "C": 817.5
  };

  function toNum(v){
    var n = Number(v);
    return Number.isFinite(n) ? n : NaN;
  }
  function detectNumericAttr(item, canon){
    var names = FIELD_CANDIDATES[canon] || [];
    for (var i=0;i<names.length;i++){
      var k = names[i];
      if (item != null && Object.prototype.hasOwnProperty.call(item, k)){
        var val = item[k];
        var num = toNum(val);
        if (Number.isFinite(num)) return num;
        // sometimes string like "2,345" -> parse
        if (typeof val === 'string'){
          var s = val.replace(/[, ]+/g,'').trim();
          var n2 = Number(s);
          if (Number.isFinite(n2)) return n2;
        }
      }
    }
    return NaN;
  }

  // Fallback mapping if only letter ranks exist (kept minimal)
  var LETTER_BASE = { "SSS": 700, "SS": 600, "S": 500, "A": 400, "B": 300, "C": 200 };
  function detectLetterBase(item, canon){
    // look for per-style letter like item.simple_rank = 'S'
    var letter = null;
    var names = FIELD_CANDIDATES[canon] || [];
    for (var i=0;i<names.length;i++){
      var k = names[i] + "_rank";
      if (item && Object.prototype.hasOwnProperty.call(item, k)){
        letter = String(item[k]).toUpperCase().trim();
        break;
      }
    }
    if (!letter){
      // generic fields
      letter = (item && (item.rank || item.Rank)) ? String(item.rank || item.Rank).toUpperCase().trim() : '';
    }
    return LETTER_BASE[letter] || 0;
  }

  function getStageMainSub(stage){
    if (!stage) return { mainKey:'', mainW:0, subKey:'', subW:0 };
    // infer style labels
    var mainLabel = stage.main || stage.main_style || stage.mainStyle || stage.primary || stage.primary_style;
    var subLabel  = stage.sub  || stage.sub_style  || stage.subStyle  || stage.secondary || stage.secondary_style;
    var mainKey = STYLE_CANON[ (mainLabel||'').toString().trim() ] || '';
    var subKey  = STYLE_CANON[ (subLabel ||'').toString().trim() ] || '';

    // read weights; default 1.33 / 1.00 when only labels exist
    var mainW = stage.weight_main || stage.main_weight || stage.mainWeight || stage.weightMain || stage.weight1;
    var subW  = stage.weight_sub  || stage.sub_weight  || stage.subWeight  || stage.weightSub  || stage.weight2;
    if (!Number.isFinite(toNum(mainW)) && (mainKey || subKey)){ mainW = 1.33; }
    if (!Number.isFinite(toNum(subW))  && (mainKey || subKey)){ subW = 1.00; }
    mainW = toNum(mainW); subW = toNum(subW);
    if (!Number.isFinite(mainW)) mainW = 0;
    if (!Number.isFinite(subW))  subW = 0;

    // Allow full style_weights override
    if (stage.style_weights && typeof stage.style_weights === 'object'){
      // pick top-2
      var entries = Object.entries(stage.style_weights).filter(function(p){ return toNum(p[1])>0; }).sort(function(a,b){ return toNum(b[1]) - toNum(a[1]); });
      if (entries[0]){ mainKey = entries[0][0]; mainW = toNum(entries[0][1]); }
      if (entries[1]){ subKey  = entries[1][0]; subW  = toNum(entries[1][1]); }
    }

    return { mainKey, mainW, subKey, subW };
  }

  function detectGrade(item){
    var g = null;
    if (item){
      g = item.grade || item.Grade || item.rank || item.Rank || item.rating || item.Rating || item.tier || item.level || item.등급;
    }
    g = (g==null ? '' : String(g)).toUpperCase().replace(/\s+/g,'');
    return GRADE_OFFSET.hasOwnProperty(g) ? g : '';
  }

  // Override the scorer: ignore any prior normalization; compute from RAW numeric attributes if available
  var PREV = window.scoreItemForStage; // keep for fallback but we won't use its normalization
  window.scoreItemForStage = function(item, stage){
    try{
      var MS = getStageMainSub(stage);
      var mainPts = Number.isFinite(detectNumericAttr(item, MS.mainKey)) ? detectNumericAttr(item, MS.mainKey) : detectLetterBase(item, MS.mainKey);
      var subPts  = Number.isFinite(detectNumericAttr(item, MS.subKey )) ? detectNumericAttr(item, MS.subKey ) : detectLetterBase(item, MS.subKey );
      var base = (mainPts * MS.mainW) + (subPts * MS.subW);

      // Add grade offset
      var g = detectGrade(item);
      var add = GRADE_OFFSET[g] || 0;
      return base + add;
    }catch(e){
      // Fallback to previous behavior if something goes wrong
      try { return typeof PREV==='function' ? PREV(item, stage) : 0; } catch(ex){ return 0; }
    }
  };

  // Re-render after patch to reflect new, larger scale
  setTimeout(function(){
    try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){}
  }, 30);
})();
</script>
<!-- === PATCH v18: Per-attribute grade points (user-provided table) === -->
<script>
(function(){
  if (window.__attrGradePointsPatchApplied) return;
  window.__attrGradePointsPatchApplied = true;

  // Your table: use EXACT values you provided
  var GRADE_POINTS = {
    "SSS": 3200,
    "SS": 2612.7,
    "S": 2089.35,
    "A": 1690.65,
    "B": 1309.8,
    "C": 817.5
  };

  // Canonicalize style names
  var STYLE_CANON = {
    "화려":"flair","심플":"simple","우아":"elegant","활발":"lively","성숙":"mature",
    "큐티":"cute","섹시":"sexy","청순":"pure","청량":"cool","따뜻":"warm",
    "flair":"flair","simple":"simple","elegant":"elegant","lively":"lively","mature":"mature",
    "cute":"cute","sexy":"sexy","pure":"pure","cool":"cool","warm":"warm"
  };

  // Detect main/sub + weights (same as v17)
  function toNum(v){ var n=Number(v); return Number.isFinite(n)?n:NaN; }
  function getStageMainSub(stage){
    if (!stage) return { mainKey:'', mainW:0, subKey:'', subW:0 };
    var mainLabel = stage.main || stage.main_style || stage.mainStyle || stage.primary || stage.primary_style;
    var subLabel  = stage.sub  || stage.sub_style  || stage.subStyle  || stage.secondary || stage.secondary_style;
    var mainKey = STYLE_CANON[ (mainLabel||'').toString().trim() ] || '';
    var subKey  = STYLE_CANON[ (subLabel ||'').toString().trim() ] || '';
    var mainW = stage.weight_main || stage.main_weight || stage.mainWeight || stage.weightMain || stage.weight1;
    var subW  = stage.weight_sub  || stage.sub_weight  || stage.subWeight  || stage.weightSub  || stage.weight2;
    if (!Number.isFinite(toNum(mainW)) && (mainKey || subKey)){ mainW = 1.33; }
    if (!Number.isFinite(toNum(subW))  && (mainKey || subKey)){ subW = 1.00; }
    mainW = toNum(mainW); subW = toNum(subW);
    if (!Number.isFinite(mainW)) mainW = 0;
    if (!Number.isFinite(subW))  subW = 0;
    if (stage.style_weights && typeof stage.style_weights === 'object'){
      var entries = Object.entries(stage.style_weights).filter(function(p){ return toNum(p[1])>0; }).sort(function(a,b){ return toNum(b[1]) - toNum(a[1]); });
      if (entries[0]){ mainKey = entries[0][0]; mainW = toNum(entries[0][1]); }
      if (entries[1]){ subKey  = entries[1][0]; subW  = toNum(entries[1][1]); }
    }
    return { mainKey, mainW, subKey, subW };
  }

  // Fetch attribute points for a given style from item:
  // 1) If item has numeric points for that style, use them
  // 2) Else if item has a LETTER grade for that style (e.g., simple: "S"), map via GRADE_POINTS
  function getAttrPoints(item, canon){
    if (!item || !canon) return 0;
    // Check numeric forms first (common keys)
    var numericKeys = [canon, canon+"_points", canon+"_point", canon+"_score", canon+"Points", canon+"Point", canon+"Score"];
    for (var i=0;i<numericKeys.length;i++){
      var k = numericKeys[i];
      if (Object.prototype.hasOwnProperty.call(item, k)){
        var v = item[k];
        // allow "2,345" strings
        if (typeof v === 'string'){
          var s = v.replace(/[, ]+/g,'').trim();
          var n = Number(s);
          if (Number.isFinite(n)) return n;
        }
        var n2 = Number(v);
        if (Number.isFinite(n2)) return n2;
      }
    }
    // Also check Korean field directly (e.g., item["심플"] = "S")
    var koKey = Object.keys(STYLE_CANON).find(function(k){ return STYLE_CANON[k] === canon && k.length <= 2; }); // e.g. "심플"
    if (koKey && Object.prototype.hasOwnProperty.call(item, koKey)){
      var val = String(item[koKey]).toUpperCase().replace(/\s+/g,'');
      if (GRADE_POINTS.hasOwnProperty(val)) return GRADE_POINTS[val];
    }
    // Check letter at canonical key (e.g., item.simple = "S")
    if (Object.prototype.hasOwnProperty.call(item, canon)){
      var v2 = String(item[canon]).toUpperCase().replace(/\s+/g,'');
      if (GRADE_POINTS.hasOwnProperty(v2)) return GRADE_POINTS[v2];
    }
    return 0;
  }

  // Override scorer to: base = mainPts*mainW + subPts*subW (no extra additive grade)
  var PREV = window.scoreItemForStage;
  window.scoreItemForStage = function(item, stage){
    try{
      var MS = getStageMainSub(stage);
      var mainPts = getAttrPoints(item, MS.mainKey);
      var subPts  = getAttrPoints(item, MS.subKey);
      var base = (mainPts * MS.mainW) + (subPts * MS.subW);
      return base;
    }catch(e){
      try { return typeof PREV==='function' ? PREV(item, stage) : 0; } catch(ex){ return 0; }
    }
  };

  // Re-render to apply new formula
  setTimeout(function(){ try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){} }, 30);
})();
</script>
<!-- === PATCH v19: Robust stage main/sub detection + safe fallback === -->
<script>
(function(){
  if (window.__stageDetectKRPatchApplied) return;
  window.__stageDetectKRPatchApplied = true;

  var GRADE_POINTS = {
    "SSS": 3200, "SS": 2612.7, "S": 2089.35, "A": 1690.65, "B": 1309.8, "C": 817.5
  };

  var STYLE_CANON = {
    "화려":"flair","심플":"simple","우아":"elegant","활발":"lively","성숙":"mature",
    "큐티":"cute","섹시":"sexy","청순":"pure","청량":"cool","따뜻":"warm",
    "flair":"flair","simple":"simple","elegant":"elegant","lively":"lively","mature":"mature",
    "cute":"cute","sexy":"sexy","pure":"pure","cool":"cool","warm":"warm"
  };

  function toNum(v){ var n = Number(v); return Number.isFinite(n)? n : NaN; }
  function gp(val){
    var s = String(val==null?'':val).toUpperCase().replace(/\s+/g,'');
    return GRADE_POINTS.hasOwnProperty(s) ? GRADE_POINTS[s] : 0;
  }

  function getAttrPoints(item, canon){
    if (!item || !canon) return 0;
    // numeric priority
    var numericKeys = [canon, canon+"_points", canon+"_point", canon+"_score", canon+"Points", canon+"Point", canon+"Score"];
    for (var i=0;i<numericKeys.length;i++){
      var k = numericKeys[i];
      if (Object.prototype.hasOwnProperty.call(item, k)){
        var v = item[k];
        if (typeof v === 'string'){
          var s = v.replace(/[, ]+/g,'').trim();
          var n = Number(s);
          if (Number.isFinite(n)) return n;
        }
        var n2 = Number(v);
        if (Number.isFinite(n2)) return n2;
      }
    }
    // letter at ko key (e.g., "심플": "S")
    var koKey = Object.keys(STYLE_CANON).find(function(k){ return STYLE_CANON[k]===canon && k.length<=2; });
    if (koKey && Object.prototype.hasOwnProperty.call(item, koKey)){
      return gp(item[koKey]);
    }
    // letter at canonical key (e.g., simple: "S")
    if (Object.prototype.hasOwnProperty.call(item, canon)){
      return gp(item[canon]);
    }
    return 0;
  }

  // NEW: derive top-2 attrs from item itself (for fallback)
  function top2AttrsFromItem(item){
    var entries = Object.keys(STYLE_CANON).filter(function(k){ return STYLE_CANON[k]===k; /* dedupe by canonical set */ });
    var canonList = ["flair","simple","elegant","lively","mature","cute","sexy","pure","cool","warm"];
    var scored = [];
    for (var i=0;i<canonList.length;i++){
      var c = canonList[i];
      var pts = getAttrPoints(item, c);
      scored.push([c, pts]);
    }
    scored.sort(function(a,b){ return b[1]-a[1]; });
    var m = scored[0] || ['simple',0];
    var s = scored[1] || ['pure',0];
    return { mainKey: m[0], subKey: s[0] };
  }

  // Replace getStageMainSub with a more robust version
  (function(){
    var OLD_SCORER = window.scoreItemForStage; // we'll wrap later
    var PREV_getStageMainSub = window.getStageMainSub;

    window.getStageMainSub = function(stage, item){
      var mainLabel = null, subLabel = null, mainW = null, subW = null;

      if (stage && typeof stage === 'object'){
        // English
        mainLabel = stage.main || stage.main_style || stage.mainStyle || stage.primary || stage.primary_style || mainLabel;
        subLabel  = stage.sub  || stage.sub_style  || stage.subStyle  || stage.secondary || stage.secondary_style || subLabel;
        mainW = stage.weight_main || stage.main_weight || stage.mainWeight || stage.weightMain || stage.weight1 || mainW;
        subW  = stage.weight_sub  || stage.sub_weight  || stage.subWeight  || stage.weightSub  || stage.weight2  || subW;

        // Korean
        mainLabel = stage["메인"] || stage["메인속성"] || stage["주속성"] || stage["주"] || stage["주요"] || mainLabel;
        subLabel  = stage["서브"] || stage["서브속성"] || stage["부속성"] || stage["부"] || stage["보조"] || subLabel;
        mainW = stage["메인가중치"] || stage["메인가중"] || stage["메인_가중치"] || stage["주가중치"] || mainW;
        subW  = stage["서브가중치"] || stage["서브가중"] || stage["서브_가중치"] || stage["부가중치"] || subW;

        // Chinese hints (just in case)
        mainLabel = stage["主"] || stage["主属性"] || mainLabel;
        subLabel  = stage["副"] || stage["副属性"] || subLabel;
        mainW = stage["主权重"] || mainW;
        subW  = stage["副权重"] || subW;

        // style_weights override
        if (stage.style_weights && typeof stage.style_weights === 'object'){
          var arr = Object.entries(stage.style_weights).filter(function(p){ return toNum(p[1])>0; }).sort(function(a,b){ return toNum(b[1])-toNum(a[1]); });
          if (arr[0]){ mainLabel = arr[0][0]; mainW = toNum(arr[0][1]); }
          if (arr[1]){ subLabel  = arr[1][0]; subW  = toNum(arr[1][1]); }
        }
      }

      var mainKey = STYLE_CANON[(mainLabel||'').toString().trim()] || '';
      var subKey  = STYLE_CANON[(subLabel ||'').toString().trim()] || '';

      // Defaults if only labels exist
      if (!Number.isFinite(toNum(mainW)) && (mainKey || subKey)) mainW = 1.33;
      if (!Number.isFinite(toNum(subW))  && (mainKey || subKey)) subW  = 1.00;

      // Fallback: if both missing, derive from item top2
      if (!mainKey && !subKey && item){
        var pair = top2AttrsFromItem(item);
        mainKey = pair.mainKey;
        subKey  = pair.subKey;
        if (!Number.isFinite(toNum(mainW))) mainW = 1.33;
        if (!Number.isFinite(toNum(subW)))  subW  = 1.00;
      }

      mainW = toNum(mainW); subW = toNum(subW);
      if (!Number.isFinite(mainW)) mainW = 0;
      if (!Number.isFinite(subW))  subW  = 0;

      return { mainKey, mainW, subKey, subW };
    };

    // Now wrap the scorer from v18 to pass item into getStageMainSub
    var BASE = window.scoreItemForStage || function(){ return 0; };
    window.scoreItemForStage = function(item, stage){
      try{
        var MS = window.getStageMainSub(stage, item);
        var mainPts = (function(){
          return (function(it, c){ if (!c) return 0; return (function(){ // inline getAttrPoints
            // Numeric or grade letter to your table
            var numericKeys = [c, c+"_points", c+"_point", c+"_score", c+"Points", c+"Point", c+"Score"];
            for (var i=0;i<numericKeys.length;i++){
              var k = numericKeys[i];
              if (Object.prototype.hasOwnProperty.call(it, k)){
                var v = it[k];
                if (typeof v === 'string'){
                  var s = v.replace(/[, ]+/g,'').trim();
                  var n = Number(s);
                  if (Number.isFinite(n)) return n;
                }
                var n2 = Number(v);
                if (Number.isFinite(n2)) return n2;
              }
            }
            var koKey = Object.keys(STYLE_CANON).find(function(k){ return STYLE_CANON[k]===c && k.length<=2; });
            if (koKey && Object.prototype.hasOwnProperty.call(it, koKey)){ return gp(it[koKey]); }
            if (Object.prototype.hasOwnProperty.call(it, c)){ return gp(it[c]); }
            return 0;
          })(); })(item, MS.mainKey);
        })();
        var subPts = (function(){
          return (function(it, c){ if (!c) return 0; return (function(){
            var numericKeys = [c, c+"_points", c+"_point", c+"_score", c+"Points", c+"Point", c+"Score"];
            for (var i=0;i<numericKeys.length;i++){
              var k = numericKeys[i];
              if (Object.prototype.hasOwnProperty.call(it, k)){
                var v = it[k];
                if (typeof v === 'string'){
                  var s = v.replace(/[, ]+/g,'').trim();
                  var n = Number(s);
                  if (Number.isFinite(n)) return n;
                }
                var n2 = Number(v);
                if (Number.isFinite(n2)) return n2;
              }
            }
            var koKey = Object.keys(STYLE_CANON).find(function(k){ return STYLE_CANON[k]===c && k.length<=2; });
            if (koKey && Object.prototype.hasOwnProperty.call(it, koKey)){ return gp(it[koKey]); }
            if (Object.prototype.hasOwnProperty.call(it, c)){ return gp(it[c]); }
            return 0;
          })(); })(item, MS.subKey);
        })();

        var base = (mainPts * MS.mainW) + (subPts * MS.subW);
        return base;
      }catch(e){
        try { return BASE(item, stage); } catch(ex){ return 0; }
      }
    };
  })();

  setTimeout(function(){ try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){} }, 30);
})();
</script>
<!-- === PATCH v20: Full vector scoring (sum over all styles) === -->
<script>
(function(){
  if (window.__fullVectorScoringPatchApplied) return;
  window.__fullVectorScoringPatchApplied = true;

  // Canonical mapping
  var STYLE_CANON = {
    "화려":"flair","심플":"simple","우아":"elegant","활발":"lively","성숙":"mature",
    "큐티":"cute","섹시":"sexy","청순":"pure","청량":"cool","따뜻":"warm",
    "flair":"flair","simple":"simple","elegant":"elegant","lively":"lively","mature":"mature",
    "cute":"cute","sexy":"sexy","pure":"pure","cool":"cool","warm":"warm"
  };
  var ALL_STYLES = ["flair","simple","elegant","lively","mature","cute","sexy","pure","cool","warm"];

  // Grade -> points (your exact table)
  var GRADE_POINTS = {
    "SSS": 3200, "SS": 2612.7, "S": 2089.35, "A": 1690.65, "B": 1309.8, "C": 817.5
  };

  function toNum(v){
    var n = Number(v);
    return Number.isFinite(n) ? n : NaN;
  }
  function canonKey(k){
    return STYLE_CANON[ (k||'').toString().trim() ] || '';
  }

  // Get stage weight for a canonical style, reading both Korean/English keys
  function stageWeight(stage, canon){
    if (!stage || !canon) return 0;
    // direct canonical
    if (Object.prototype.hasOwnProperty.call(stage, canon)){
      var n = toNum(stage[canon]); if (Number.isFinite(n)) return n;
    }
    // try Korean key for this canon
    var ko = null;
    for (var k in STYLE_CANON){
      if (STYLE_CANON[k] === canon && k.length <= 2){ ko = k; break; }
    }
    if (ko && Object.prototype.hasOwnProperty.call(stage, ko)){
      var n2 = toNum(stage[ko]); if (Number.isFinite(n2)) return n2;
    }
    // style_weights container
    if (stage.style_weights && typeof stage.style_weights === 'object'){
      var v = stage.style_weights[canon];
      var n3 = toNum(v); if (Number.isFinite(n3)) return n3;
      if (ko && Object.prototype.hasOwnProperty.call(stage.style_weights, ko)){
        var n4 = toNum(stage.style_weights[ko]); if (Number.isFinite(n4)) return n4;
      }
    }
    return 0;
  }

  // Get item attribute points for a canonical style
  function itemPoints(item, canon){
    if (!item || !canon) return 0;
    // numeric preferred
    var numericKeys = [canon, canon+"_points", canon+"_point", canon+"_score", canon+"Points", canon+"Point", canon+"Score"];
    for (var i=0;i<numericKeys.length;i++){
      var key = numericKeys[i];
      if (Object.prototype.hasOwnProperty.call(item, key)){
        var v = item[key];
        if (typeof v === 'string'){
          var s = v.replace(/[, ]+/g,'').trim();
          var n = Number(s);
          if (Number.isFinite(n)) return n;
        }
        var n2 = Number(v);
        if (Number.isFinite(n2)) return n2;
      }
    }
    // Korean key letter (e.g., "심플": "S")
    var ko = null;
    for (var k in STYLE_CANON){ if (STYLE_CANON[k]===canon && k.length<=2){ ko=k; break; } }
    if (ko && Object.prototype.hasOwnProperty.call(item, ko)){
      var g = String(item[ko]).toUpperCase().replace(/\s+/g,'');
      if (GRADE_POINTS.hasOwnProperty(g)) return GRADE_POINTS[g];
    }
    // Canonical key letter (e.g., simple: "S")
    if (Object.prototype.hasOwnProperty.call(item, canon)){
      var g2 = String(item[canon]).toUpperCase().replace(/\s+/g,'');
      if (GRADE_POINTS.hasOwnProperty(g2)) return GRADE_POINTS[g2];
    }
    return 0;
  }

  // Override scorer: Σ over all styles
  var PREV = window.scoreItemForStage;
  window.scoreItemForStage = function(item, stage){
    try{
      var sum = 0;
      for (var i=0;i<ALL_STYLES.length;i++){
        var s = ALL_STYLES[i];
        var w = stageWeight(stage, s);
        if (!w) continue;
        var p = itemPoints(item, s);
        if (!p) continue;
        sum += p * w;
      }
      return sum;
    }catch(e){
      try { return typeof PREV==='function' ? PREV(item, stage) : 0; } catch(ex){ return 0; }
    }
  };

  // Re-render to apply new scoring
  setTimeout(function(){ try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){} }, 30);
})();
</script>
<script>
/* === Owned status robust patch (fixed21) === */
(function(){
  function normOwnedName(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,''); }
  window.normOwnedName = window.normOwnedName || normOwnedName;

  function parseOwned(text){
    return String(text||'')
      .split(/[\n\r;,]+|\s{2,}/g)
      .map(function(s){ return s.trim(); })
      .filter(Boolean);
  }

  function rebuildOwnedSet(){
    try{
      var ta = document.getElementById('ownedInput');
      var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
      window.ownedNameSet = new Set(names.map(normOwnedName));
    }catch(e){
      window.ownedNameSet = new Set();
    }
  }

  // Wrap getFilteredList to re-tag items with _owned reliably
  var __origGetFilteredList = window.getFilteredList;
  window.getFilteredList = function(stage){
    try{
      var base = __origGetFilteredList ? __origGetFilteredList(stage) :
                (Array.isArray(window.items) ? window.items.slice() : []);
      var hasSet = (window.ownedNameSet instanceof Set) && (typeof window.normOwnedName === 'function');
      if(!hasSet) return base;
      return base.map(function(it){
        var nm = (it && it.name) || '';
        var key = window.normOwnedName(nm);
        return Object.assign({}, it, {_owned: window.ownedNameSet.has(key)});
      });
    }catch(e){
      return [];
    }
  };

  // Ensure badges and list refresh after any change
  document.addEventListener('DOMContentLoaded', function(){
    rebuildOwnedSet();
    if(typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
  });

  document.addEventListener('input', function(ev){
    if(ev && ev.target && ev.target.id === 'ownedInput'){
      rebuildOwnedSet();
      if(typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
      if(typeof window.renderAll === 'function') window.renderAll();
    }
  }, false);

  // Wrap renderAll to rebuild set before rendering to keep state in sync
  if(typeof window.renderAll === 'function'){
    var __origRenderAll = window.renderAll;
    window.renderAll = function(){
      rebuildOwnedSet();
      var r = __origRenderAll.apply(this, arguments);
      if(typeof window.updateOwnedBadges === 'function') window.updateOwnedBadges();
      return r;
    };
  }
})();
</script>
<script>
/* === Filters change hook (fixed22) === */
(function(){
  document.addEventListener('change', function(ev){
    var id = ev && ev.target && ev.target.id;
    if(id === 'partFilter' || id === 'ownedOnly' || id === 'sortBy'){
      if(typeof window.renderAll === 'function') window.renderAll();
    }
  }, false);
})();
</script>
<script>
/* === DOM enforcement for part/owned filters (fixed22) === */
(function(){
  function enforceDOMFilters(){
    try{
      var partSel = document.getElementById('partFilter');
      var part = partSel ? partSel.value : '';
      var ownedOnlyEl = document.getElementById('ownedOnly');
      var ownedOnly = ownedOnlyEl ? !!ownedOnlyEl.checked : false;

      // Cards
      var cards = document.querySelectorAll('#list .card');
      if(cards.length){
        cards.forEach(function(card){
          var partEl = card.querySelector('[data-field="part"], .part, td.part');
          var nameEl = card.querySelector('[data-field="name"], .name, .title');
          var nm = nameEl ? nameEl.textContent.trim() : '';
          var ptxt = partEl ? partEl.textContent.trim() : '';
          var show = true;
          if(part){ show = show && (ptxt === part); }
          if(ownedOnly){
            var ownedMark = card.querySelector('.badge.owned,[data-owned="1"]');
            // fallback: check with global set
            if(!ownedMark && window.ownedNameSet && typeof window.normOwnedName === 'function' && nm){
              show = show && window.ownedNameSet.has(window.normOwnedName(nm));
            } else {
              show = show && !!ownedMark;
            }
          }
          card.style.display = show ? '' : 'none';
        });
      }
      // Table rows
      var trs = document.querySelectorAll('#itemsTable tbody tr');
      if(trs.length){
        trs.forEach(function(tr){
          var ptd = tr.children && tr.children[1]; // second column is part
          var ntd = tr.children && tr.children[3]; // fourth column is name
          var ptxt = ptd ? (ptd.textContent||'').trim() : '';
          var nm = ntd ? (ntd.textContent||'').trim() : '';
          var show = true;
          if(part){ show = show && (ptxt === part); }
          if(ownedOnly){
            var ownedCell = tr.querySelector('.badge.owned,[data-owned="1"]');
            if(!ownedCell && window.ownedNameSet && typeof window.normOwnedName === 'function' && nm){
              show = show && window.ownedNameSet.has(window.normOwnedName(nm));
            } else if(ownedCell){
              show = show && true;
            } else {
              show = false;
            }
          }
          tr.style.display = show ? '' : 'none';
        });
      }
    }catch(e){}
  }

  if(typeof window.renderAll === 'function'){
    var __orig = window.renderAll;
    window.renderAll = function(){
      var r = __orig.apply(this, arguments);
      // run after DOM paint
      setTimeout(enforceDOMFilters, 0);
      return r;
    };
  }
  document.addEventListener('DOMContentLoaded', function(){ setTimeout(enforceDOMFilters, 50); });
  document.addEventListener('change', function(ev){
    var id = ev && ev.target && ev.target.id;
    if(id === 'partFilter' || id === 'ownedOnly'){ setTimeout(enforceDOMFilters, 0); }
  }, false);
})();
</script>
<script>
/* === Super filter (fixed23): renderer-agnostic owned + part filtering === */
(function(){
  function norm(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/[\s\u00A0]+/g,''); }
  function getOwnedSet(){
    try { return (window.ownedNameSet instanceof Set) ? window.ownedNameSet : new Set(); }
    catch(e){ return new Set(); }
  }
  function getActivePart(){
    var sel = document.getElementById('partFilter');
    return sel ? sel.value : '';
  }
  function isOwnedName(nm){
    try{
      var set = getOwnedSet();
      if(!set.size) return false;
      return set.has(norm(nm));
    }catch(e){ return false; }
  }
  function extractNameFromCard(card){
    if(!card) return '';
    var el = card.querySelector('[data-field="name"], .item-name, .card-title, .title, .name, h3');
    if(el && el.textContent) return el.textContent.trim();
    // fallback to aria/title
    var a = card.getAttribute('aria-label') || card.getAttribute('title') || '';
    return a.trim();
  }
  function extractPartFromCard(card){
    if(!card) return '';
    // explicit attributes first
    var el = card.querySelector('[data-part], [data-field="part"], .part, td.part');
    if(el && el.textContent) return el.textContent.trim();
    // try badges that match a known part
    var known = (function(){
      var k = Object.keys(window.PART_WEIGHTS || {});
      // plus common accessory buckets
      k = k.concat(["장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식","장식 - 귀",
                    "장식 - 목 - 목도리","장식 - 목 - 목걸이",
                    "장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑",
                    "장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손","장식 - 허리",
                    "장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리",
                    "장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨",
                    "반딧불의 영혼","뷰티"]);
      return Array.from(new Set(k));
    })();
    var badges = card.querySelectorAll('.badge, .badges .badge, .pill, .chip');
    for(var i=0;i<badges.length;i++){
      var t = (badges[i].textContent||'').trim();
      if(known.indexOf(t) !== -1) return t;
    }
    // last resort: search small/label cells
    var small = card.querySelector('.small, .label');
    if(small && small.textContent) return small.textContent.trim();
    return '';
  }
  function enforce(){
    var part = getActivePart();
    var ownedOnlyEl = document.getElementById('ownedOnly');
    var ownedOnly = ownedOnlyEl ? !!ownedOnlyEl.checked : false;

    // Cards list (추천/점수 탭)
    var list = document.getElementById('list');
    if(list){
      var cards = list.querySelectorAll('.card');
      cards.forEach(function(card){
        var nm = extractNameFromCard(card);
        var prt = extractPartFromCard(card);
        var show = true;
        if(part) show = show && (prt === part);
        if(ownedOnly) show = show && isOwnedName(nm);
        card.style.display = show ? '' : 'none';
        // annotate for debugging
        if(nm) card.setAttribute('data-filter-name', nm);
        if(prt) card.setAttribute('data-filter-part', prt);
        card.setAttribute('data-filter-owned', isOwnedName(nm) ? '1' : '0');
      });
    }

    // Table view rows
    var tbody = document.querySelector('#itemsTable tbody');
    if(tbody){
      var trs = tbody.querySelectorAll('tr');
      trs.forEach(function(tr){
        var nameCell = tr.children[3]; // 0:이미지,1:부위,2:코드,3:이름
        var partCell = tr.children[1];
        var nm = nameCell ? (nameCell.textContent||'').trim() : '';
        var prt = partCell ? (partCell.textContent||'').trim() : '';
        var show = true;
        if(part) show = show && (prt === part);
        if(ownedOnly) show = show && isOwnedName(nm);
        tr.style.display = show ? '' : 'none';
        if(nm) tr.setAttribute('data-filter-name', nm);
        if(prt) tr.setAttribute('data-filter-part', prt);
        tr.setAttribute('data-filter-owned', isOwnedName(nm) ? '1' : '0');
      });
    }
  }

  // Run on initial load, on input/change, and after renders
  document.addEventListener('DOMContentLoaded', function(){ setTimeout(enforce, 50); });
  document.addEventListener('input', function(ev){
    if(ev && (ev.target && (ev.target.id === 'ownedInput'))) setTimeout(enforce, 0);
  }, false);
  document.addEventListener('change', function(ev){
    var id = ev && ev.target && ev.target.id;
    if(id === 'partFilter' || id === 'ownedOnly' || id === 'sortBy') setTimeout(enforce, 0);
  }, false);

  if(typeof window.renderAll === 'function'){
    var __orig = window.renderAll;
    window.renderAll = function(){
      var r = __orig.apply(this, arguments);
      setTimeout(enforce, 0);
      return r;
    };
  }

  // Expose for manual trigger
  window.__enforceSuperFilter = enforce;
})();
</script>
<script>
/* === Name-set DOM filter (fixed24): match by item names present in card/row text === */
(function(){
  function norm(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/[\s\u00A0]+/g,''); }
  function parseOwned(text){
    return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean);
  }
  function getOwnedSet(){
    try{
      var ta = document.getElementById('ownedInput');
      var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
      return new Set(names.map(norm));
    }catch(e){ return new Set(); }
  }
  function getActivePart(){
    var sel = document.getElementById('partFilter');
    return sel ? sel.value : '';
  }
  function buildFilteredNameSet(){
    var items = Array.isArray(window.items) ? window.items : [];
    var ownedOnlyEl = document.getElementById('ownedOnly');
    var ownedOnly = ownedOnlyEl ? !!ownedOnlyEl.checked : false;
    var part = getActivePart();
    var ownedSet = getOwnedSet();
    var set = new Set();
    for(var i=0;i<items.length;i++){
      var it = items[i] || {};
      if(part && String(it.part||'') !== part) continue;
      if(ownedOnly && !ownedSet.has(norm(it.name))) continue;
      set.add(norm(it.name));
    }
    return set;
  }
  function bestNameFromText(text, nameList){
    var T = norm(text);
    var best = '';
    for(var i=0;i<nameList.length;i++){
      var n = nameList[i];
      if(!n) continue;
      if(T.indexOf(n) !== -1){
        if(n.length > best.length) best = n; // prefer longest match
      }
    }
    return best || null;
  }
  function enforceByNameSet(){
    try{
      var filteredSet = buildFilteredNameSet();
      var allNames = Array.isArray(window.items) ? window.items.map(function(it){return norm(it && it.name);}) : [];
      // unique & sort by length desc for better matching
      var uniq = Array.from(new Set(allNames)).filter(Boolean).sort(function(a,b){ return b.length - a.length; });

      // Cards
      var list = document.getElementById('list');
      if(list){
        var cards = list.querySelectorAll('.card');
        cards.forEach(function(card){
          var text = card.textContent || '';
          var nm = bestNameFromText(text, uniq);
          var show = true;
          if(nm){ show = filteredSet.has(nm); }
          card.style.display = show ? '' : 'none';
          if(nm){ card.setAttribute('data-filter-name2', nm); }
        });
      }
      // Table rows
      var tbody = document.querySelector('#itemsTable tbody');
      if(tbody){
        var trs = tbody.querySelectorAll('tr');
        trs.forEach(function(tr){
          var text = tr.textContent || '';
          var nm = bestNameFromText(text, uniq);
          var show = true;
          if(nm){ show = filteredSet.has(nm); }
          tr.style.display = show ? '' : 'none';
          if(nm){ tr.setAttribute('data-filter-name2', nm); }
        });
      }
    }catch(e){}
  }

  // Hook lifecycle
  document.addEventListener('DOMContentLoaded', function(){ setTimeout(enforceByNameSet, 100); });
  document.addEventListener('change', function(ev){
    var id = ev && ev.target && ev.target.id;
    if(id === 'partFilter' || id === 'ownedOnly' || id === 'sortBy') setTimeout(enforceByNameSet, 0);
  }, false);
  document.addEventListener('input', function(ev){
    if(ev && ev.target && ev.target.id === 'ownedInput') setTimeout(enforceByNameSet, 0);
  }, false);
  if(typeof window.renderAll === 'function'){
    var __orig = window.renderAll;
    window.renderAll = function(){
      var r = __orig.apply(this, arguments);
      setTimeout(enforceByNameSet, 0);
      return r;
    };
  }
  window.__enforceByNameSet = enforceByNameSet;
})();
</script>
<!-- integrated patch for 장식/특수 탭 fix (2025-10-19) -->
<script>
(function(){
  'use strict';
  if (window.__ACC_SPECIAL_PATCH_APPLIED__) return;
  window.__ACC_SPECIAL_PATCH_APPLIED__ = true;

  function $(id){ return document.getElementById(id); }
  function normName(s){
    if (typeof window.normOwnedName === 'function') return window.normOwnedName(s);
    return String(s||'').normalize('NFKC').toLowerCase().replace(/\s+/g,'');
  }

  var ACC_HEAD = ["장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식","장식 - 귀","장식 - 목 - 목도리","장식 - 목 - 목걸이"];
  var ACC_HAND = ["장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑"];
  var ACC_PROP = ["장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손","장식 - 허리"];
  var ACC_SPECIAL = ["장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리","장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"];
  var ACC_OTHER = ["반딧불의 영혼"];

  function chipHtml(label, owned, total, partValue){
    var lbl = label.split(' - ').pop();
    return '<span class="chip" data-part="'+partValue+'"><span class="k">'+lbl+'</span><span class="v"> '+(owned||0)+'/'+(total||0)+'</span></span>';
  }
  function parseOwned(t){return String(t||'').split(/[\n\r;,]+|\s{2,}/g).map(s=>s.trim()).filter(Boolean);}
  function getStats(){
    var items = window.items||window.ITEMS||[];
    var totals={}, byName={};
    for (let it of items){ if(!it)continue; let p=it.part||''; totals[p]=(totals[p]||0)+1; byName[normName(it.name)]=it; }
    var ownedPer={}, ta=$('ownedInput'), names=ta?Array.from(new Set(parseOwned(ta.value))):[];
    for(let nm of names){let it=byName[normName(nm)]; if(it){ownedPer[it.part]=(ownedPer[it.part]||0)+1;}}
    return {totals, ownedPer};
  }

  function renderChips(parts){
    var row=$('partChips'); if(!row)return; var S=getStats();
    row.innerHTML = parts.map(p=>chipHtml(p,S.ownedPer[p]||0,S.totals[p]||0,p)).join('');
  }

  function renderAcc(){renderChips(ACC_HEAD.concat(ACC_HAND,ACC_PROP));}
  function renderSpecial(){renderChips(ACC_SPECIAL);}
  function renderSoul(){renderChips(ACC_OTHER);}

  var orig=window.setGroup;
  window.setGroup=function(g){
    if(g==='acc') return renderAcc();
    if(g==='special') return renderSpecial();
    if(g==='soul') return renderSoul();
    if(typeof orig==='function') return orig(g);
  };

  document.addEventListener('click',function(e){
    var chip=e.target.closest&&e.target.closest('#partChips .chip');
    if(!chip)return;
    var part=chip.getAttribute('data-part')||'';
    var sel=$('partFilter'); if(!sel)return;
    for(let i=0;i<sel.options.length;i++){ if(sel.options[i].value===part){sel.selectedIndex=i; break;} }
    sel.dispatchEvent(new Event('change',{bubbles:true}));
  });
})();
</script>

<!-- accessory fix patch v2: normalize filter options + preserve original setGroup side-effects -->
<script>
(function(){
  'use strict';
  if (window.__ACC_SPECIAL_PATCH_V2__) return;
  window.__ACC_SPECIAL_PATCH_V2__ = true;

  function $(id){ return document.getElementById(id); }
  function normName(s){
    if (typeof window.normOwnedName === 'function') return window.normOwnedName(s);
    return String(s||'').normalize('NFKC').toLowerCase().replace(/[\s\u00A0]+/g,'');
  }

  var ACC_HEAD = ["장식 - 머리 - 머리","장식 - 머리 - 베일","장식 - 머리 - 헤어핀","장식 - 머리 - 귀장식","장식 - 귀","장식 - 목 - 목도리","장식 - 목 - 목걸이"];
  var ACC_HAND = ["장식 - 손 - 팔찌(우)","장식 - 손 - 팔찌(좌)","장식 - 손 - 장갑"];
  var ACC_PROP = ["장식 - 소품 - 소품(우)","장식 - 소품 - 소품(좌)","장식 - 소품 - 양손","장식 - 허리"];
  var ACC_SPECIAL = ["장식 - 특수 - 얼굴","장식 - 특수 - 가슴","장식 - 특수 - 문신","장식 - 특수 - 날개","장식 - 특수 - 꼬리","장식 - 특수 - 전경","장식 - 특수 - 배경","장식 - 특수 - 상단","장식 - 특수 - 하단","장식 - 특수 - 스킨"];
  var ACC_OTHER = ["반딧불의 영혼"];

  function normalizeAccessoryFilterOptions(){
    var sel = $('partFilter'); if(!sel) return;
    var map = Object.create(null);
    function addMap(arr){
      for (var i=0;i<arr.length;i++){
        var full = arr[i], leaf = full.split(' - ').pop();
        map[leaf]=full; map[full]=full;
      }
    }
    addMap(ACC_HEAD); addMap(ACC_HAND); addMap(ACC_PROP); addMap(ACC_SPECIAL); addMap(ACC_OTHER);
    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      var text = (opt.textContent||opt.label||'').trim();
      if(!text) continue;
      if (map[text] && opt.value !== map[text]) opt.value = map[text];
    }
  }

  function chipHtml(label, owned, total, partValue){
    var lbl = String(label||''); if(lbl.indexOf(' - ')!==-1) lbl = lbl.split(' - ').pop();
    return '<span class="chip" data-part="'+(partValue||label)+'"><span class="k">'+lbl+'</span><span class="v"> '+(owned||0)+'/'+(total||0)+'</span></span>';
  }
  function parseOwned(t){return String(t||'').split(/[\n\r;,]+|\s{2,}/g).map(s=>s.trim()).filter(Boolean);}
  function getStats(){
    var items = Array.isArray(window.items)?window.items:(Array.isArray(window.ITEMS)?window.ITEMS:[]);
    var totals = Object.create(null), byName = Object.create(null);
    for (var i=0;i<items.length;i++){ var it=items[i]||{}; var p=String(it.part||''); totals[p]=(totals[p]||0)+1; byName[normName(it.name)]=it; }
    var ownedPer = Object.create(null), ta=$('ownedInput'); var names = ta?Array.from(new Set(parseOwned(ta.value))):[];
    for (var j=0;j<names.length;j++){ var it2=byName[normName(names[j])]; if(it2){ ownedPer[String(it2.part||'')] = (ownedPer[String(it2.part||'')]||0)+1; } }
    return {totals: totals, ownedPer: ownedPer};
  }

  function renderChips(parts){
    var row=$('partChips'); if(!row) return;
    var S=getStats();
    row.innerHTML = parts.map(function(p){ return chipHtml(p, S.ownedPer[p]||0, S.totals[p]||0, p); }).join('');
  }
  function renderAcc(){ renderChips(ACC_HEAD.concat(ACC_HAND, ACC_PROP)); }
  function renderSpecial(){ renderChips(ACC_SPECIAL); }
  function renderSoul(){ renderChips(ACC_OTHER); }

  // Preserve original behavior but ensure our chips render
  var __origSetGroup = window.setGroup;
  window.setGroup = function(g){
    // call original first to keep any side-effects (like class toggles)
    if (typeof __origSetGroup === 'function') { try { __origSetGroup(g); } catch(e){} }
    // then normalize filter options and render the right chips
    try { normalizeAccessoryFilterOptions(); } catch(e){}
    if (g === 'acc') return renderAcc();
    if (g === 'special') return renderSpecial();
    if (g === 'soul') return renderSoul();
    // fallthrough for others
  };

  // Clicking a chip selects the matching partFilter option
  document.addEventListener('click', function(ev){
    var chip = ev.target && ev.target.closest && ev.target.closest('#partChips .chip');
    if(!chip) return;
    var part = chip.getAttribute('data-part')||'';
    normalizeAccessoryFilterOptions();
    var sel = $('partFilter'); if(!sel) return;
    var matched = false;
    for (var i=0;i<sel.options.length;i++){ if(sel.options[i].value===part){ sel.selectedIndex=i; matched=true; break; } }
    if(!matched){
      var leaf = part.split(' - ').pop();
      for (var j=0;j<sel.options.length;j++){ var t=(sel.options[j].textContent||sel.options[j].label||'').trim(); if(t===leaf){ sel.selectedIndex=j; matched=true; break; } }
    }
    sel.dispatchEvent(new Event('change',{bubbles:true}));
  }, false);

  document.addEventListener('DOMContentLoaded', function(){
    try { normalizeAccessoryFilterOptions(); } catch(e){}
  });
})();
</script>

<!-- === PATCH v14: Async-safe unified '장식/특수' + reliable code index (2025-10-19) === -->
<script>
(function(){
  'use strict';
  if (window.__ACC_CODE_UNIFIED_V14__) return;
  window.__ACC_CODE_UNIFIED_V14__ = true;

  function $(id){ return document.getElementById(id); }
  var FIRE = '반딧불의 영혼';

  // Accessory & Special subpart labels that may appear in selectors (plain or prefixed)
  var ACC_PLAIN = ['머리','베일','헤어핀','귀장식','귀','목도리','목걸이','팔찌(우)','팔찌(좌)','장갑','소품(우)','소품(좌)','양손','허리'];
  var ACC_PREFIXED = [
    '장식 - 머리 - 머리','장식 - 머리 - 베일','장식 - 머리 - 헤어핀','장식 - 머리 - 귀장식','장식 - 귀',
    '장식 - 목 - 목도리','장식 - 목 - 목걸이',
    '장식 - 손 - 팔찌(우)','장식 - 손 - 팔찌(좌)','장식 - 손 - 장갑',
    '장식 - 소품 - 소품(우)','장식 - 소품 - 소품(좌)','장식 - 소품 - 양손','장식 - 허리'
  ];
  var SPEC_PREFIXED = ['장식 - 특수 - 얼굴','장식 - 특수 - 가슴','장식 - 특수 - 문신','장식 - 특수 - 날개','장식 - 특수 - 꼬리','장식 - 특수 - 전경','장식 - 특수 - 배경','장식 - 특수 - 상단','장식 - 특수 - 하단','장식 - 특수 - 스킨'];

  function isAccOrSpecLabel(v){
    if (!v) return false;
    v = String(v).trim();
    if (v === '장식' || v === '특수' || v === '장식/특수') return true;
    if (/\(자동\)/.test(v)) return true;
    if (v.indexOf('특수') !== -1) return true;
    if (/^\s*장식\s*\-/.test(v)) return true;
    for (var i=0;i<ACC_PLAIN.length;i++){ if (v === ACC_PLAIN[i]) return true; }
    for (var j=0;j<ACC_PREFIXED.length;j++){ if (v === ACC_PREFIXED[j]) return true; }
    for (var k=0;k<SPEC_PREFIXED.length;k++){ if (v === SPEC_PREFIXED[k]) return true; }
    return false;
  }
  function isAccOrSpecPart(part){
    var p = String(part||'').trim();
    if (!p || p === FIRE) return false; // exclude Firefly explicitly
    if (p.indexOf('특수') !== -1) return true;
    if (/^\s*장식\s*\-/.test(p)) return true;
    for (var i=0;i<ACC_PLAIN.length;i++){ if (p === ACC_PLAIN[i]) return true; }
    for (var j=0;j<ACC_PREFIXED.length;j++){ if (p === ACC_PREFIXED[j]) return true; }
    return false;
  }

  function codeKeys(code){
    var raw = String(code||'').trim(); if (!raw) return [];
    var noLead = raw.replace(/^0+/, '') || '0';
    var digits = raw.replace(/\D+/g, '') || '';
    var digitsNoLead = digits ? (digits.replace(/^0+/, '') || '0') : '';
    var set = Object.create(null);
    function add(k){ if(k && !set[k]) set[k]=true; }
    add(raw); add(noLead); add(digits); add(digitsNoLead);
    return Object.keys(set);
  }

  // Items accessor that waits for async injection
  function getItemsList(){
    var list = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    return Array.isArray(list) ? list : [];
  }

  // Unified index (rebuildable)
  function buildUnifiedIndex(){
    var list = getItemsList();
    var idx = Object.create(null);
    for (var i=0;i<list.length;i++){
      var it = list[i] || {};
      if (!isAccOrSpecPart(it.part)) continue;
      var code = (it.code!=null) ? String(it.code) : '';
      var name = String(it.name||'');
      if (!code || !name) continue;
      var keys = codeKeys(code);
      for (var k=0;k<keys.length;k++){ var key = keys[k]; if (!(key in idx)) idx[key] = name; }
    }
    window.__CODE_IDX_UNIFIED_STRICT = idx;
    return idx;
  }
  function ensureIndexReady(){
    if (!window.__CODE_IDX_UNIFIED_STRICT) return buildUnifiedIndex();
    // If items length grew, rebuild (in case items arrived later)
    var currentLen = (getItemsList()||[]).length;
    if (typeof window.__IDX_LEN === 'number' && currentLen !== window.__IDX_LEN){
      return buildUnifiedIndex();
    }
    return window.__CODE_IDX_UNIFIED_STRICT;
  }

  // Listen for postMessage from iframe to rebuild when items arrive
  window.addEventListener('message', function(ev){
    try{
      var d = ev && ev.data;
      if (d && d.__splitData && d.key === 'items' && Array.isArray(d.data)){
        window.items = d.data; window.ITEMS = d.data; window.__IDX_LEN = d.data.length;
        buildUnifiedIndex();
      }
    }catch(e){}
  }, false);

  // Force selector to have: '장식/특수', FIRE (if present), and keep others as-is
  function enforceUnifiedSelector(){
    var sel = $('codePartSelectInline');
    if (!sel) return;
    var keep = [];
    var hasFire = false, needUnified = false;

    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      var v = opt && (opt.value || '');
      var label = opt && (opt.textContent || opt.text || v);
      if (!v) continue;
      if (label === FIRE || v === FIRE){ hasFire = true; continue; }
      if (isAccOrSpecLabel(v) || isAccOrSpecLabel(label)){ needUnified = true; continue; }
      keep.push({v:v, t:label});
    }

    while (sel.firstChild) sel.removeChild(sel.firstChild);
    if (needUnified){
      var o = document.createElement('option'); o.value = '장식/특수'; o.textContent = '장식/특수'; sel.appendChild(o);
    }
    if (hasFire){
      var f = document.createElement('option'); f.value = FIRE; f.textContent = FIRE; sel.appendChild(f);
    }
    for (var j=0;j<keep.length;j++){ var k = document.createElement('option'); k.value = keep[j].v; k.textContent = keep[j].t; sel.appendChild(k); }
  }

  // Patch functions that repopulate the selector
  (function patchPopulators(){
    var ensured = false;
    function wrap(fnName){
      var orig = window[fnName];
      if (typeof orig !== 'function') return;
      if (orig.__wrappedV14) return;
      window[fnName] = function(){
        var r = orig.apply(this, arguments);
        try{ enforceUnifiedSelector(); }catch(e){}
        return r;
      };
      window[fnName].__wrappedV14 = true;
      ensured = true;
    }
    wrap('populatePartSelect');
    wrap('copyPartOptionsInline');
    if (!ensured){
      // fallback: late bind
      setTimeout(patchPopulators, 400);
    }
  })();

  // Observe selector for later mutations
  function observeSelector(){
    var sel = $('codePartSelectInline'); if (!sel || sel.__obsV14) return;
    var obs = new MutationObserver(function(){ try{ enforceUnifiedSelector(); }catch(e){} });
    obs.observe(sel, {childList:true, subtree:false});
    sel.__obsV14 = true;
  }

  // Apply handler: if '장식/특수', use unified index (on-demand ensure)
  function bindApply(){
    var btn = $('applyCodesBtnInline'); if (!btn || btn.__bindV14) return;
    btn.__bindV14 = true;
    btn.addEventListener('click', function(ev){
      var sel = $('codePartSelectInline'); var ta = $('ownedInput'); var inp = $('codeNumbersInline');
      if (!sel || !ta) return;
      if (sel.value !== '장식/특수') return; // not ours
      ev.stopPropagation(); ev.preventDefault();

      function parseCodes(text){
        return (String(text||'').match(/\d+/g) || []).map(function(s){
          s = String(s||'').trim(); var n = s.replace(/^0+/, ''); return n.length ? n : '0';
        });
      }
      function norm(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }

      var fromInline = parseCodes(inp ? inp.value : '');
      var fromTextarea = (document.querySelector('input[name="ownedMode"]:checked')?.value === 'code') ? parseCodes(ta.value) : [];
      var codes = fromInline.length ? fromInline : fromTextarea;
      if (!codes.length){ alert('코드 입력이 비어있습니다. 코드번호를 입력하거나 붙여넣어 주세요.'); return; }

      var idx = ensureIndexReady();
      var namesToAdd = [];
      for (var i=0;i<codes.length;i++){
        var c = codes[i];
        var forms = (function(raw){ var list=[raw, raw.replace(/^0+/, '')||'0']; var d=raw.replace(/\D+/g,'')||''; if(d){ list.push(d, d.replace(/^0+/, '')||'0'); } return list; })(c);
        var nm = null;
        for (var k=0;k<forms.length;k++){ nm = idx[forms[k]]; if (nm) break; }
        if (nm) namesToAdd.push(nm);
      }
      if (!namesToAdd.length){ alert('일치하는 코드가 없습니다. (장식/특수 통합)'); return; }

      var owned = String(ta.value||'').split(/[\n\r;,,]+|\s{2,}/g).map(function(s){ return s.trim(); }).filter(Boolean);
      var set = new Set(owned.map(norm));
      for (var j=0;j<namesToAdd.length;j++){ var k = norm(namesToAdd[j]); if (!set.has(k)){ set.add(k); owned.push(namesToAdd[j]); } }
      ta.value = owned.join('\n');
      try{ if (typeof window.updateOwnedBadges==='function') window.updateOwnedBadges(); }catch(e){}
      try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){}

      var t = $('toast'); if (t){ t.textContent = '코드 적용: ' + namesToAdd.length + '개'; t.classList.add('show'); setTimeout(function(){ t.classList.remove('show'); }, 1200); }
    }, true);
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(enforceUnifiedSelector, 0);
    setTimeout(enforceUnifiedSelector, 200);
    setTimeout(enforceUnifiedSelector, 600);
    setTimeout(observeSelector, 0);
    setTimeout(bindApply, 0);
    setTimeout(bindApply, 200);
    setTimeout(bindApply, 600);
    // async rebuild as items may load later via iframe
    setTimeout(ensureIndexReady, 800);
    setInterval(function(){ try{ ensureIndexReady(); }catch(e){} }, 1500); // light periodic guard
  }, false);
})();
</script>

<!-- === PATCH v15: Unify '양말' + '양말장식' for code input (2025-10-19) === -->
<script>
(function(){
  'use strict';
  if (window.__SOCKS_UNIFY_V15__) return;
  window.__SOCKS_UNIFY_V15__ = true;

  function $(id){ return document.getElementById(id); }
  var FIRE = '반딧불의 영혼';

  function codeKeys(code){
    var raw = String(code||'').trim(); if (!raw) return [];
    var noLead = raw.replace(/^0+/, '') || '0';
    var digits = raw.replace(/\D+/g, '') || '';
    var digitsNoLead = digits ? (digits.replace(/^0+/, '') || '0') : '';
    var set = Object.create(null);
    function add(k){ if(k && !set[k]) set[k]=true; }
    add(raw); add(noLead); add(digits); add(digitsNoLead);
    return Object.keys(set);
  }

  function getItemsList(){
    var list = Array.isArray(window.items) ? window.items : (Array.isArray(window.ITEMS) ? window.ITEMS : []);
    return Array.isArray(list) ? list : [];
  }

  // --- 1) Selector: collapse '양말' and '양말장식' into single option ---
  function enforceSocksUnifiedInSelector(){
    var sel = $('codePartSelectInline'); if (!sel) return;
    var keep = [];
    var hasUnifiedAccSpec = false, hasFire = false, needSocksUnified = false;

    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      var v = opt && (opt.value || '');
      var label = opt && (opt.textContent || opt.text || v);
      if (!v) continue;

      if (v === '장식/특수') { hasUnifiedAccSpec = true; keep.push({v:v, t:label}); continue; }
      if (v === FIRE || label === FIRE) { hasFire = true; continue; }

      if (v === '양말' || v === '양말장식' || label === '양말' || label === '양말장식'){
        needSocksUnified = true;
        continue; // will replace with unified option
      }
      keep.push({v:v, t:label});
    }

    while (sel.firstChild) sel.removeChild(sel.firstChild);

    // Keep existing '장식/특수' (if present)
    if (hasUnifiedAccSpec){
      var a = document.createElement('option'); a.value = '장식/특수'; a.textContent = '장식/특수'; sel.appendChild(a);
    }
    // Insert unified socks option if needed
    if (needSocksUnified){
      var s = document.createElement('option'); s.value = '양말/양말장식'; s.textContent = '양말/양말장식'; sel.appendChild(s);
    }
    // Keep '반딧불의 영혼' right after
    if (hasFire){
      var f = document.createElement('option'); f.value = FIRE; f.textContent = FIRE; sel.appendChild(f);
    }
    // Append others
    for (var j=0;j<keep.length;j++){
      var k = document.createElement('option'); k.value = keep[j].v; k.textContent = keep[j].t; sel.appendChild(k);
    }
  }

  // Patch populators so any later repopulation is re-collapsed
  (function patchPopulators(){
    function wrap(name){
      var orig = window[name];
      if (typeof orig !== 'function' || orig.__socksWrappedV15) return;
      window[name] = function(){
        var r = orig.apply(this, arguments);
        try{ enforceSocksUnifiedInSelector(); }catch(e){}
        return r;
      };
      window[name].__socksWrappedV15 = true;
    }
    wrap('populatePartSelect');
    wrap('copyPartOptionsInline');
    setTimeout(function(){ wrap('populatePartSelect'); wrap('copyPartOptionsInline'); }, 400);
  })();

  // Observe selector for childList mutations
  (function observe(){
    var sel = $('codePartSelectInline'); if (!sel || sel.__socksObsV15) return;
    var obs = new MutationObserver(function(){ try{ enforceSocksUnifiedInSelector(); }catch(e){} });
    obs.observe(sel, {childList:true, subtree:false});
    sel.__socksObsV15 = true;
  })();

  // --- 2) Build socks unified index ---
  function buildSocksIndex(){
    var list = getItemsList();
    var idx = Object.create(null);
    for (var i=0;i<list.length;i++){
      var it = list[i] || {};
      var part = String(it.part||'');
      if (!(part === '양말' || part === '양말장식')) continue;
      var code = (it.code!=null) ? String(it.code) : '';
      var name = String(it.name||'');
      if (!code || !name) continue;
      var keys = codeKeys(code);
      for (var k=0;k<keys.length;k++){ var key = keys[k]; if (!(key in idx)) idx[key] = name; }
    }
    window.__CODE_IDX_SOCKS_UNIFIED = idx;
    return idx;
  }

  function ensureSocksIndex(){
    if (!window.__CODE_IDX_SOCKS_UNIFIED) return buildSocksIndex();
    return window.__CODE_IDX_SOCKS_UNIFIED;
  }

  // Rebuild index once items list arrives/changes
  window.addEventListener('message', function(ev){
    try{
      var d = ev && ev.data;
      if (d && d.__splitData && d.key === 'items' && Array.isArray(d.data)){
        window.items = d.data; window.ITEMS = d.data;
        buildSocksIndex();
      }
    }catch(e){}
  }, false);

  // --- 3) Apply handler for socks unified option ---
  function bind(){
    var btn = $('applyCodesBtnInline'); if (!btn || btn.__socksBindV15) return;
    btn.__socksBindV15 = true;
    btn.addEventListener('click', function(ev){
      var sel = $('codePartSelectInline'); var ta = $('ownedInput'); var inp = $('codeNumbersInline');
      if (!sel || !ta) return;
      if (sel.value !== '양말/양말장식') return; // not ours
      ev.stopPropagation(); ev.preventDefault();

      function parseCodes(text){
        return (String(text||'').match(/\d+/g) || []).map(function(s){
          s = String(s||'').trim(); var n = s.replace(/^0+/, ''); return n.length ? n : '0';
        });
      }
      function norm(s){ return String(s||'').normalize('NFKC').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }

      var fromInline = parseCodes(inp ? inp.value : '');
      var fromTextarea = (document.querySelector('input[name="ownedMode"]:checked')?.value === 'code') ? parseCodes(ta.value) : [];
      var codes = fromInline.length ? fromInline : fromTextarea;
      if (!codes.length){ alert('코드 입력이 비어있습니다. 코드번호를 입력하거나 붙여넣어 주세요.'); return; }

      var idx = ensureSocksIndex();
      var namesToAdd = [];
      for (var i=0;i<codes.length;i++){
        var c = codes[i];
        var forms = [c, c.replace(/^0+/, '')||'0'];
        var d = c.replace(/\D+/g, '')||''; if (d){ forms.push(d, d.replace(/^0+/, '')||'0'); }
        var nm = null;
        for (var k=0;k<forms.length;k++){ nm = idx[forms[k]]; if (nm) break; }
        if (nm) namesToAdd.push(nm);
      }
      if (!namesToAdd.length){ alert('일치하는 코드가 없습니다. (양말/양말장식 통합)'); return; }

      var owned = String(ta.value||'').split(/[\n\r;,,]+|\s{2,}/g).map(function(s){ return s.trim(); }).filter(Boolean);
      var set = new Set(owned.map(norm));
      for (var j=0;j<namesToAdd.length;j++){ var k = norm(namesToAdd[j]); if (!set.has(k)){ set.add(k); owned.push(namesToAdd[j]); } }
      ta.value = owned.join('\n');
      try{ if (typeof window.updateOwnedBadges==='function') window.updateOwnedBadges(); }catch(e){}
      try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){}

      var t = $('toast'); if (t){ t.textContent = '코드 적용: ' + namesToAdd.length + '개'; t.classList.add('show'); setTimeout(function(){ t.classList.remove('show'); }, 1200); }
    }, true);
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(enforceSocksUnifiedInSelector, 0);
    setTimeout(enforceSocksUnifiedInSelector, 200);
    setTimeout(enforceSocksUnifiedInSelector, 600);
    setTimeout(bind, 0); setTimeout(bind, 200); setTimeout(bind, 600);
    // build once; postMessage listener will refresh later if needed
    try{ buildSocksIndex(); }catch(e){}
  }, false);
})();
</script>

<!-- === PATCH v16: De-duplicate '장식/특수' option & sanitize selector (2025-10-19) === -->
<script>
(function(){
  'use strict';
  if (window.__DEDUP_UNIFIED_OPTS_V16__) return;
  window.__DEDUP_UNIFIED_OPTS_V16__ = true;

  function $(id){ return document.getElementById(id); }
  var FIRE = '반딧불의 영혼';
  var UNIFIED = '장식/특수';

  function sanitizeSelector(){
    var sel = $('codePartSelectInline'); if (!sel) return;

    // Collect unique options (value/text normalized), but with custom order:
    // 1) '장식/특수' (at most one)
    // 2) '반딧불의 영혼' (at most one, immediately after 1 if present)
    // 3) All others in first-appearance order (excluding '(자동)' variants and accessory/special subparts)
    var seen = Object.create(null);
    var others = [];
    var hasUnified = false, hasFire = false;

    function norm(s){ return String(s||'').normalize('NFKC').trim(); }
    function isAutoLabel(s){ return /\(자동\)/.test(String(s||'')); }
    function isAccSpecSub(v){
      v = String(v||'').trim();
      return /^장식\s*-/.test(v) || v.indexOf('특수') !== -1 ||
             ['머리','베일','헤어핀','귀장식','귀','목도리','목걸이','팔찌(우)','팔찌(좌)','장갑','소품(우)','소품(좌)','양손','허리'].includes(v);
    }

    for (var i=0;i<sel.options.length;i++){
      var opt = sel.options[i];
      var v = norm(opt.value || '');
      var t = norm(opt.textContent || opt.text || v);
      if (!v) continue;

      // kill any '(자동)' labels
      if (isAutoLabel(v) || isAutoLabel(t)) continue;

      if (v === UNIFIED || t === UNIFIED){ hasUnified = true; continue; }
      if (v === FIRE || t === FIRE){ hasFire = true; continue; }

      // Drop accessory/special subparts from this selector
      if (isAccSpecSub(v) || isAccSpecSub(t)) continue;

      var key = v + '::' + t;
      if (!seen[key]){ seen[key] = true; others.push({v:v, t:t}); }
    }

    // Rebuild list
    while (sel.firstChild) sel.removeChild(sel.firstChild);
    if (hasUnified){
      var a = document.createElement('option'); a.value = UNIFIED; a.textContent = UNIFIED; sel.appendChild(a);
    }
    if (hasFire){
      var f = document.createElement('option'); f.value = FIRE; f.textContent = FIRE; sel.appendChild(f);
    }
    for (var j=0;j<others.length;j++){
      var o = document.createElement('option'); o.value = others[j].v; o.textContent = others[j].t; sel.appendChild(o);
    }
  }

  function observe(){
    var sel = $('codePartSelectInline'); if (!sel || sel.__dedupObsV16) return;
    var obs = new MutationObserver(function(){ try{ sanitizeSelector(); }catch(e){} });
    obs.observe(sel, {childList:true, subtree:false});
    sel.__dedupObsV16 = true;
  }

  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(sanitizeSelector, 0);
    setTimeout(sanitizeSelector, 200);
    setTimeout(sanitizeSelector, 600);
    setTimeout(observe, 0);
  }, false);
})();
</script>

<!-- === v19: Stage-strict scoring with STAR×GRADE multipliers (matches requested per-item scores) === -->
<script>
(function(){
  if (window.__v19StageStrictApplied) return;
  window.__v19StageStrictApplied = true;

  // Tuned so that:
  //  - 记者的衣橱·蓝 (2★, 상의) @ 1-2 ≈ 6,835.34
  //  - 碎珠 (3★, 하의) @ 1-2 ≈ 4,551.91
  const STAR_MULT = {1:1.12, 2:1.20, 3:1.27, 4:1.33, 5:1.40, 6:1.48};
  const GRADE_OFFSET = 0.06; // multiplicative (+6%)

  function num(v){ var n = Number(v); return Number.isFinite(n)? n : 0; }
  function getStars(item){
    var s = num(item && item.stars);
    if (!s && item && typeof item.stars === 'string'){
      var m = String(item.stars).match(/\d+/);
      if (m) s = num(m[0]);
    }
    return s || 0;
  }

  // Prefer a clean, pre-scaled scorer if present (saved by earlier patches)
  var CLEAN_BASE = (typeof window.__ORIG_scoreItemForStage === 'function')
                   ? window.__ORIG_scoreItemForStage
                   : (typeof window.scoreItemForStage === 'function' ? window.scoreItemForStage : function(){ return 0; });

  // Final scorer: base(stage-strict) * (1+GRADE_OFFSET) * STAR_MULT
  window.scoreItemForStage = function(item, stage){
    try{
      var base = num(CLEAN_BASE(item, stage));
      var s = getStars(item);
      var m = (STAR_MULT.hasOwnProperty(s) ? STAR_MULT[s] : 1.0);
      return base * (1 + GRADE_OFFSET) * m;
    }catch(e){
      try{ return num(CLEAN_BASE(item, stage)); }catch(_){ return 0; }
    }
  };

  // Trigger a rerender to show new scores
  setTimeout(function(){ try{ if (typeof window.renderAll==='function') window.renderAll(); }catch(e){} }, 30);
})();
</script>

<!-- === v19b: SAFE scorer (stage-strict 0 for others) + STAR × GRADE, no dependency on old functions === -->
<script>
(function(){
  if (window.__v19bSafeScorerApplied) return;
  window.__v19bSafeScorerApplied = true;

  // ----- Tunables (match your observed numbers) -----
  const STAR_MULT = {1:1.12, 2:1.20, 3:1.27, 4:1.33, 5:1.40, 6:1.48};
  const GRADE_OFFSET = 0.06; // multiplicative +6%

  // Attribute grade table (if item stores letters like "A", "S", etc.)
  const GRADE_SCORES = {
    "SS": 2612.7, "S": 2070.75, "A": 1690.65, "B": 1309.8, "C": 930.375
  };

  // Recognized attribute keys (superset; others ignored)
  const ATTR_KEYS = [
    "simple","cute","pure","warm","elegant",
    "lively","cool","sexy","mature","flair","mature"
  ];

  // Part multipliers (Korean labels)
  const PART_MULT = {
    "원피스": 2.0,
    "상의": 1.0,
    "하의": 1.0,
    "아우터": 0.8,
    "헤어": 1.0,
    "신발": 0.8,
    "양말": 0.5,
    "양말장식": 0.2,
    "장식": 0.2
  };

  function num(v){ var n = Number(v); return Number.isFinite(n) ? n : 0; }

  function valOf(attrVal){
    if (attrVal == null) return 0;
    if (typeof attrVal === "number") return attrVal;
    // letter grade?
    var s = String(attrVal).trim().toUpperCase();
    if (GRADE_SCORES.hasOwnProperty(s)) return GRADE_SCORES[s];
    // not a known grade, try numeric parse
    var n = Number(s);
    return Number.isFinite(n) ? n : 0;
  }

  function starMult(stars){
    var s = num(stars);
    return STAR_MULT.hasOwnProperty(s) ? STAR_MULT[s] : 1.0;
  }

  function partMult(part){
    if (!part) return 1.0;
    // direct match
    if (PART_MULT.hasOwnProperty(part)) return PART_MULT[part];
    // contains
    for (var k in PART_MULT){
      if (part.indexOf(k) !== -1) return PART_MULT[k];
    }
    return 1.0;
  }

  function getStageWeights(stage){
    if (!stage || typeof stage !== "object") return {};
    // support both {simple:1.33,...} and {weights:{...}}
    if (stage.weights && typeof stage.weights === "object") return stage.weights;
    return stage;
  }

  function baseStageStrictScore(item, stage){
    var w = getStageWeights(stage);
    var sum = 0;
    for (var i=0;i<ATTR_KEYS.length;i++){
      var key = ATTR_KEYS[i];
      var weight = num(w[key]); // if undefined -> 0
      if (!weight) continue;    // stage에 없는 속성은 바로 0점
      var val = valOf(item && item[key]);
      if (!val) continue;
      sum += val * weight;
    }
    // multiply by part multiplier (원피스 2.0 등)
    var pm = partMult(item && item.part);
    return sum * pm;
  }

  // Final scorer = base(stage-strict) × (1+GRADE_OFFSET) × STAR_MULT
  window.scoreItemForStage = function(item, stage){
    try{
      var base = baseStageStrictScore(item, stage) || 0;
      var mult = (1 + GRADE_OFFSET) * starMult(item && item.stars);
      return base * mult;
    }catch(e){
      return 0;
    }
  };

  // Optional: trigger re-render if app exposes renderer
  setTimeout(function(){
    try{
      if (typeof window.renderAll === 'function') window.renderAll();
      else if (typeof window.render === 'function') window.render();
    }catch(e){}
  }, 30);
})();
</script>

<!-- === v19c: Force [1-2] stage to use only {simple:1.33, cute:1, pure:1, warm:1, elegant:1} === -->
<script>
(function(){
  if (window.__v19cStrict12Applied) return;
  window.__v19cStrict12Applied = true;

  // reuse scorer from v19b if present
  var prevScorer = window.scoreItemForStage;

  // canonical 1-2 weights
  var W12 = { simple:1.33, cute:1.0, pure:1.0, warm:1.0, elegant:1.0 };

  function looksLike12(stage){
    // Accept various id/name formats containing "1-2" (dash or unicode hyphens)
    var s = "";
    try{
      if (stage && typeof stage === "object"){
        s = String(stage.stage_id || stage.name || stage.id || "");
      } else {
        s = String(stage || "");
      }
    }catch(e){}
    s = s || "";
    return /(^|\s|\[|\()1[\-－‑–—]2(\s|$|\]|\))/u.test(s);
  }

  window.scoreItemForStage = function(item, stage){
    try{
      if (looksLike12(stage)){
        // Build a minimal stage object that has ONLY the 5 keys
        var st = {weights: W12};
        return prevScorer ? prevScorer(item, st) : 0;
      } else {
        return prevScorer ? prevScorer(item, stage) : 0;
      }
    }catch(e){
      try{ return prevScorer ? prevScorer(item, stage) : 0; }catch(_){ return 0; }
    }
  };

  setTimeout(function(){
    try{
      if (typeof window.renderAll==='function') window.renderAll();
      else if (typeof window.render==='function') window.render();
    }catch(e){}
  }, 30);
})();
</script>

<script>
/* PAGINATION PATCH v2: force renderAll -> render so paging cannot be bypassed */
(function(){
  try{
    window.renderAll = function(){ try{ if(typeof window.render==='function') window.render(); }catch(e){} };
  }catch(e){}
})();
</script>


<!-- === PATCH: mine_items always zero (final wrapper) === -->
<script>
(function(){
  if (window.__mineZeroFinalApplied) return;
  window.__mineZeroFinalApplied = true;

  function normMine(s){
    try{
      return String(s||'')
        .normalize('NFKC')
        .toLowerCase()
        .replace(/\s+/g,'')
        // common middle-dot variants
        .replace(/[・‧·．\.]/g,'·');
    }catch(e){
      try{ return String(s||'').toLowerCase().replace(/\s+/g,''); }catch(_){ return ''; }
    }
  }

  function isMined(item, stage){
    try{
      if (!stage || !Array.isArray(stage.mine_items) || !stage.mine_items.length) return false;
      var nm = normMine(item && item.name);
      if (!nm) return false;
      // build/set cache per stage object
      if (!stage.__mineNameSet){
        try{
          var set = new Set();
          stage.mine_items.forEach(function(x){
            var k = normMine(x);
            if (k) set.add(k);
          });
          Object.defineProperty(stage, '__mineNameSet', {value:set, enumerable:false, configurable:true});
        }catch(e){
          stage.__mineNameSet = null;
        }
      }
      if (stage.__mineNameSet && stage.__mineNameSet.has(nm)) return true;
      // fallback direct includes (original behavior)
      var raw = (item && item.name) ? String(item.name).trim() : '';
      return stage.mine_items.includes(raw);
    }catch(e){ return false; }
  }

  var prev = window.scoreItemForStage;
  window.scoreItemForStage = function(item, stage){
    try{
      if (isMined(item, stage)) return 0;
      return (typeof prev === 'function') ? prev(item, stage) : 0;
    }catch(e){
      try{ return (typeof prev === 'function') ? prev(item, stage) : 0; }catch(_){ return 0; }
    }
  };
})();
</script>
</body>
</html>
<script>(function(){if(!window.__bootDone){window.__bootDone=false;}function canInit(){try{return Array.isArray(window.items)&&window.items.length>0&&Array.isArray(window.stages)&&window.stages.length>0;}catch(e){return false;}}function tryInitNow(){if(window.__bootDone)return;if(canInit()){window.__bootDone=true;if(typeof init==='function')init();return true;}return false;}document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};if(tryInitNow())return;let n=0;const t=setInterval(function(){n++;if(tryInitNow()||n>30){clearInterval(t);}},200);});window.addEventListener('load',tryInitNow);window.addEventListener('message',function(){setTimeout(tryInitNow,0);},true);})();</script>
<script>(function(){function ex(h){const m=h.match(/var\s+data\s*=\s*(\[[\s\S]*?\]);/);return m?m[1]:null;}async function fetchArr(u){try{const r=await fetch(u,{credentials:'same-origin'});if(!r.ok)return null;const h=await r.text();const t=ex(h);if(!t)return null;const a=Function('\"use strict\";return ('+t+')')();return Array.isArray(a)?a:null;}catch(_){return null;}}async function go(){if(!(window.items&&window.items.length)){const a=await fetchArr('items_frame_v2.html');if(a){window.items=a;items=window.items;if(window.got)window.got.items=true;}}if(!(window.stages&&window.stages.length)){const a2=await fetchArr('stages_frame_v2.html');if(a2){window.stages=a2;stages=window.stages;if(window.got)window.got.stages=true;}}if(typeof maybeInit==='function')maybeInit();}document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};setTimeout(go,800);});})();</script>
<script>// Iframe onload fallback
(function(){function ex(h){const m=h&&h.match(/var\s+data\s*=\s*(\[[\s\S]*?\]);/);return m?m[1]:null;}function parseIF(f){try{const d=f&&f.contentDocument;const h=d&&d.documentElement&&d.documentElement.innerHTML;const t=ex(h||'');if(!t)return null;const a=Function('\"use strict\";return ('+t+')')();return Array.isArray(a)?a:null;}catch(_){return null;}}function go(){var i=document.querySelector('iframe[src="./items_frame_v2.html"]');var s2=document.querySelector('iframe[src="./stages_frame_v2.html"]');if(i&&!(window.items&&window.items.length)){var a=parseIF(i);if(a){window.items=a;items=window.items;if(window.got)window.got.items=true;}}if(s2&&!(window.stages&&window.stages.length)){var a2=parseIF(s2);if(a2){window.stages=a2;stages=window.stages;if(window.got)window.got.stages=true;}}if(typeof maybeInit==='function')maybeInit();}window.addEventListener('load',function(){setTimeout(go,400);});document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};var i=document.querySelector('iframe[src="./items_frame_v2.html"]');var s2=document.querySelector('iframe[src="./stages_frame_v2.html"]');function onIF(){setTimeout(go,50);}if(i)i.addEventListener('load',onIF);if(s2)s2.addEventListener('load',onIF);});})();</script>
<script>
(function(){
  function hasData(a){ return Array.isArray(a) && a.length>0; }
  function refreshCountsNow(){
    try{
      if (typeof computeOwnedTotal === 'function'){
        var res = computeOwnedTotal();
        var badge = document.querySelector('#ownedSummary strong');
        if (badge) badge.textContent = '보유 ' + res.owned + ' / 전체 ' + (res.total||0);
      }
      if (typeof renderPartCounts === 'function') renderPartCounts();
    }catch(e){ console.warn('refreshCountsNow', e); }
  }
  // Recompute on textarea typing/paste
  document.addEventListener('DOMContentLoaded', function(){ try{ if(window._loading) window._loading.show(true);}catch(e){}; try{ if(typeof renderAll==='function') renderAll(); }catch(e){};
    var ta = document.getElementById('ownedInput');
    if (ta){
      ['input','change','blur'].forEach(function(ev){
        ta.addEventListener(ev, function(){ setTimeout(refreshCountsNow,0); });
      });
    }
  });

  // Re-render when datasets arrive via postMessage
  window.addEventListener('message', function(ev){
    var d = ev && ev.data;
    if (!d || !d.__splitData) return;
    // Give original handlers a tick to assign window.items/stages
    setTimeout(function(){
      if (typeof renderAll === 'function' && hasData(window.items) && hasData(window.stages)){
        renderAll(); refreshCountsNow();
      }
    },0);
  }, true);
})();
</script>
<!-- STRONG FIX: override updateOwnedBadges with robust totals + observers (keeps calc as first tab) -->
<script>
(function(){
  function getItemsTotal(){
    try{
      if (Array.isArray(window.ITEMS) && window.ITEMS.length) return window.ITEMS.length;
      if (Array.isArray(window.items) && window.items.length) return window.items.length;
    }catch(e){}
    try{ return document.querySelectorAll('.card').length || 0; }catch(e){}
    return 0;
  }
  function norm(s){ return String(s||'').toLowerCase().replace(/[\s\u00A0]+/g,' ').trim(); }
  function parseOwned(text){ return String(text||'').split(/[\n\r;,]+|\s{2,}/g).map(function(s){return s.trim();}).filter(Boolean); }
  function getOwnedCount(){
    var src = Array.isArray(window.ITEMS)&&window.ITEMS.length? window.ITEMS : (Array.isArray(window.items)? window.items : []);
    var by = Object.create(null);
    for (var i=0;i<src.length;i++){ var k = norm(src[i] && src[i].name); if(k && !(k in by)) by[k]=true; }
    var ta = document.getElementById('ownedInput'); var names = ta ? Array.from(new Set(parseOwned(ta.value))) : [];
    var n=0; for (var j=0;j<names.length;j++){ var k=norm(names[j]); if(k && (k in by)) n++; }
    return n;
  }
  // Override
  window.updateOwnedBadges = (function(ORIG){
    return function(){
      try{
        var total = getItemsTotal() + GRADE_OFFSET[item.grade];
        var owned = getOwnedCount();
        var el1 = document.getElementById('ownedSummary');
        var el2 = document.getElementById('ownedSummaryMini');
        if (el1) el1.textContent = '보유 ' + owned + ' / 전체 ' + total;
        if (el2) el2.textContent = '보유 ' + owned + ' / 전체 ' + total;
        // store diag
        if (el2) el2.title = 'ITEMS:' + (Array.isArray(window.ITEMS)?window.ITEMS.length:0)
                            + ' items:' + (Array.isArray(window.items)?window.items.length:0)
                            + ' cards:' + (function(){try{return document.querySelectorAll(".card").length||0;}catch(e){return 0;}})();
      }catch(e){ try{ if(typeof ORIG==='function') ORIG(); }catch(_){ } }
    };
  })(window.updateOwnedBadges);
  // Trigger updates at useful times
  function tick(){ try{ updateOwnedBadges(); }catch(e){} }
  window.addEventListener('load', function(){ setTimeout(tick,50); setTimeout(tick,300); setTimeout(tick,1000); });
  window.addEventListener('message', function(ev){ var m=ev.data||{}; if(m.__splitData && (m.key==='items'||m.key==='stages')){ setTimeout(tick,0); setTimeout(tick,200); setTimeout(tick,800);} });
  // Mutation observer on cards container
  try{
    var mo = new MutationObserver(function(){ tick(); });
    mo.observe(document.body, { childList:true, subtree:true });
  }catch(e){}
})();
</script>


<!-- === Pagination patch (2026-01-07): show 24 items per page in 추천/점수 card list === -->
<style>
  #pagerBar{padding:6px 20px 12px 20px; display:none; align-items:center; gap:8px; flex-wrap:wrap;}
  #pagerBar .pinfo{font-size:12px;color:#666;margin-right:6px}
  #pagerBar button{padding:6px 10px;border:1px solid #ddd;border-radius:999px;background:#fff;cursor:pointer}
  #pagerBar button:hover{background:#fafafa}
  #pagerBar button[disabled]{opacity:.5;cursor:not-allowed}
  #pagerBar button.is-on{background:#f0f7ff;border-color:#cfe4ff;font-weight:700}
</style>
<script>
(function(){
  'use strict';
  if (window.__NIKKI_PAGINATION_PATCH__) return;
  window.__NIKKI_PAGINATION_PATCH__ = true;

  const PAGE_SIZE = 24;

  const $ = (id)=> document.getElementById(id);

  function norm(s){
    try{
      if (typeof window.normOwnedName === 'function') return window.normOwnedName(s);
    }catch(e){}
    return String(s||'').toLowerCase().replace(/\\s+/g,'').trim();
  }

  function ensurePagerBar(){
    let bar = $('pagerBar');
    if (bar) return bar;
    const listEl = $('list');
    if (!listEl) return null;
    bar = document.createElement('div');
    bar.id = 'pagerBar';
    bar.innerHTML = '<span class="pinfo" id="pagerInfo"></span><span id="pagerBtns" style="display:flex;gap:6px;flex-wrap:wrap;align-items:center"></span>';
    // insert right before list
    listEl.parentNode.insertBefore(bar, listEl);
    return bar;
  }

  const state = window.__pagerState || (window.__pagerState = { page: 1, key: '' });

  function activeKey(){
    const stageId = $('stageSelect') ? $('stageSelect').value : '';
    const part = $('partFilter') ? $('partFilter').value : '';
    const ownedOnly = $('ownedOnly') ? !!$('ownedOnly').checked : false;
    const sortBy = $('sortBy') ? $('sortBy').value : '';
    const tagsText = $('activeTags') ? ($('activeTags').textContent||'').trim() : '';
    return [stageId, part, ownedOnly ? '1':'0', sortBy, tagsText].join('|');
  }

  function clampPage(p, totalPages){
    let x = Number(p)||1;
    if (x < 1) x = 1;
    if (x > totalPages) x = totalPages;
    return x;
  }

  function renderPager(totalItems, totalPages){
    const bar = ensurePagerBar();
    if (!bar) return;
    const info = $('pagerInfo');
    const btns = $('pagerBtns');
    if (!btns) return;

    if (totalItems <= PAGE_SIZE){
      bar.style.display = 'none';
      return;
    }
    bar.style.display = 'flex';
    if (info) info.textContent = `총 ${totalItems}개 · ${state.page}/${totalPages}페이지`;

    const mkBtn = (label, page, disabled, isOn)=> {
      const b = document.createElement('button');
      b.type = 'button';
      b.textContent = label;
      if (page != null) b.dataset.page = String(page);
      if (disabled) b.disabled = true;
      if (isOn) b.classList.add('is-on');
      return b;
    };

    btns.innerHTML = '';

    // Prev
    btns.appendChild(mkBtn('이전', state.page-1, state.page<=1, false));

    // Page numbers (compact)
    const maxNums = 7;
    let start = Math.max(1, state.page - Math.floor(maxNums/2));
    let end = start + maxNums - 1;
    if (end > totalPages){ end = totalPages; start = Math.max(1, end - maxNums + 1); }

    if (start > 1){
      btns.appendChild(mkBtn('1', 1, false, state.page===1));
      if (start > 2) btns.appendChild(mkBtn('…', null, true, false));
    }

    for (let p = start; p <= end; p++){
      btns.appendChild(mkBtn(String(p), p, false, state.page===p));
    }

    if (end < totalPages){
      if (end < totalPages - 1) btns.appendChild(mkBtn('…', null, true, false));
      btns.appendChild(mkBtn(String(totalPages), totalPages, false, state.page===totalPages));
    }

    // Next
    btns.appendChild(mkBtn('다음', state.page+1, state.page>=totalPages, false));
  }

  // Click handler for pager
  document.addEventListener('click', function(ev){
    const btn = ev.target && ev.target.closest && ev.target.closest('#pagerBar button[data-page]');
    if (!btn) return;
    const p = Number(btn.dataset.page);
    if (!Number.isFinite(p)) return;
    state.page = p;
    try{ if (typeof window.render === 'function') window.render(); }catch(e){}
  }, false);

  // Reset page when filters change (stage/part/owned/sort/tag)
  document.addEventListener('change', function(ev){
    const t = ev && ev.target;
    if (!t) return;
    const id = t.id || '';
    const inTags = !!(t.closest && t.closest('#tagsPanel'));
    if (id==='stageSelect' || id==='partFilter' || id==='ownedOnly' || id==='sortBy' || inTags || t.name==='tagMode'){
      state.page = 1;
    }
  }, false);

  // Render required panel (optional, safe)
  function renderReqPanelFromStage(stage){
    const panel = $('reqPanel');
    if(!panel) return;
    const rp = stage && stage.required_parts;
    if(!rp || typeof rp!=='object'){ panel.style.display='none'; panel.innerHTML=''; return; }
    const parts = Object.keys(rp).filter(k=> Array.isArray(rp[k]) && rp[k].length);
    if(!parts.length){ panel.style.display='none'; panel.innerHTML=''; return; }
    const rows = parts.map(p=>{
      const names = rp[p].map(n=> `<code>${String(n)}</code>`).join(', ');
      const label = (typeof window.displayShort==='function') ? window.displayShort(p) : p;
      return `<tr><th>${label}</th><td>${names}</td></tr>`;
    }).join('');
    panel.innerHTML = `<h3>추천아이템</h3><table class="req-table"><tbody>${rows}</tbody></table>`;
    panel.style.display='block';
  }

  // Our clean render override (cards only). Keeps existing tables untouched.
  const scoreSafe = (item, stage)=>{
    try{ return (typeof window.scoreItemForStage==='function') ? window.scoreItemForStage(item, stage) : 0; }
    catch(e){ return 0; }
  };

  window.render = function(){
    try{
      const stageSel = $('stageSelect');
      const stageId = stageSel ? stageSel.value : '';
      const stage = (window.stages||[]).find(s=> String(s.stage_id)===String(stageId)) || (window.stages||[])[0] || null;

      renderReqPanelFromStage(stage);

      const part = $('partFilter') ? $('partFilter').value : '';
      const sortBy = $('sortBy') ? $('sortBy').value : 'score';
      const ownedOnly = $('ownedOnly') ? !!$('ownedOnly').checked : false;

      let src = Array.isArray(window.items) ? window.items : [];
      let list = src.map(it=> Object.assign({}, it, { score: scoreSafe(it, stage) }));

      // part filter (exact match)
      if (part) list = list.filter(it=> String(it.part||'')===String(part));

      // owned filter
      if (ownedOnly){
        if (window.ownedNameSet instanceof Set){
          list = list.filter(it=> window.ownedNameSet.has(norm(it && it.name)));
        } else {
          list = list.filter(it=> it && it._owned === true);
        }
      }

      // required set (name-based)
      const reqSet = new Set();
      try{
        const rp = stage && stage.required_parts;
        if (rp && typeof rp==='object'){
          Object.keys(rp).forEach(p=>{
            const arr = Array.isArray(rp[p]) ? rp[p] : [];
            arr.forEach(n=> reqSet.add(norm(n)));
          });
        }
      }catch(e){}
      list = list.map(it=> Object.assign({}, it, { __req: reqSet.has(norm(it && it.name)) }));

      // sort
      if (sortBy === 'name'){
        list.sort((a,b)=> (b.__req - a.__req) || String(a.name||'').localeCompare(String(b.name||'')));
      } else {
        list.sort((a,b)=> (b.__req - a.__req) || (Number(b.score||0) - Number(a.score||0)));
      }

      const listEl = $('list');
      const empty = $('emptyState');
      if (!listEl) return;

      // pagination state
      const key = activeKey();
      if (state.key !== key){
        state.key = key;
        state.page = 1;
      }

      const totalItems = list.length;
      const totalPages = Math.max(1, Math.ceil(totalItems / PAGE_SIZE));
      state.page = clampPage(state.page, totalPages);

      const start = (state.page - 1) * PAGE_SIZE;
      const pageList = list.slice(start, start + PAGE_SIZE);

      if (totalItems === 0){
        listEl.style.display = 'none';
        if (empty) empty.style.display = 'block';
        // hide pager if empty
        const bar = $('pagerBar'); if (bar) bar.style.display = 'none';
        return;
      } else {
        listEl.style.display = 'grid';
        if (empty) empty.style.display = 'none';
      }

      // tags helper
      const toTags = (it)=>{
        try{
          if (typeof window.getItemTags === 'function'){
            const out = window.getItemTags(it);
            return Array.isArray(out) ? out : [];
          }
        }catch(e){}
        const raw = (it && it.tags) ? it.tags : '';
        if (Array.isArray(raw)) return raw;
        return String(raw||'').split(/[,\s#]+/).filter(Boolean);
      };

      listEl.innerHTML = pageList.map(it=>{
        const stars = Math.max(0, Math.min(6, Number(it.stars||0)));
        const tgs = toTags(it);
        const img = it.img ? `<img class="thumb" src="${it.img}" alt="${String(it.name||'')}">` : '';
        const reqBadge = it.__req ? `<span class="req-badge">추천</span>` : '';
        const safeName = String(it.name||'').replace(/\\/g,'\\\\').replace(/'/g,"\\'");
        const partLabel = (typeof window.displayShort==='function') ? window.displayShort(it.part) : (it.part||'-');
        return `<div class="card">
          <div class="row thumbrow">${img}<h3 style="margin:0;flex:1;display:flex;justify-content:space-between;align-items:center">
            <span>${String(it.name||'-')} ${reqBadge}</span>
            <button class="copy-btn" onclick="copyText('${safeName}')">이름 복사</button>
          </h3></div>
          <div class="badges">
            <span class="badge">${partLabel}</span>
            <span class="badge">${stars}★</span>
            ${it._owned ? '<span class="badge owned">보유</span>' : ''}
          </div>
          <div class="badges tags">${tgs.map(x=>`<span class='badge tag'>#${String(x)}</span>`).join('')}</div>
          <div class="score">점수: ${Number(it.score||0).toFixed(2)}</div>
        </div>`;
      }).join('');

      renderPager(totalItems, totalPages);
    }catch(e){
      // swallow
    }
  };

  // Try one render once everything is ready
  setTimeout(function(){
    try{
      if (typeof window.renderAll === 'function') window.renderAll();
      else if (typeof window.render === 'function') window.render();
    }catch(e){}
  }, 60);

})();
</script>

